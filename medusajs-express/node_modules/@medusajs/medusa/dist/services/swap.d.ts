export default SwapService;
declare const SwapService_base: any;
/**
 * Handles swaps
 * @extends BaseService
 */
declare class SwapService extends SwapService_base {
    [x: string]: any;
    static Events: {
        CREATED: string;
        RECEIVED: string;
        SHIPMENT_CREATED: string;
        PAYMENT_COMPLETED: string;
        PAYMENT_CAPTURED: string;
        PAYMENT_CAPTURE_FAILED: string;
        PROCESS_REFUND_FAILED: string;
        REFUND_PROCESSED: string;
        FULFILLMENT_CREATED: string;
    };
    constructor({ manager, swapRepository, eventBusService, cartService, totalsService, returnService, lineItemService, paymentProviderService, shippingOptionService, fulfillmentService, orderService, inventoryService, customShippingOptionService, }: {
        manager: any;
        swapRepository: any;
        eventBusService: any;
        cartService: any;
        totalsService: any;
        returnService: any;
        lineItemService: any;
        paymentProviderService: any;
        shippingOptionService: any;
        fulfillmentService: any;
        orderService: any;
        inventoryService: any;
        customShippingOptionService: any;
    });
    /** @private @const {EntityManager} */
    private manager_;
    /** @private @const {SwapModel} */
    private swapRepository_;
    /** @private @const {TotalsService} */
    private totalsService_;
    /** @private @const {LineItemService} */
    private lineItemService_;
    /** @private @const {ReturnService} */
    private returnService_;
    /** @private @const {PaymentProviderService} */
    private paymentProviderService_;
    /** @private @const {CartService} */
    private cartService_;
    /** @private @const {FulfillmentService} */
    private fulfillmentService_;
    /** @private @const {OrderService} */
    private orderService_;
    /** @private @const {ShippingOptionService} */
    private shippingOptionService_;
    /** @private @const {InventoryService} */
    private inventoryService_;
    /** @private @const {EventBusService} */
    private eventBus_;
    /** @private @const {CustomShippingOptionService} */
    private customShippingOptionService_;
    withTransaction(transactionManager: any): SwapService;
    transformQueryForTotals_(config: any): any;
    decorateTotals_(cart: any, totalsFields?: any[]): Promise<any>;
    /**
     * Retrieves a swap with the given id.
     * @param {string} id - the id of the swap to retrieve
     * @param {Object} config - the configuration to retrieve the swap
     * @return {Promise<Swap>} the swap
     */
    retrieve(id: string, config?: any): Promise<Swap>;
    /**
     * Retrieves a swap based on its associated cart id
     * @param {string} cartId - the cart id that the swap's cart has
     * @param {string[]} relations - the relations to retrieve swap
     * @return {Promise<Swap>} the swap
     */
    retrieveByCartId(cartId: string, relations?: string[]): Promise<Swap>;
    /**
     * @param {Object} selector - the query object for find
     * @param {Object} config - the configuration used to find the objects. contains relations, skip, and take.
     * @return {Promise} the result of the find operation
     */
    list(selector: any, config?: any): Promise<any>;
    /**
     * @typedef OrderLike
     * @property {Array<LineItem>} items - the items on the order
     */
    /**
     * @typedef ReturnItem
     * @property {string} item_id - the id of the item in the order to return from.
     * @property {number} quantity - the amount of the item to return.
     */
    /**
     * Goes through a list of return items to ensure that they exist on the
     * original order. If the item exists it is verified that the quantity to
     * return is not higher than the original quantity ordered.
     * @param {OrderLike} order - the order to return from
     * @param {Array<ReturnItem>} returnItems - the items to return
     * @return {Array<ReturnItems>} the validated returnItems
     */
    validateReturnItems_(order: {
        /**
         * - the items on the order
         */
        items: Array<LineItem>;
    }, returnItems: {
        /**
         * - the id of the item in the order to return from.
         */
        item_id: string;
        /**
         * - the amount of the item to return.
         */
        quantity: number;
    }[]): Array<ReturnItems>;
    /**
     * @typedef PreliminaryLineItem
     * @property {string} variant_id - the id of the variant to create an item from
     * @property {number} quantity - the amount of the variant to add to the line item
     */
    /**
     * Creates a swap from an order, with given return items, additional items
     * and an optional return shipping method.
     * @param {Order} order - the order to base the swap off.
     * @param {Array<ReturnItem>} returnItems - the items to return in the swap.
     * @param {Array<PreliminaryLineItem> | undefined} additionalItems - the items to send to
     *  the customer.
     * @param {ReturnShipping?} returnShipping - an optional shipping method for
     *  returning the returnItems.
     * @param {Object} custom - contains relevant custom information. This object may
     *  include no_notification which will disable sending notification when creating
     *  swap. If set, it overrules the attribute inherited from the order.
     * @return {Promise<Swap>} the newly created swap.
     */
    create(order: Order, returnItems: {
        /**
         * - the id of the item in the order to return from.
         */
        item_id: string;
        /**
         * - the amount of the item to return.
         */
        quantity: number;
    }[], additionalItems: {
        /**
         * - the id of the variant to create an item from
         */
        variant_id: string;
        /**
         * - the amount of the variant to add to the line item
         */
        quantity: number;
    }[] | undefined, returnShipping: ReturnShipping | null, custom?: any): Promise<Swap>;
    processDifference(swapId: any): Promise<any>;
    update(swapId: any, update: any): Promise<any>;
    /**
     * Creates a cart from the given swap and order. The cart can be used to pay
     * for differences associated with the swap. The swap represented by the
     * swapId must belong to the order. Fails if there is already a cart on the
     * swap.
     * @param {string} swapId - the id of the swap to create the cart from
     * @param {object[]} customShippingOptions - the shipping options
     * @param {Order} order - the order to create the cart from
     * @return {Promise<Swap>} the swap with its cart_id prop set to the id of
     *   the new cart.
     */
    createCart(swapId: string, customShippingOptions?: object[]): Promise<Swap>;
    /**
     *@param {string} swapId - The id of the swap
     */
    registerCartCompletion(swapId: string): Promise<any>;
    /**
     * Registers the return associated with a swap as received. If the return
     * is received with mismatching return items the swap's status will be updated
     * to requires_action.
     * @param {string} swapId - the id of the swap to receive.
     * @param {Array<ReturnItem>} returnItems - the return items that have been returned
     * @return {Promise<Swap>} the resulting swap, with an updated return and
     *   status.
     */
    receiveReturn(swapId: string, returnItems: {
        /**
         * - the id of the item in the order to return from.
         */
        item_id: string;
        /**
         * - the amount of the item to return.
         */
        quantity: number;
    }[]): Promise<Swap>;
    /**
     * Cancels a given swap if possible. A swap can only be canceled if all
     * related returns, fulfillments, and payments have been canceled. If a swap
     * is associated with a refund, it cannot be canceled.
     * @param {string} swapId - the id of the swap to cancel.
     * @return {Promise<Swap>} the canceled swap.
     */
    cancel(swapId: string): Promise<Swap>;
    /**
     * Fulfills the addtional items associated with the swap. Will call the
     * fulfillment providers associated with the shipping methods.
     * @param {string} swapId - the id of the swap to fulfill,
     * @param {object} config - optional configurations, includes optional metadata to attach to the shipment, and a no_notification flag.
     * @return {Promise<Swap>} the updated swap with new status and fulfillments.
     */
    createFulfillment(swapId: string, config?: object): Promise<Swap>;
    /**
     * Cancels a fulfillment (if related to a swap)
     * @param {string} fulfillmentId - the ID of the fulfillment to cancel
     * @return {Swap} updated swap
     */
    cancelFulfillment(fulfillmentId: string): Swap;
    /**
     * Marks a fulfillment as shipped and attaches tracking numbers.
     * @param {string} swapId - the id of the swap that has been shipped.
     * @param {string} fulfillmentId - the id of the specific fulfillment that
     *   has been shipped
     * @param {TrackingLink[] | undefined} trackingLinks - the tracking numbers associated
     *   with the shipment
     * @param {object} config - optional configurations, includes optional metadata to attach to the shipment, and a noNotification flag.
     * @return {Promise<Swap>} the updated swap with new fulfillments and status.
     */
    createShipment(swapId: string, fulfillmentId: string, trackingLinks: TrackingLink[] | undefined, config?: object): Promise<Swap>;
    /**
     * Dedicated method to delete metadata for a swap.
     * @param {string} swapId - the order to delete metadata from.
     * @param {string} key - key for metadata field
     * @return {Promise} resolves to the updated result.
     */
    deleteMetadata(swapId: string, key: string): Promise<any>;
    /**
     * Registers the swap return items as received so that they cannot be used
     * as a part of other swaps/returns.
     * @param {string} id - the id of the order with the swap.
     * @param {string} swapId - the id of the swap that has been received.
     * @return {Promise<Order>} the resulting order
     */
    registerReceived(id: string): Promise<Order>;
}
