export default NoteService;
declare const NoteService_base: any;
declare class NoteService extends NoteService_base {
    [x: string]: any;
    static Events: {
        CREATED: string;
        UPDATED: string;
        DELETED: string;
    };
    constructor({ manager, noteRepository, eventBusService }: {
        manager: any;
        noteRepository: any;
        eventBusService: any;
    });
    /** @private @const {EntityManager} */
    private manager_;
    /** @private @const {NoteRepository} */
    private noteRepository_;
    /** @private @const {EventBus} */
    private eventBus_;
    /**
     * Sets the service's manager to a given transaction manager
     * @param {EntityManager} transactionManager - the manager to use
     * @return {NoteService} a cloned note service
     */
    withTransaction(transactionManager: EntityManager): NoteService;
    /**
     * Retrieves a specific note.
     * @param {string} id - the id of the note to retrieve.
     * @param {object} config - any options needed to query for the result.
     * @return {Promise<Note>} which resolves to the requested note.
     */
    retrieve(id: string, config?: object): Promise<Note>;
    /** Fetches all notes related to the given selector
     * @param {Object} selector - the query object for find
     * @param {Object} config - the configuration used to find the objects. contains relations, skip, and take.
     * @param {string[]} config.relations - Which relations to include in the resulting list of Notes.
     * @param {number} config.take - How many Notes to take in the resulting list of Notes.
     * @param {number} config.skip - How many Notes to skip in the resulting list of Notes.
     * @return {Promise<Note[]>} notes related to the given search.
     */
    list(selector: any, config?: {
        relations: string[];
        take: number;
        skip: number;
    }): Promise<Note[]>;
    /**
     * Creates a note associated with a given author
     * @param {CreateNoteInput} data - the note to create
     * @param {*} config - any configurations if needed, including meta data
     * @return {Promise} resolves to the creation result
     */
    create(data: CreateNoteInput, config?: any): Promise<any>;
    /**
     * Updates a given note with a new value
     * @param {*} noteId - the id of the note to update
     * @param {*} value - the new value
     * @return {Promise} resolves to the updated element
     */
    update(noteId: any, value: any): Promise<any>;
    /**
     * Deletes a given note
     * @param {*} noteId - id of the note to delete
     * @return {Promise}
     */
    delete(noteId: any): Promise<any>;
}
