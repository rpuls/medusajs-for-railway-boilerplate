"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var medusa_core_utils_1 = require("medusa-core-utils");
var medusa_interfaces_1 = require("medusa-interfaces");
var typeorm_1 = require("typeorm");
/**
 * Provides layer to manipulate products.
 * @extends BaseService
 */
var ProductService = /** @class */ (function (_super) {
    __extends(ProductService, _super);
    function ProductService(_a) {
        var manager = _a.manager, productRepository = _a.productRepository, productVariantRepository = _a.productVariantRepository, productOptionRepository = _a.productOptionRepository, eventBusService = _a.eventBusService, productVariantService = _a.productVariantService, productCollectionService = _a.productCollectionService, productTypeRepository = _a.productTypeRepository, productTagRepository = _a.productTagRepository, imageRepository = _a.imageRepository, searchService = _a.searchService;
        var _this = _super.call(this) || this;
        /** @private @const {EntityManager} */
        _this.manager_ = manager;
        /** @private @const {ProductOption} */
        _this.productOptionRepository_ = productOptionRepository;
        /** @private @const {Product} */
        _this.productRepository_ = productRepository;
        /** @private @const {ProductVariant} */
        _this.productVariantRepository_ = productVariantRepository;
        /** @private @const {EventBus} */
        _this.eventBus_ = eventBusService;
        /** @private @const {ProductVariantService} */
        _this.productVariantService_ = productVariantService;
        /** @private @const {ProductCollectionService} */
        _this.productCollectionService_ = productCollectionService;
        /** @private @const {ProductCollectionService} */
        _this.productTypeRepository_ = productTypeRepository;
        /** @private @const {ProductCollectionService} */
        _this.productTagRepository_ = productTagRepository;
        /** @private @const {ImageRepository} */
        _this.imageRepository_ = imageRepository;
        /** @private @const {SearchService} */
        _this.searchService_ = searchService;
        return _this;
    }
    ProductService.prototype.withTransaction = function (transactionManager) {
        if (!transactionManager) {
            return this;
        }
        var cloned = new ProductService({
            manager: transactionManager,
            productRepository: this.productRepository_,
            productVariantRepository: this.productVariantRepository_,
            productOptionRepository: this.productOptionRepository_,
            eventBusService: this.eventBus_,
            productVariantService: this.productVariantService_,
            productCollectionService: this.productCollectionService_,
            productTagRepository: this.productTagRepository_,
            productTypeRepository: this.productTypeRepository_,
            imageRepository: this.imageRepository_,
        });
        cloned.transactionManager_ = transactionManager;
        return cloned;
    };
    /**
     * Lists products based on the provided parameters.
     * @param {object} selector - an object that defines rules to filter products
     *   by
     * @param {object} config - object that defines the scope for what should be
     *   returned
     * @return {Promise<Product[]>} the result of the find operation
     */
    ProductService.prototype.list = function (selector, config) {
        var _a;
        if (selector === void 0) { selector = {}; }
        if (config === void 0) { config = { relations: [], skip: 0, take: 20 }; }
        return __awaiter(this, void 0, void 0, function () {
            var productRepo, _b, q, query, relations, qb, raw;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        productRepo = this.manager_.getCustomRepository(this.productRepository_);
                        _b = this.prepareListQuery_(selector, config), q = _b.q, query = _b.query, relations = _b.relations;
                        if (!q) return [3 /*break*/, 2];
                        qb = this.getFreeTextQueryBuilder_(productRepo, query, q);
                        return [4 /*yield*/, qb.getMany()];
                    case 1:
                        raw = _c.sent();
                        return [2 /*return*/, productRepo.findWithRelations(relations, raw.map(function (i) { return i.id; }), (_a = query.withDeleted) !== null && _a !== void 0 ? _a : false)];
                    case 2: return [2 /*return*/, productRepo.findWithRelations(relations, query)];
                }
            });
        });
    };
    /**
     * Lists products based on the provided parameters and includes the count of
     * products that match the query.
     * @param {object} selector - an object that defines rules to filter products
     *   by
     * @param {object} config - object that defines the scope for what should be
     *   returned
     * @return {[Promise<Product[]>, number]} an array containing the products as
     *   the first element and the total count of products that matches the query
     *   as the second element.
     */
    ProductService.prototype.listAndCount = function (selector, config) {
        var _a;
        if (selector === void 0) { selector = {}; }
        if (config === void 0) { config = { relations: [], skip: 0, take: 20 }; }
        return __awaiter(this, void 0, void 0, function () {
            var productRepo, _b, q, query, relations, qb, _c, raw, count, products;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        productRepo = this.manager_.getCustomRepository(this.productRepository_);
                        _b = this.prepareListQuery_(selector, config), q = _b.q, query = _b.query, relations = _b.relations;
                        if (!q) return [3 /*break*/, 3];
                        qb = this.getFreeTextQueryBuilder_(productRepo, query, q);
                        return [4 /*yield*/, qb.getManyAndCount()];
                    case 1:
                        _c = __read.apply(void 0, [_d.sent(), 2]), raw = _c[0], count = _c[1];
                        return [4 /*yield*/, productRepo.findWithRelations(relations, raw.map(function (i) { return i.id; }), (_a = query.withDeleted) !== null && _a !== void 0 ? _a : false)];
                    case 2:
                        products = _d.sent();
                        return [2 /*return*/, [products, count]];
                    case 3: return [4 /*yield*/, productRepo.findWithRelationsAndCount(relations, query)];
                    case 4: return [2 /*return*/, _d.sent()];
                }
            });
        });
    };
    /**
     * Return the total number of documents in database
     * @param {object} selector - the selector to choose products by
     * @return {Promise} the result of the count operation
     */
    ProductService.prototype.count = function (selector) {
        if (selector === void 0) { selector = {}; }
        var productRepo = this.manager_.getCustomRepository(this.productRepository_);
        var query = this.buildQuery_(selector);
        return productRepo.count(query);
    };
    /**
     * Gets a product by id.
     * Throws in case of DB Error and if product was not found.
     * @param {string} productId - id of the product to get.
     * @param {object} config - object that defines what should be included in the
     *   query response
     * @return {Promise<Product>} the result of the find one operation.
     */
    ProductService.prototype.retrieve = function (productId, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var productRepo, validatedId, query, rels, product;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        productRepo = this.manager_.getCustomRepository(this.productRepository_);
                        validatedId = this.validateId_(productId);
                        query = { where: { id: validatedId } };
                        if (config.relations && config.relations.length > 0) {
                            query.relations = config.relations;
                        }
                        if (config.select && config.select.length > 0) {
                            query.select = config.select;
                        }
                        rels = query.relations;
                        delete query.relations;
                        return [4 /*yield*/, productRepo.findOneWithRelations(rels, query)];
                    case 1:
                        product = _a.sent();
                        if (!product) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Product with id: ".concat(productId, " was not found"));
                        }
                        return [2 /*return*/, product];
                }
            });
        });
    };
    /**
     * Gets a product by handle.
     * Throws in case of DB Error and if product was not found.
     * @param {string} productHandle - handle of the product to get.
     * @param {object} config - details about what to get from the product
     * @return {Promise<Product>} the result of the find one operation.
     */
    ProductService.prototype.retrieveByHandle = function (productHandle, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var productRepo, query, rels, product;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        productRepo = this.manager_.getCustomRepository(this.productRepository_);
                        query = { where: { handle: productHandle } };
                        if (config.relations && config.relations.length > 0) {
                            query.relations = config.relations;
                        }
                        if (config.select && config.select.length > 0) {
                            query.select = config.select;
                        }
                        rels = query.relations;
                        delete query.relations;
                        return [4 /*yield*/, productRepo.findOneWithRelations(rels, query)];
                    case 1:
                        product = _a.sent();
                        if (!product) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Product with handle: ".concat(productHandle, " was not found"));
                        }
                        return [2 /*return*/, product];
                }
            });
        });
    };
    /**
     * Gets a product by external id.
     * Throws in case of DB Error and if product was not found.
     * @param {string} externalId - handle of the product to get.
     * @param {object} config - details about what to get from the product
     * @return {Promise<Product>} the result of the find one operation.
     */
    ProductService.prototype.retrieveByExternalId = function (externalId, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var productRepo, query, rels, product;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        productRepo = this.manager_.getCustomRepository(this.productRepository_);
                        query = { where: { external_id: externalId } };
                        if (config.relations && config.relations.length > 0) {
                            query.relations = config.relations;
                        }
                        if (config.select && config.select.length > 0) {
                            query.select = config.select;
                        }
                        rels = query.relations;
                        delete query.relations;
                        return [4 /*yield*/, productRepo.findOneWithRelations(rels, query)];
                    case 1:
                        product = _a.sent();
                        if (!product) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Product with exteral_id: ".concat(externalId, " was not found"));
                        }
                        return [2 /*return*/, product];
                }
            });
        });
    };
    /**
     * Gets all variants belonging to a product.
     * @param {string} productId - the id of the product to get variants from.
     * @return {Promise} an array of variants
     */
    ProductService.prototype.retrieveVariants = function (productId) {
        return __awaiter(this, void 0, void 0, function () {
            var product;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.retrieve(productId, { relations: ["variants"] })];
                    case 1:
                        product = _a.sent();
                        return [2 /*return*/, product.variants];
                }
            });
        });
    };
    ProductService.prototype.listTypes = function () {
        return __awaiter(this, void 0, void 0, function () {
            var productTypeRepository;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        productTypeRepository = this.manager_.getCustomRepository(this.productTypeRepository_);
                        return [4 /*yield*/, productTypeRepository.find({})];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    ProductService.prototype.listTagsByUsage = function (count) {
        if (count === void 0) { count = 10; }
        return __awaiter(this, void 0, void 0, function () {
            var tags;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.manager_.query("\n      SELECT ID, O.USAGE_COUNT, PT.VALUE\n      FROM PRODUCT_TAG PT\n      LEFT JOIN\n        (SELECT COUNT(*) AS USAGE_COUNT,\n          PRODUCT_TAG_ID\n          FROM PRODUCT_TAGS\n          GROUP BY PRODUCT_TAG_ID) O ON O.PRODUCT_TAG_ID = PT.ID\n      ORDER BY O.USAGE_COUNT DESC\n      LIMIT $1", [count])];
                    case 1:
                        tags = _a.sent();
                        return [2 /*return*/, tags];
                }
            });
        });
    };
    ProductService.prototype.upsertProductType_ = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var productTypeRepository, existing, created, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        productTypeRepository = this.manager_.getCustomRepository(this.productTypeRepository_);
                        if (type === null) {
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, productTypeRepository.findOne({
                                where: { value: type.value },
                            })];
                    case 1:
                        existing = _a.sent();
                        if (existing) {
                            return [2 /*return*/, existing.id];
                        }
                        created = productTypeRepository.create(type);
                        return [4 /*yield*/, productTypeRepository.save(created)];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, result.id];
                }
            });
        });
    };
    ProductService.prototype.upsertProductTags_ = function (tags) {
        return __awaiter(this, void 0, void 0, function () {
            var productTagRepository, newTags, tags_1, tags_1_1, tag, existing, created, result, e_1_1;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        productTagRepository = this.manager_.getCustomRepository(this.productTagRepository_);
                        newTags = [];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 8, 9, 10]);
                        tags_1 = __values(tags), tags_1_1 = tags_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!tags_1_1.done) return [3 /*break*/, 7];
                        tag = tags_1_1.value;
                        return [4 /*yield*/, productTagRepository.findOne({
                                where: { value: tag.value },
                            })];
                    case 3:
                        existing = _b.sent();
                        if (!existing) return [3 /*break*/, 4];
                        newTags.push(existing);
                        return [3 /*break*/, 6];
                    case 4:
                        created = productTagRepository.create(tag);
                        return [4 /*yield*/, productTagRepository.save(created)];
                    case 5:
                        result = _b.sent();
                        newTags.push(result);
                        _b.label = 6;
                    case 6:
                        tags_1_1 = tags_1.next();
                        return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/, newTags];
                }
            });
        });
    };
    /**
     * Creates a product.
     * @param {object} productObject - the product to create
     * @return {Promise} resolves to the creation result.
     */
    ProductService.prototype.create = function (productObject) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productRepo, optionRepo, options, tags, type, images, rest, product, _a, _b, _c, _d, result;
                        var _this = this;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    productRepo = manager.getCustomRepository(this.productRepository_);
                                    optionRepo = manager.getCustomRepository(this.productOptionRepository_);
                                    options = productObject.options, tags = productObject.tags, type = productObject.type, images = productObject.images, rest = __rest(productObject, ["options", "tags", "type", "images"]);
                                    if (!rest.thumbnail && images && images.length) {
                                        rest.thumbnail = images[0];
                                    }
                                    // if product is a giftcard, we should disallow discounts
                                    if (rest.is_giftcard) {
                                        rest.discountable = false;
                                    }
                                    product = productRepo.create(rest);
                                    if (!images) return [3 /*break*/, 2];
                                    _a = product;
                                    return [4 /*yield*/, this.upsertImages_(images)];
                                case 1:
                                    _a.images = _e.sent();
                                    _e.label = 2;
                                case 2:
                                    if (!tags) return [3 /*break*/, 4];
                                    _b = product;
                                    return [4 /*yield*/, this.upsertProductTags_(tags)];
                                case 3:
                                    _b.tags = _e.sent();
                                    _e.label = 4;
                                case 4:
                                    if (!(typeof type !== "undefined")) return [3 /*break*/, 6];
                                    _c = product;
                                    return [4 /*yield*/, this.upsertProductType_(type)];
                                case 5:
                                    _c.type_id = _e.sent();
                                    _e.label = 6;
                                case 6: return [4 /*yield*/, productRepo.save(product)];
                                case 7:
                                    product = _e.sent();
                                    _d = product;
                                    return [4 /*yield*/, Promise.all(options.map(function (o) { return __awaiter(_this, void 0, void 0, function () {
                                            var res;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        res = optionRepo.create(__assign(__assign({}, o), { product_id: product.id }));
                                                        return [4 /*yield*/, optionRepo.save(res)];
                                                    case 1:
                                                        _a.sent();
                                                        return [2 /*return*/, res];
                                                }
                                            });
                                        }); }))];
                                case 8:
                                    _d.options = _e.sent();
                                    return [4 /*yield*/, this.retrieve(product.id, { relations: ["options"] })];
                                case 9:
                                    result = _e.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.CREATED, {
                                            id: result.id,
                                        })];
                                case 10:
                                    _e.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    ProductService.prototype.upsertImages_ = function (images) {
        return __awaiter(this, void 0, void 0, function () {
            var imageRepository, productImages, images_1, images_1_1, img, existing, created, e_2_1;
            var e_2, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        imageRepository = this.manager_.getCustomRepository(this.imageRepository_);
                        productImages = [];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        images_1 = __values(images), images_1_1 = images_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!images_1_1.done) return [3 /*break*/, 5];
                        img = images_1_1.value;
                        return [4 /*yield*/, imageRepository.findOne({
                                where: { url: img },
                            })];
                    case 3:
                        existing = _b.sent();
                        if (existing) {
                            productImages.push(existing);
                        }
                        else {
                            created = imageRepository.create({ url: img });
                            productImages.push(created);
                        }
                        _b.label = 4;
                    case 4:
                        images_1_1 = images_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (images_1_1 && !images_1_1.done && (_a = images_1.return)) _a.call(images_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, productImages];
                }
            });
        });
    };
    /**
     * Updates a product. Product variant updates should use dedicated methods,
     * e.g. `addVariant`, etc. The function will throw errors if metadata or
     * product variant updates are attempted.
     * @param {string} productId - the id of the product. Must be a string that
     *   can be casted to an ObjectId
     * @param {object} update - an object with the update values.
     * @return {Promise} resolves to the update result.
     */
    ProductService.prototype.update = function (productId, update) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productRepo, productVariantRepo, product, variants, metadata, images, tags, type, rest, _a, _b, _c, _loop_1, _d, _e, variant, e_3_1, newVariants, _loop_2, this_1, _f, _g, _h, i, newVariant, e_4_1, _j, _k, _l, key, value, result;
                        var e_3, _m, e_4, _o, e_5, _p;
                        return __generator(this, function (_q) {
                            switch (_q.label) {
                                case 0:
                                    productRepo = manager.getCustomRepository(this.productRepository_);
                                    productVariantRepo = manager.getCustomRepository(this.productVariantRepository_);
                                    return [4 /*yield*/, this.retrieve(productId, {
                                            relations: ["variants", "tags", "images"],
                                        })];
                                case 1:
                                    product = _q.sent();
                                    variants = update.variants, metadata = update.metadata, images = update.images, tags = update.tags, type = update.type, rest = __rest(update, ["variants", "metadata", "images", "tags", "type"]);
                                    if (!product.thumbnail && !update.thumbnail && (images === null || images === void 0 ? void 0 : images.length)) {
                                        product.thumbnail = images[0];
                                    }
                                    if (!images) return [3 /*break*/, 3];
                                    _a = product;
                                    return [4 /*yield*/, this.upsertImages_(images)];
                                case 2:
                                    _a.images = _q.sent();
                                    _q.label = 3;
                                case 3:
                                    if (metadata) {
                                        product.metadata = this.setMetadata_(product, metadata);
                                    }
                                    if (!(typeof type !== "undefined")) return [3 /*break*/, 5];
                                    _b = product;
                                    return [4 /*yield*/, this.upsertProductType_(type)];
                                case 4:
                                    _b.type_id = _q.sent();
                                    _q.label = 5;
                                case 5:
                                    if (!tags) return [3 /*break*/, 7];
                                    _c = product;
                                    return [4 /*yield*/, this.upsertProductTags_(tags)];
                                case 6:
                                    _c.tags = _q.sent();
                                    _q.label = 7;
                                case 7:
                                    if (!variants) return [3 /*break*/, 24];
                                    _loop_1 = function (variant) {
                                        var exists;
                                        return __generator(this, function (_r) {
                                            switch (_r.label) {
                                                case 0:
                                                    exists = variants.find(function (v) { return v.id && variant.id === v.id; });
                                                    if (!!exists) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, productVariantRepo.remove(variant)];
                                                case 1:
                                                    _r.sent();
                                                    _r.label = 2;
                                                case 2: return [2 /*return*/];
                                            }
                                        });
                                    };
                                    _q.label = 8;
                                case 8:
                                    _q.trys.push([8, 13, 14, 15]);
                                    _d = __values(product.variants), _e = _d.next();
                                    _q.label = 9;
                                case 9:
                                    if (!!_e.done) return [3 /*break*/, 12];
                                    variant = _e.value;
                                    return [5 /*yield**/, _loop_1(variant)];
                                case 10:
                                    _q.sent();
                                    _q.label = 11;
                                case 11:
                                    _e = _d.next();
                                    return [3 /*break*/, 9];
                                case 12: return [3 /*break*/, 15];
                                case 13:
                                    e_3_1 = _q.sent();
                                    e_3 = { error: e_3_1 };
                                    return [3 /*break*/, 15];
                                case 14:
                                    try {
                                        if (_e && !_e.done && (_m = _d.return)) _m.call(_d);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                    return [7 /*endfinally*/];
                                case 15:
                                    newVariants = [];
                                    _loop_2 = function (i, newVariant) {
                                        var variant, saved, created;
                                        return __generator(this, function (_s) {
                                            switch (_s.label) {
                                                case 0:
                                                    newVariant.variant_rank = i;
                                                    if (!newVariant.id) return [3 /*break*/, 2];
                                                    variant = product.variants.find(function (v) { return v.id === newVariant.id; });
                                                    if (!variant) {
                                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Variant with id: ".concat(newVariant.id, " is not associated with this product"));
                                                    }
                                                    return [4 /*yield*/, this_1.productVariantService_
                                                            .withTransaction(manager)
                                                            .update(variant, newVariant)];
                                                case 1:
                                                    saved = _s.sent();
                                                    newVariants.push(saved);
                                                    return [3 /*break*/, 4];
                                                case 2: return [4 /*yield*/, this_1.productVariantService_
                                                        .withTransaction(manager)
                                                        .create(product.id, newVariant)];
                                                case 3:
                                                    created = _s.sent();
                                                    newVariants.push(created);
                                                    _s.label = 4;
                                                case 4: return [2 /*return*/];
                                            }
                                        });
                                    };
                                    this_1 = this;
                                    _q.label = 16;
                                case 16:
                                    _q.trys.push([16, 21, 22, 23]);
                                    _f = __values(variants.entries()), _g = _f.next();
                                    _q.label = 17;
                                case 17:
                                    if (!!_g.done) return [3 /*break*/, 20];
                                    _h = __read(_g.value, 2), i = _h[0], newVariant = _h[1];
                                    return [5 /*yield**/, _loop_2(i, newVariant)];
                                case 18:
                                    _q.sent();
                                    _q.label = 19;
                                case 19:
                                    _g = _f.next();
                                    return [3 /*break*/, 17];
                                case 20: return [3 /*break*/, 23];
                                case 21:
                                    e_4_1 = _q.sent();
                                    e_4 = { error: e_4_1 };
                                    return [3 /*break*/, 23];
                                case 22:
                                    try {
                                        if (_g && !_g.done && (_o = _f.return)) _o.call(_f);
                                    }
                                    finally { if (e_4) throw e_4.error; }
                                    return [7 /*endfinally*/];
                                case 23:
                                    product.variants = newVariants;
                                    _q.label = 24;
                                case 24:
                                    try {
                                        for (_j = __values(Object.entries(rest)), _k = _j.next(); !_k.done; _k = _j.next()) {
                                            _l = __read(_k.value, 2), key = _l[0], value = _l[1];
                                            if (typeof value !== "undefined") {
                                                product[key] = value;
                                            }
                                        }
                                    }
                                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                    finally {
                                        try {
                                            if (_k && !_k.done && (_p = _j.return)) _p.call(_j);
                                        }
                                        finally { if (e_5) throw e_5.error; }
                                    }
                                    return [4 /*yield*/, productRepo.save(product)];
                                case 25:
                                    result = _q.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.UPDATED, {
                                            id: result.id,
                                            fields: Object.keys(update),
                                        })];
                                case 26:
                                    _q.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Deletes a product from a given product id. The product's associated
     * variants will also be deleted.
     * @param {string} productId - the id of the product to delete. Must be
     *   castable as an ObjectId
     * @return {Promise} empty promise
     */
    ProductService.prototype.delete = function (productId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productRepo, product;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    productRepo = manager.getCustomRepository(this.productRepository_);
                                    return [4 /*yield*/, productRepo.findOne({ id: productId }, { relations: ["variants"] })];
                                case 1:
                                    product = _a.sent();
                                    if (!product) {
                                        return [2 /*return*/, Promise.resolve()];
                                    }
                                    return [4 /*yield*/, productRepo.softRemove(product)];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.DELETED, {
                                            id: productId,
                                        })];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/, Promise.resolve()];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Adds an option to a product. Options can, for example, be "Size", "Color",
     * etc. Will update all the products variants with a dummy value for the newly
     * created option. The same option cannot be added more than once.
     * @param {string} productId - the product to apply the new option to
     * @param {string} optionTitle - the display title of the option, e.g. "Size"
     * @return {Promise} the result of the model update operation
     */
    ProductService.prototype.addOption = function (productId, optionTitle) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productOptionRepo, product, option, _a, _b, variant, result;
                        var e_6, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    productOptionRepo = manager.getCustomRepository(this.productOptionRepository_);
                                    return [4 /*yield*/, this.retrieve(productId, {
                                            relations: ["options", "variants"],
                                        })];
                                case 1:
                                    product = _d.sent();
                                    if (product.options.find(function (o) { return o.title === optionTitle; })) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.DUPLICATE_ERROR, "An option with the title: ".concat(optionTitle, " already exists"));
                                    }
                                    return [4 /*yield*/, productOptionRepo.create({
                                            title: optionTitle,
                                            product_id: productId,
                                        })];
                                case 2:
                                    option = _d.sent();
                                    return [4 /*yield*/, productOptionRepo.save(option)];
                                case 3:
                                    _d.sent();
                                    try {
                                        for (_a = __values(product.variants), _b = _a.next(); !_b.done; _b = _a.next()) {
                                            variant = _b.value;
                                            this.productVariantService_
                                                .withTransaction(manager)
                                                .addOptionValue(variant.id, option.id, "Default Value");
                                        }
                                    }
                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                                    finally {
                                        try {
                                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                                        }
                                        finally { if (e_6) throw e_6.error; }
                                    }
                                    return [4 /*yield*/, this.retrieve(productId)];
                                case 4:
                                    result = _d.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.UPDATED, result)];
                                case 5:
                                    _d.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    ProductService.prototype.reorderVariants = function (productId, variantOrder) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productRepo, product, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    productRepo = manager.getCustomRepository(this.productRepository_);
                                    return [4 /*yield*/, this.retrieve(productId, {
                                            relations: ["variants"],
                                        })];
                                case 1:
                                    product = _a.sent();
                                    if (product.variants.length !== variantOrder.length) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Product variants and new variant order differ in length.");
                                    }
                                    product.variants = variantOrder.map(function (vId) {
                                        var variant = product.variants.find(function (v) { return v.id === vId; });
                                        if (!variant) {
                                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Product has no variant with id: ".concat(vId));
                                        }
                                        return variant;
                                    });
                                    result = productRepo.save(product);
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.UPDATED, result)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Changes the order of a product's options. Will throw if the length of
     * optionOrder and the length of the product's options are different. Will
     * throw optionOrder contains an id not associated with the product.
     * @param {string} productId - the product whose options we are reordering
     * @param {string[]} optionOrder - the ids of the product's options in the
     *    new order
     * @return {Promise} the result of the update operation
     */
    ProductService.prototype.reorderOptions = function (productId, optionOrder) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productRepo, product, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    productRepo = manager.getCustomRepository(this.productRepository_);
                                    return [4 /*yield*/, this.retrieve(productId, { relations: ["options"] })];
                                case 1:
                                    product = _a.sent();
                                    if (product.options.length !== optionOrder.length) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Product options and new options order differ in length.");
                                    }
                                    product.options = optionOrder.map(function (oId) {
                                        var option = product.options.find(function (o) { return o.id === oId; });
                                        if (!option) {
                                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Product has no option with id: ".concat(oId));
                                        }
                                        return option;
                                    });
                                    result = productRepo.save(product);
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.UPDATED, result)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Updates a product's option. Throws if the call tries to update an option
     * not associated with the product. Throws if the updated title already exists.
     * @param {string} productId - the product whose option we are updating
     * @param {string} optionId - the id of the option we are updating
     * @param {object} data - the data to update the option with
     * @return {Promise} the updated product
     */
    ProductService.prototype.updateOption = function (productId, optionId, data) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productOptionRepo, product, title, values, optionExists, productOption;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    productOptionRepo = manager.getCustomRepository(this.productOptionRepository_);
                                    return [4 /*yield*/, this.retrieve(productId, { relations: ["options"] })];
                                case 1:
                                    product = _a.sent();
                                    title = data.title, values = data.values;
                                    optionExists = product.options.some(function (o) {
                                        return o.title.toUpperCase() === title.toUpperCase() && o.id !== optionId;
                                    });
                                    if (optionExists) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "An option with title ".concat(title, " already exists"));
                                    }
                                    return [4 /*yield*/, productOptionRepo.findOne({
                                            where: { id: optionId },
                                        })];
                                case 2:
                                    productOption = _a.sent();
                                    if (!productOption) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Option with id: ".concat(optionId, " does not exist"));
                                    }
                                    productOption.title = title;
                                    productOption.values = values;
                                    return [4 /*yield*/, productOptionRepo.save(productOption)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.UPDATED, product)];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/, product];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Delete an option from a product.
     * @param {string} productId - the product to delete an option from
     * @param {string} optionId - the option to delete
     * @return {Promise} the updated product
     */
    ProductService.prototype.deleteOption = function (productId, optionId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var productOptionRepo, product, productOption, firstVariant, valueToMatch, equalsFirst;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    productOptionRepo = manager.getCustomRepository(this.productOptionRepository_);
                                    return [4 /*yield*/, this.retrieve(productId, {
                                            relations: ["variants", "variants.options"],
                                        })];
                                case 1:
                                    product = _a.sent();
                                    return [4 /*yield*/, productOptionRepo.findOne({
                                            where: { id: optionId, product_id: productId },
                                        })];
                                case 2:
                                    productOption = _a.sent();
                                    if (!productOption) {
                                        return [2 /*return*/, Promise.resolve()];
                                    }
                                    firstVariant = product.variants[0];
                                    valueToMatch = firstVariant.options.find(function (o) { return o.option_id === optionId; }).value;
                                    return [4 /*yield*/, Promise.all(product.variants.map(function (v) { return __awaiter(_this, void 0, void 0, function () {
                                            var option;
                                            return __generator(this, function (_a) {
                                                option = v.options.find(function (o) { return o.option_id === optionId; });
                                                return [2 /*return*/, option.value === valueToMatch];
                                            });
                                        }); }))];
                                case 3:
                                    equalsFirst = _a.sent();
                                    if (!equalsFirst.every(function (v) { return v; })) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "To delete an option, first delete all variants, such that when an option is deleted, no duplicate variants will exist.");
                                    }
                                    // If we reach this point, we can safely delete the product option
                                    return [4 /*yield*/, productOptionRepo.softRemove(productOption)];
                                case 4:
                                    // If we reach this point, we can safely delete the product option
                                    _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(ProductService.Events.UPDATED, product)];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, product];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Decorates a product with product variants.
     * @param {string} productId - the productId to decorate.
     * @param {string[]} fields - the fields to include.
     * @param {string[]} expandFields - fields to expand.
     * @return {Product} return the decorated product.
     */
    ProductService.prototype.decorate = function (productId, fields, expandFields) {
        if (fields === void 0) { fields = []; }
        if (expandFields === void 0) { expandFields = []; }
        return __awaiter(this, void 0, void 0, function () {
            var requiredFields, product;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requiredFields = ["id", "metadata"];
                        fields = fields.concat(requiredFields);
                        return [4 /*yield*/, this.retrieve(productId, {
                                select: fields,
                                relations: expandFields,
                            })
                            // const final = await this.runDecorators_(decorated)
                        ];
                    case 1:
                        product = _a.sent();
                        // const final = await this.runDecorators_(decorated)
                        return [2 /*return*/, product];
                }
            });
        });
    };
    /**
     * Creates a query object to be used for list queries.
     * @param {object} selector - the selector to create the query from
     * @param {object} config - the config to use for the query
     * @return {object} an object containing the query, relations and free-text
     *   search param.
     */
    ProductService.prototype.prepareListQuery_ = function (selector, config) {
        var q;
        if ("q" in selector) {
            q = selector.q;
            delete selector.q;
        }
        var query = this.buildQuery_(selector, config);
        if (config.relations && config.relations.length > 0) {
            query.relations = config.relations;
        }
        if (config.select && config.select.length > 0) {
            query.select = config.select;
        }
        var rels = query.relations;
        delete query.relations;
        return {
            query: query,
            relations: rels,
            q: q,
        };
    };
    /**
     * Creates a QueryBuilder that can fetch products based on free text.
     * @param {ProductRepository} productRepo - an instance of a ProductRepositry
     * @param {FindOptions<Product>} query - the query to get products by
     * @param {string} q - the text to perform free text search from
     * @return {QueryBuilder<Product>} a query builder that can fetch products
     */
    ProductService.prototype.getFreeTextQueryBuilder_ = function (productRepo, query, q) {
        var where = query.where;
        delete where.description;
        delete where.title;
        var qb = productRepo
            .createQueryBuilder("product")
            .leftJoinAndSelect("product.variants", "variant")
            .leftJoinAndSelect("product.collection", "collection")
            .select(["product.id"])
            .where(where)
            .andWhere(new typeorm_1.Brackets(function (qb) {
            qb.where("product.description ILIKE :q", { q: "%".concat(q, "%") })
                .orWhere("product.title ILIKE :q", { q: "%".concat(q, "%") })
                .orWhere("variant.title ILIKE :q", { q: "%".concat(q, "%") })
                .orWhere("variant.sku ILIKE :q", { q: "%".concat(q, "%") })
                .orWhere("collection.title ILIKE :q", { q: "%".concat(q, "%") });
        }));
        if (query.withDeleted) {
            qb = qb.withDeleted();
        }
        return qb;
    };
    ProductService.IndexName = "products";
    ProductService.Events = {
        UPDATED: "product.updated",
        CREATED: "product.created",
        DELETED: "product.deleted",
    };
    return ProductService;
}(medusa_interfaces_1.BaseService));
exports.default = ProductService;
//# sourceMappingURL=product.js.map