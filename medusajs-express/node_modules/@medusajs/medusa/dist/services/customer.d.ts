/// <reference path="../../index.d.ts" />
export default CustomerService;
declare const CustomerService_base: any;
/**
 * Provides layer to manipulate customers.
 * @implements {BaseService}
 */
declare class CustomerService extends CustomerService_base implements BaseService {
    [x: string]: any;
    static Events: {
        PASSWORD_RESET: string;
        CREATED: string;
        UPDATED: string;
    };
    constructor({ manager, customerRepository, eventBusService, addressRepository, }: {
        manager: any;
        customerRepository: any;
        eventBusService: any;
        addressRepository: any;
    });
    /** @private @const {EntityManager} */
    private manager_;
    /** @private @const {CustomerRepository} */
    private customerRepository_;
    /** @private @const {EventBus} */
    private eventBus_;
    /** @private @const {AddressRepository} */
    private addressRepository_;
    withTransaction(transactionManager: any): CustomerService;
    /**
     * Used to validate customer email.
     * @param {string} email - email to validate
     * @return {string} the validated email
     */
    validateEmail_(email: string): string;
    validateBillingAddress_(address: any): any;
    /**
     * Generate a JSON Web token, that will be sent to a customer, that wishes to
     * reset password.
     * The token will be signed with the customer's current password hash as a
     * secret a long side a payload with userId and the expiry time for the token,
     * which is always 15 minutes.
     * @param {string} customerId - the customer to reset the password for
     * @return {string} the generated JSON web token
     */
    generateResetPasswordToken(customerId: string): string;
    /**
     * @param {Object} selector - the query object for find
     * @param {Object} config - the config object containing query settings
     * @return {Promise} the result of the find operation
     */
    list(selector?: any, config?: any): Promise<any>;
    /**
     * @param {Object} selector - the query object for find
     * @param {FindConfig<Customer>} config - the config object containing query settings
     * @return {Promise} the result of the find operation
     */
    listAndCount(selector: any, config?: FindConfig<Customer>): Promise<any>;
    /**
     * Return the total number of documents in database
     * @return {Promise} the result of the count operation
     */
    count(): Promise<any>;
    /**
     * Gets a customer by id.
     * @param {string} customerId - the id of the customer to get.
     * @param {Object} config - the config object containing query settings
     * @return {Promise<Customer>} the customer document.
     */
    retrieve(customerId: string, config?: any): Promise<Customer>;
    /**
     * Gets a customer by email.
     * @param {string} email - the email of the customer to get.
     * @param {Object} config - the config object containing query settings
     * @return {Promise<Customer>} the customer document.
     */
    retrieveByEmail(email: string, config?: any): Promise<Customer>;
    /**
     * Gets a customer by phone.
     * @param {string} phone - the phone of the customer to get.
     * @param {Object} config - the config object containing query settings
     * @return {Promise<Customer>} the customer document.
     */
    retrieveByPhone(phone: string, config?: any): Promise<Customer>;
    /**
     * Hashes a password
     * @param {string} password - the value to hash
     * @return {Promise<string>} hashed password
     */
    hashPassword_(password: string): Promise<string>;
    /**
     * Creates a customer from an email - customers can have accounts associated,
     * e.g. to login and view order history, etc. If a password is provided the
     * customer will automatically get an account, otherwise the customer is just
     * used to hold details of customers.
     * @param {object} customer - the customer to create
     * @return {Promise} the result of create
     */
    create(customer: object): Promise<any>;
    /**
     * Updates a customer.
     * @param {string} customerId - the id of the variant. Must be a string that
     *   can be casted to an ObjectId
     * @param {object} update - an object with the update values.
     * @return {Promise} resolves to the update result.
     */
    update(customerId: string, update: object): Promise<any>;
    /**
     * Updates the customers' billing address.
     * @param {Customer} customer - the Customer to update
     * @param {Object|string} addressOrId - the value to set the billing address to
     * @param {Object} addrRepo - address repository
     * @return {Promise} the result of the update operation
     */
    updateBillingAddress_(customer: Customer, addressOrId: any | string, addrRepo: any): Promise<any>;
    updateAddress(customerId: any, addressId: any, address: any): Promise<any>;
    removeAddress(customerId: any, addressId: any): Promise<any>;
    addAddress(customerId: any, address: any): Promise<any>;
    /**
     * Deletes a customer from a given customer id.
     * @param {string} customerId - the id of the customer to delete. Must be
     *   castable as an ObjectId
     * @return {Promise} the result of the delete operation.
     */
    delete(customerId: string): Promise<any>;
    /**
     * Decorates a customer.
     * @param {Customer} customer - the cart to decorate.
     * @param {string[]} fields - the fields to include.
     * @param {string[]} expandFields - fields to expand.
     * @return {Customer} return the decorated customer.
     */
    decorate(customer: Customer, fields?: string[], expandFields?: string[]): Customer;
}
import { BaseService } from "medusa-interfaces";
