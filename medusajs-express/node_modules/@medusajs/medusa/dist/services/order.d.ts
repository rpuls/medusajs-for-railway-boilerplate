export default OrderService;
declare const OrderService_base: any;
declare class OrderService extends OrderService_base {
    [x: string]: any;
    static Events: {
        GIFT_CARD_CREATED: string;
        PAYMENT_CAPTURED: string;
        PAYMENT_CAPTURE_FAILED: string;
        SHIPMENT_CREATED: string;
        FULFILLMENT_CREATED: string;
        FULFILLMENT_CANCELED: string;
        RETURN_REQUESTED: string;
        ITEMS_RETURNED: string;
        RETURN_ACTION_REQUIRED: string;
        REFUND_CREATED: string;
        REFUND_FAILED: string;
        SWAP_CREATED: string;
        PLACED: string;
        UPDATED: string;
        CANCELED: string;
        COMPLETED: string;
    };
    constructor({ manager, orderRepository, customerService, paymentProviderService, shippingOptionService, shippingProfileService, discountService, fulfillmentProviderService, fulfillmentService, lineItemService, totalsService, regionService, cartService, addressRepository, giftCardService, draftOrderService, inventoryService, eventBusService, }: {
        manager: any;
        orderRepository: any;
        customerService: any;
        paymentProviderService: any;
        shippingOptionService: any;
        shippingProfileService: any;
        discountService: any;
        fulfillmentProviderService: any;
        fulfillmentService: any;
        lineItemService: any;
        totalsService: any;
        regionService: any;
        cartService: any;
        addressRepository: any;
        giftCardService: any;
        draftOrderService: any;
        inventoryService: any;
        eventBusService: any;
    });
    /** @private @constant {EntityManager} */
    private manager_;
    /** @private @constant {OrderRepository} */
    private orderRepository_;
    /** @private @constant {CustomerService} */
    private customerService_;
    /** @private @constant {PaymentProviderService} */
    private paymentProviderService_;
    /** @private @constant {ShippingProvileService} */
    private shippingProfileService_;
    /** @private @constant {FulfillmentProviderService} */
    private fulfillmentProviderService_;
    /** @private @constant {LineItemService} */
    private lineItemService_;
    /** @private @constant {TotalsService} */
    private totalsService_;
    /** @private @constant {RegionService} */
    private regionService_;
    /** @private @constant {FulfillmentService} */
    private fulfillmentService_;
    /** @private @constant {DiscountService} */
    private discountService_;
    /** @private @constant {DiscountService} */
    private giftCardService_;
    /** @private @constant {EventBus} */
    private eventBus_;
    /** @private @constant {ShippingOptionService} */
    private shippingOptionService_;
    /** @private @constant {CartService} */
    private cartService_;
    /** @private @constant {AddressRepository} */
    private addressRepository_;
    /** @private @constant {DraftOrderService} */
    private draftOrderService_;
    /** @private @constant {InventoryService} */
    private inventoryService_;
    withTransaction(manager: any): OrderService;
    /**
     * Used to validate order ids. Throws an error if the cast fails
     * @param {string} rawId - the raw order id to validate.
     * @return {string} the validated id
     */
    validateId_(rawId: string): string;
    /**
     * Used to validate order addresses. Can be used to both
     * validate shipping and billing address.
     * @param {Address} address - the address to validate
     * @return {Address} the validated address
     */
    validateAddress_(address: Address): Address;
    /**
     * Used to validate email.
     * @param {string} email - the email to vaildate
     * @return {string} the validate email
     */
    validateEmail_(email: string): string;
    /**
     * @param {Object} selector - the query object for find
     * @param {Object} config - the config to be used for find
     * @return {Promise} the result of the find operation
     */
    list(selector: any, config?: any): Promise<any>;
    listAndCount(selector: any, config?: {
        skip: number;
        take: number;
        order: {
            created_at: string;
        };
    }): Promise<any[]>;
    transformQueryForTotals_(config: any): {
        relations: any;
        select: any;
        totalsToSelect: any;
    };
    /**
     * Gets an order by id.
     * @param {string} orderId - id of order to retrieve
     * @param {Object} config - config of order to retrieve
     * @return {Promise<Order>} the order document
     */
    retrieve(orderId: string, config?: any): Promise<Order>;
    /**
     * Gets an order by cart id.
     * @param {string} cartId - cart id to find order
     * @param {Object} config - the config to be used to find order
     * @return {Promise<Order>} the order document
     */
    retrieveByCartId(cartId: string, config?: any): Promise<Order>;
    /**
     * Gets an order by id.
     * @param {string} externalId - id of order to retrieve
     * @param {object} config - query config to get order by
     * @return {Promise<Order>} the order document
     */
    retrieveByExternalId(externalId: string, config?: object): Promise<Order>;
    /**
     * Checks the existence of an order by cart id.
     * @param {string} cartId - cart id to find order
     * @return {Promise<Order>} the order document
     */
    existsByCartId(cartId: string): Promise<Order>;
    /**
     * @param {string} orderId - id of the order to complete
     * @return {Promise} the result of the find operation
     */
    completeOrder(orderId: string): Promise<any>;
    /**
     * Creates an order from a cart
     * @param {string} cartId - id of the cart to create an order from
     * @return {Promise} resolves to the creation result.
     */
    createFromCart(cartId: string): Promise<any>;
    /**
     * Adds a shipment to the order to indicate that an order has left the
     * warehouse. Will ask the fulfillment provider for any documents that may
     * have been created in regards to the shipment.
     * @param {string} orderId - the id of the order that has been shipped
     * @param {string} fulfillmentId - the fulfillment that has now been shipped
     * @param {TrackingLink[] | undefined} trackingLinks - array of tracking numebers
     *   associated with the shipment
     * @param {Object} config - the config of the order that has been shipped
     * @param {Dictionary<String, String>} metadata - optional metadata to add to
     *   the fulfillment
     * @return {order} the resulting order following the update.
     */
    createShipment(orderId: string, fulfillmentId: string, trackingLinks: TrackingLink[] | undefined, config?: any): order;
    /**
     * Creates an order
     * @param {object} data - the data to create an order
     * @return {Promise} resolves to the creation result.
     */
    create(data: object): Promise<any>;
    /**
     * Updates the order's billing address.
     * @param {object} order - the order to update
     * @param {object} address - the value to set the billing address to
     * @return {Promise} the result of the update operation
     */
    updateBillingAddress_(order: object, address: object): Promise<any>;
    /**
     * Updates the order's shipping address.
     * @param {object} order - the order to update
     * @param {object} address - the value to set the shipping address to
     * @return {Promise} the result of the update operation
     */
    updateShippingAddress_(order: object, address: object): Promise<any>;
    addShippingMethod(orderId: any, optionId: any, data: any, config?: {}): Promise<any>;
    /**
     * Updates an order. Metadata updates should
     * use dedicated method, e.g. `setMetadata` etc. The function
     * will throw errors if metadata updates are attempted.
     * @param {string} orderId - the id of the order. Must be a string that
     *   can be casted to an ObjectId
     * @param {object} update - an object with the update values.
     * @return {Promise} resolves to the update result.
     */
    update(orderId: string, update: object): Promise<any>;
    /**
     * Cancels an order.
     * Throws if fulfillment process has been initiated.
     * Throws if payment process has been initiated.
     * @param {string} orderId - id of order to cancel.
     * @return {Promise} result of the update operation.
     */
    cancel(orderId: string): Promise<any>;
    /**
     * Captures payment for an order.
     * @param {string} orderId - id of order to capture payment for.
     * @return {Promise} result of the update operation.
     */
    capturePayment(orderId: string): Promise<any>;
    /**
     * Checks that a given quantity of a line item can be fulfilled. Fails if the
     * fulfillable quantity is lower than the requested fulfillment quantity.
     * Fulfillable quantity is calculated by subtracting the already fulfilled
     * quantity from the quantity that was originally purchased.
     * @param {LineItem} item - the line item to check has sufficient fulfillable
     *   quantity.
     * @param {number} quantity - the quantity that is requested to be fulfilled.
     * @return {LineItem} a line item that has the requested fulfillment quantity
     *   set.
     */
    validateFulfillmentLineItem_(item: LineItem, quantity: number): LineItem;
    /**
     * Creates fulfillments for an order.
     * In a situation where the order has more than one shipping method,
     * we need to partition the order items, such that they can be sent
     * to their respective fulfillment provider.
     * @param {string} orderId - id of order to cancel.
     * @param {Object} itemsToFulfill - items to fulfil.
     * @param {Object} config - the config to cancel.
     * @return {Promise} result of the update operation.
     */
    createFulfillment(orderId: string, itemsToFulfill: any, config?: any): Promise<any>;
    /**
     * Cancels a fulfillment (if related to an order)
     * @param {string} fulfillmentId - the ID of the fulfillment to cancel
     * @return {Promise} updated order
     */
    cancelFulfillment(fulfillmentId: string): Promise<any>;
    /**
     * Retrieves the order line items, given an array of items.
     * @param {Order} order - the order to get line items from
     * @param {{ item_id: string, quantity: number }} items - the items to get
     * @param {function} transformer - a function to apply to each of the items
     *    retrieved from the order, should return a line item. If the transformer
     *    returns an undefined value the line item will be filtered from the
     *    returned array.
     * @return {Promise<Array<LineItem>>} the line items generated by the transformer.
     */
    getFulfillmentItems_(order: Order, items: {
        item_id: string;
        quantity: number;
    }, transformer: Function): Promise<Array<LineItem>>;
    /**
     * Archives an order. It only alloved, if the order has been fulfilled
     * and payment has been captured.
     * @param {string} orderId - the order to archive
     * @return {Promise} the result of the update operation
     */
    archive(orderId: string): Promise<any>;
    /**
     * Refunds a given amount back to the customer.
     * @param {string} orderId - id of the order to refund.
     * @param {float} refundAmount - the amount to refund.
     * @param {string} reason - the reason to refund.
     * @param {string | undefined} note - note for refund.
     * @param {Object} config - the config for refund.
     * @return {Promise} the result of the refund operation.
     */
    createRefund(orderId: string, refundAmount: float, reason: string, note: string | undefined, config?: any): Promise<any>;
    decorateTotals_(order: any, totalsFields?: any[]): any;
    /**
     * Handles receiving a return. This will create a
     * refund to the customer. If the returned items don't match the requested
     * items the return status will be updated to requires_action. This behaviour
     * is useful in sitautions where a custom refund amount is requested, but the
     * retuned items are not matching the requested items. Setting the
     * allowMismatch argument to true, will process the return, ignoring any
     * mismatches.
     * @param {string} orderId - the order to return.
     * @param {object} receivedReturn - the received return
     * @param {float} customRefundAmount - the custom refund amount return
     * @return {Promise} the result of the update operation
     */
    registerReturnReceived(orderId: string, receivedReturn: object, customRefundAmount: float): Promise<any>;
    /**
     * Dedicated method to delete metadata for an order.
     * @param {string} orderId - the order to delete metadata from.
     * @param {string} key - key for metadata field
     * @return {Promise} resolves to the updated result.
     */
    deleteMetadata(orderId: string, key: string): Promise<any>;
}
