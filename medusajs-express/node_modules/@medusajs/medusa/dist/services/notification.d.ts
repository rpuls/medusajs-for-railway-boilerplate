export default NotificationService;
declare const NotificationService_base: any;
/**
 * Provides layer to manipulate orchestrate notifications.
 * @extends BaseService
 */
declare class NotificationService extends NotificationService_base {
    [x: string]: any;
    constructor(container: any);
    container_: any;
    /** @private @const {EntityManager} */
    private manager_;
    logger_: any;
    /** @private @const {NotificationRepository} */
    private notificationRepository_;
    notificationProviderRepository_: any;
    subscribers_: {};
    attachmentGenerator_: any;
    /**
     * Registers an attachment generator to the service. The generator can be
     * used to generate on demand invoices or other documents.
     * @param {object} service
     */
    registerAttachmentGenerator(service: object): void;
    /**
     * Sets the service's manager to a given transaction manager.
     * @param {EntityManager} transactionManager - the manager to use
     * @return {NotificationService} a cloned notification service
     */
    withTransaction(transactionManager: EntityManager): NotificationService;
    /**
     * Takes a list of notification provider ids and persists them in the database.
     * @param {Array<string>} providers - a list of provider ids
     */
    registerInstalledProviders(providers: Array<string>): Promise<void>;
    /**
     * Retrieves a list of notifications.
     * @param {object} selector - the params to select the notifications by.
     * @param {object} config - the configuration to apply to the query
     * @return {Array<Notification>} the notifications that satisfy the query.
     */
    list(selector: object, config?: object): Array<Notification>;
    /**
     * Retrieves a notification with a given id
     * @param {string} id - the id of the notification
     * @param {object} config - the configuration to apply to the query
     * @return {Notification} the notification
     */
    retrieve(id: string, config?: object): Notification;
    /**
     * Subscribes a given provider to an event.
     * @param {string} eventName - the event to subscribe to
     * @param {string} providerId - the provider that the event will be sent to
     */
    subscribe(eventName: string, providerId: string): void;
    /**
     * Finds a provider with a given id. Will throw a NOT_FOUND error if the
     * resolution fails.
     * @param {string} id - the id of the provider
     * @return {NotificationProvider} the notification provider
     */
    retrieveProvider_(id: string): NotificationProvider;
    /**
     * Handles an event by relaying the event data to the subscribing providers.
     * The result of the notification send will be persisted in the database in
     * order to allow for resends. Will log any errors that are encountered.
     * @param {string} eventName - the event to handle
     * @param {object} data - the data the event was sent with
     * @return {Promise} - the result of notification subscribed
     */
    handleEvent(eventName: string, data: object): Promise<any>;
    /**
     * Sends a notification, by calling the given provider's sendNotification
     * method. Persists the Notification in the database.
     * @param {string} event - the name of the event
     * @param {object} eventData - the data the event was sent with
     * @param {string} providerId - the provider that should hande the event.
     * @return {Notification} the created notification
     */
    send(event: string, eventData: object, providerId: string): Notification;
    /**
     * Resends a notification by retrieving a prior notification and calling the
     * underlying provider's resendNotification method.
     * @param {string} id - the id of the notification
     * @param {object} config - any configuration that might override the previous
     *  send
     * @return {Notification} the newly created notification
     */
    resend(id: string, config?: object): Notification;
}
