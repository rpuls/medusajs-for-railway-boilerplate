import { EntityManager } from "typeorm";
import { BaseService } from "medusa-interfaces";
import { ShippingMethodRepository } from "../repositories/shipping-method";
import { CartRepository } from "../repositories/cart";
import { AddressRepository } from "../repositories/address";
import { PaymentSessionRepository } from "../repositories/payment-session";
import { Address } from "../models/address";
import { Cart } from "../models/cart";
import { Customer } from "../models/customer";
import { LineItem } from "../models/line-item";
import { ShippingMethod } from "../models/shipping-method";
import { CustomShippingOption } from "../models/custom-shipping-option";
import { TotalField, FindConfig } from "../types/common";
import { FilterableCartProps, LineItemUpdate, CartUpdateProps, CartCreateProps } from "../types/cart";
import EventBusService from "./event-bus";
import ProductVariantService from "./product-variant";
import ProductService from "./product";
import RegionService from "./region";
import LineItemService from "./line-item";
import PaymentProviderService from "./payment-provider";
import ShippingOptionService from "./shipping-option";
import CustomerService from "./customer";
import DiscountService from "./discount";
import GiftCardService from "./gift-card";
import TotalsService from "./totals";
import InventoryService from "./inventory";
import CustomShippingOptionService from "./custom-shipping-option";
declare type CartConstructorProps = {
    manager: EntityManager;
    cartRepository: typeof CartRepository;
    shippingMethodRepository: typeof ShippingMethodRepository;
    addressRepository: typeof AddressRepository;
    paymentSessionRepository: typeof PaymentSessionRepository;
    eventBusService: EventBusService;
    paymentProviderService: PaymentProviderService;
    productService: ProductService;
    productVariantService: ProductVariantService;
    regionService: RegionService;
    lineItemService: LineItemService;
    shippingOptionService: ShippingOptionService;
    customerService: CustomerService;
    discountService: DiscountService;
    giftCardService: GiftCardService;
    totalsService: TotalsService;
    inventoryService: InventoryService;
    customShippingOptionService: CustomShippingOptionService;
};
declare class CartService extends BaseService {
    static Events: {
        CUSTOMER_UPDATED: string;
        CREATED: string;
        UPDATED: string;
    };
    private manager_;
    private shippingMethodRepository_;
    private cartRepository_;
    private eventBus_;
    private productVariantService_;
    private productService_;
    private regionService_;
    private lineItemService_;
    private paymentProviderService_;
    private customerService_;
    private shippingOptionService_;
    private discountService_;
    private giftCardService_;
    private totalsService_;
    private addressRepository_;
    private paymentSessionRepository_;
    private inventoryService_;
    private customShippingOptionService_;
    constructor({ manager, cartRepository, shippingMethodRepository, eventBusService, paymentProviderService, productService, productVariantService, regionService, lineItemService, shippingOptionService, customerService, discountService, giftCardService, totalsService, addressRepository, paymentSessionRepository, inventoryService, customShippingOptionService, }: CartConstructorProps);
    withTransaction(transactionManager: EntityManager): CartService;
    /**
     * Used to validate cart ids. Throws an error if the cast fails
     * @param {string} rawId - the raw cart id to validate.
     * @return {string} the validated id
     */
    /**
     * Contents of a line item
     * @typedef {(object | array)} LineItemContent
     * @property {number} unit_price - the price of the content
     * @property {object} variant - the product variant of the content
     * @property {object} product - the product of the content
     * @property {number} quantity - the quantity of the content
     */
    /**
     * A collection of contents grouped in the same line item
     * @typedef {LineItemContent[]} LineItemContentArray
     */
    transformQueryForTotals_(config: FindConfig<Cart>): FindConfig<Cart> & {
        totalsToSelect: TotalField[];
    };
    decorateTotals_(cart: Cart, totalsToSelect: TotalField[]): Promise<Cart>;
    /**
     * @param {Object} selector - the query object for find
     * @param {Object} config - config object
     * @return {Promise} the result of the find operation
     */
    list(selector: FilterableCartProps, config?: FindConfig<Cart>): Promise<Cart[]>;
    /**
     * Gets a cart by id.
     * @param {string} cartId - the id of the cart to get.
     * @param {Object} options - the options to get a cart
     * @return {Promise<Cart>} the cart document.
     */
    retrieve(cartId: string, options?: FindConfig<Cart>): Promise<Cart>;
    /**
     * Creates a cart.
     * @param {Object} data - the data to create the cart with
     * @return {Promise} the result of the create operation
     */
    create(data: CartCreateProps): Promise<Cart>;
    /**
     * Removes a line item from the cart.
     * @param {string} cartId - the id of the cart that we will remove from
     * @param {LineItem} lineItemId - the line item to remove.
     * @return {Promise} the result of the update operation
     */
    removeLineItem(cartId: string, lineItemId: string): Promise<Cart>;
    /**
     * Checks if a given line item has a shipping method that can fulfill it.
     * Returns true if all products in the cart can be fulfilled with the current
     * shipping methods.
     * @param {ShippingMethod[]} shippingMethods - the set of shipping methods to check from
     * @param {LineItem} lineItem - the line item
     * @return {boolean}
     */
    validateLineItemShipping_(shippingMethods: ShippingMethod[], lineItem: LineItem): boolean;
    /**
     * Adds a line item to the cart.
     * @param {string} cartId - the id of the cart that we will add to
     * @param {LineItem} lineItem - the line item to add.
     * @return {Promise} the result of the update operation
     */
    addLineItem(cartId: string, lineItem: LineItem): Promise<Cart>;
    /**
     * Updates a cart's existing line item.
     * @param {string} cartId - the id of the cart to update
     * @param {string} lineItemId - the id of the line item to update.
     * @param {LineItemUpdate} lineItemUpdate - the line item to update. Must
     * include an id field.
     * @return {Promise} the result of the update operation
     */
    updateLineItem(cartId: string, lineItemId: string, lineItemUpdate: LineItemUpdate): Promise<Cart>;
    /**
     * Ensures shipping total on cart is correct in regards to a potential free
     * shipping discount
     * If a free shipping is present, we set shipping methods price to 0
     * if a free shipping was present, we set shipping methods to original amount
     * @param {Cart} cart - the the cart to adjust free shipping for
     * @param {boolean} shouldAdd - flag to indicate, if we should add or remove
     */
    adjustFreeShipping_(cart: Cart, shouldAdd: boolean): Promise<void>;
    update(cartId: string, update: CartUpdateProps): Promise<Cart>;
    /**
     * Sets the customer id of a cart
     * @param {Cart} cart - the cart to add email to
     * @param {string} customerId - the customer to add to cart
     * @return {Promise} the result of the update operation
     */
    updateCustomerId_(cart: Cart, customerId: string): Promise<void>;
    /**
     * Creates or fetches a user based on an email.
     * @param {string} email - the email to use
     * @return {Promise} the resultign customer object
     */
    createOrFetchUserFromEmail_(email: string): Promise<Customer>;
    /**
     * Updates the cart's billing address.
     * @param {Cart} cart - the cart to update
     * @param {Address | string} addressOrId - the value to set the billing
     * address to
     * @param {AddressRepository} addrRepo - the repository to use for address
     * updates
     * @return {Promise} the result of the update operation
     */
    updateBillingAddress_(cart: Cart, addressOrId: Partial<Address> | string, addrRepo: AddressRepository): Promise<void>;
    /**
     * Updates the cart's shipping address.
     * @param {Cart} cart - the cart to update
     * @param {Address | string} addressOrId - the value to set the shipping
     * address to
     * @param {AddressRepository} addrRepo - the repository to use for address
     * updates
     * @return {Promise} the result of the update operation
     */
    updateShippingAddress_(cart: Cart, addressOrId: Partial<Address> | string, addrRepo: AddressRepository): Promise<void>;
    applyGiftCard_(cart: Cart, code: string): Promise<void>;
    /**
     * Updates the cart's discounts.
     * If discount besides free shipping is already applied, this
     * will be overwritten
     * Throws if discount regions does not include the cart region
     * @param {Cart} cart - the cart to update
     * @param {string} discountCode - the discount code
     * @return {Promise} the result of the update operation
     */
    applyDiscount(cart: Cart, discountCode: string): Promise<void>;
    /**
     * Removes a discount based on a discount code.
     * @param {string} cartId - the id of the cart to remove from
     * @param {string} discountCode - the discount code to remove
     * @return {Promise<Cart>} the resulting cart
     */
    removeDiscount(cartId: string, discountCode: string): Promise<Cart>;
    /**
     * A payment method represents a way for the customer to pay. The payment
     * method will typically come from one of the payment sessions.
     * @typedef {object} PaymentMethod
     * @property {string} provider_id - the identifier of the payment method's
     *     provider
     * @property {object} data - the data associated with the payment method
     */
    /**
     * Updates the currently selected payment session.
     * @param {string} cartId - the id of the cart to update the payment session for
     * @param {object} update - the data to update the payment session with
     */
    updatePaymentSession(cartId: string, update: object): Promise<Cart>;
    /**
     * Authorizes a payment for a cart.
     * Will authorize with chosen payment provider. This will return
     * a payment object, that we will use to update our cart payment with.
     * Additionally, if the payment does not require more or fails, we will
     * set the payment on the cart.
     * @param {string} cartId - the id of the cart to authorize payment for
     * @param {object} context - object containing whatever is relevant for
     *    authorizing the payment with the payment provider. As an example,
     *    this could be IP address or similar for fraud handling.
     * @return {Promise<Cart>} the resulting cart
     */
    authorizePayment(cartId: string, context?: object): Promise<Cart>;
    /**
     * Sets a payment method for a cart.
     * @param {string} cartId - the id of the cart to add payment method to
     * @param {string} providerId - the id of the provider to be set to the cart
     * @return {Promise} result of update operation
     */
    setPaymentSession(cartId: string, providerId: string): Promise<Cart>;
    /**
     * Creates, updates and sets payment sessions associated with the cart. The
     * first time the method is called payment sessions will be created for each
     * provider. Additional calls will ensure that payment sessions have correct
     * amounts, currencies, etc. as well as make sure to filter payment sessions
     * that are not available for the cart's region.
     * @param {Cart | string} cartOrCartId - the id of the cart to set payment
     * session for
     * @return {Promise} the result of the update operation.
     */
    setPaymentSessions(cartOrCartId: Cart | string): Promise<Cart>;
    /**
     * Removes a payment session from the cart.
     * @param {string} cartId - the id of the cart to remove from
     * @param {string} providerId - the id of the provider whoose payment session
     *    should be removed.
     * @return {Promise<Cart>} the resulting cart.
     */
    deletePaymentSession(cartId: string, providerId: string): Promise<Cart>;
    /**
     * Refreshes a payment session on a cart
     * @param {string} cartId - the id of the cart to remove from
     * @param {string} providerId - the id of the provider whoose payment session
     *    should be removed.
     * @return {Promise<Cart>} the resulting cart.
     */
    refreshPaymentSession(cartId: string, providerId: string): Promise<Cart>;
    /**
     * Adds the shipping method to the list of shipping methods associated with
     * the cart. Shipping Methods are the ways that an order is shipped, whereas a
     * Shipping Option is a possible way to ship an order. Shipping Methods may
     * also have additional details in the data field such as an id for a package
     * shop.
     * @param {string} cartId - the id of the cart to add shipping method to
     * @param {string} optionId - id of shipping option to add as valid method
     * @param {Object} data - the fulmillment data for the method
     * @return {Promise} the result of the update operation
     */
    addShippingMethod(cartId: string, optionId: string, data?: object): Promise<Cart>;
    /**
     * Finds the cart's custom shipping options based on the passed option id.
     * throws if custom options is not empty and no shipping option corresponds to optionId
     * @param {Object} cartCustomShippingOptions - the cart's custom shipping options
     * @param {string} optionId - id of the normal or custom shipping option to find in the cartCustomShippingOptions
     * @return {CustomShippingOption | undefined}
     */
    findCustomShippingOption(cartCustomShippingOptions: CustomShippingOption[], optionId: string): CustomShippingOption | undefined;
    /**
     * Set's the region of a cart.
     * @param {Cart} cart - the cart to set region on
     * @param {string} regionId - the id of the region to set the region to
     * @param {string} countryCode - the country code to set the country to
     * @return {Promise} the result of the update operation
     */
    setRegion_(cart: Cart, regionId: string, countryCode: string | null): Promise<void>;
    /**
     * Deletes a cart from the database. Completed carts cannot be deleted.
     * @param {string} cartId - the id of the cart to delete
     * @return {Promise<string>} the deleted cart or undefined if the cart was
     *    not found.
     */
    delete(cartId: string): Promise<string>;
    /**
     * Dedicated method to set metadata for a cart.
     * To ensure that plugins does not overwrite each
     * others metadata fields, setMetadata is provided.
     * @param {string} cartId - the cart to apply metadata to.
     * @param {string} key - key for metadata field
     * @param {string} value - value for metadata field.
     * @return {Promise} resolves to the updated result.
     */
    setMetadata(cartId: string, key: string, value: string | number): Promise<Cart>;
    /**
     * Dedicated method to delete metadata for a cart.
     * @param {string} cartId - the cart to delete metadata from.
     * @param {string} key - key for metadata field
     * @return {Promise} resolves to the updated result.
     */
    deleteMetadata(cartId: string, key: string): Promise<Cart>;
}
export default CartService;
