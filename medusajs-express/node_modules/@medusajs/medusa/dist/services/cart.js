"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __importDefault(require("lodash"));
var medusa_core_utils_1 = require("medusa-core-utils");
var medusa_interfaces_1 = require("medusa-interfaces");
/* Provides layer to manipulate carts.
 * @implements BaseService
 */
var CartService = /** @class */ (function (_super) {
    __extends(CartService, _super);
    function CartService(_a) {
        var manager = _a.manager, cartRepository = _a.cartRepository, shippingMethodRepository = _a.shippingMethodRepository, eventBusService = _a.eventBusService, paymentProviderService = _a.paymentProviderService, productService = _a.productService, productVariantService = _a.productVariantService, regionService = _a.regionService, lineItemService = _a.lineItemService, shippingOptionService = _a.shippingOptionService, customerService = _a.customerService, discountService = _a.discountService, giftCardService = _a.giftCardService, totalsService = _a.totalsService, addressRepository = _a.addressRepository, paymentSessionRepository = _a.paymentSessionRepository, inventoryService = _a.inventoryService, customShippingOptionService = _a.customShippingOptionService;
        var _this = _super.call(this) || this;
        /** @private @const {EntityManager} */
        _this.manager_ = manager;
        /** @private @const {ShippingMethodRepository} */
        _this.shippingMethodRepository_ = shippingMethodRepository;
        /** @private @const {CartRepository} */
        _this.cartRepository_ = cartRepository;
        /** @private @const {EventBus} */
        _this.eventBus_ = eventBusService;
        /** @private @const {ProductVariantService} */
        _this.productVariantService_ = productVariantService;
        /** @private @const {ProductService} */
        _this.productService_ = productService;
        /** @private @const {RegionService} */
        _this.regionService_ = regionService;
        /** @private @const {LineItemService} */
        _this.lineItemService_ = lineItemService;
        /** @private @const {PaymentProviderService} */
        _this.paymentProviderService_ = paymentProviderService;
        /** @private @const {CustomerService} */
        _this.customerService_ = customerService;
        /** @private @const {ShippingOptionService} */
        _this.shippingOptionService_ = shippingOptionService;
        /** @private @const {DiscountService} */
        _this.discountService_ = discountService;
        /** @private @const {GiftCardService} */
        _this.giftCardService_ = giftCardService;
        /** @private @const {TotalsService} */
        _this.totalsService_ = totalsService;
        /** @private @const {AddressRepository} */
        _this.addressRepository_ = addressRepository;
        /** @private @const {PaymentSessionRepository} */
        _this.paymentSessionRepository_ = paymentSessionRepository;
        /** @private @const {InventoryService} */
        _this.inventoryService_ = inventoryService;
        /** @private @const {CustomShippingOptionService} */
        _this.customShippingOptionService_ = customShippingOptionService;
        return _this;
    }
    CartService.prototype.withTransaction = function (transactionManager) {
        if (!transactionManager) {
            return this;
        }
        var cloned = new CartService({
            manager: transactionManager,
            cartRepository: this.cartRepository_,
            eventBusService: this.eventBus_,
            paymentProviderService: this.paymentProviderService_,
            paymentSessionRepository: this.paymentSessionRepository_,
            shippingMethodRepository: this.shippingMethodRepository_,
            productService: this.productService_,
            productVariantService: this.productVariantService_,
            regionService: this.regionService_,
            lineItemService: this.lineItemService_,
            shippingOptionService: this.shippingOptionService_,
            customerService: this.customerService_,
            discountService: this.discountService_,
            totalsService: this.totalsService_,
            addressRepository: this.addressRepository_,
            giftCardService: this.giftCardService_,
            inventoryService: this.inventoryService_,
            customShippingOptionService: this.customShippingOptionService_,
        });
        cloned.transactionManager_ = transactionManager;
        return cloned;
    };
    /**
     * Used to validate cart ids. Throws an error if the cast fails
     * @param {string} rawId - the raw cart id to validate.
     * @return {string} the validated id
     */
    /**
     * Contents of a line item
     * @typedef {(object | array)} LineItemContent
     * @property {number} unit_price - the price of the content
     * @property {object} variant - the product variant of the content
     * @property {object} product - the product of the content
     * @property {number} quantity - the quantity of the content
     */
    /**
     * A collection of contents grouped in the same line item
     * @typedef {LineItemContent[]} LineItemContentArray
     */
    CartService.prototype.transformQueryForTotals_ = function (config) {
        var select = config.select, relations = config.relations;
        if (!select) {
            return {
                select: select,
                relations: relations,
                totalsToSelect: [],
            };
        }
        var totalFields = [
            "subtotal",
            "tax_total",
            "shipping_total",
            "discount_total",
            "gift_card_total",
            "total",
        ];
        var totalsToSelect = select.filter(function (v) {
            return totalFields.includes(v);
        });
        if (totalsToSelect.length > 0) {
            var relationSet = new Set(relations);
            relationSet.add("items");
            relationSet.add("gift_cards");
            relationSet.add("discounts");
            relationSet.add("discounts.rule");
            relationSet.add("discounts.rule.valid_for");
            // relationSet.add("discounts.parent_discount")
            // relationSet.add("discounts.parent_discount.rule")
            // relationSet.add("discounts.parent_discount.regions")
            relationSet.add("shipping_methods");
            relationSet.add("region");
            relations = Array.from(relationSet.values());
            select = select.filter(function (v) { return !totalFields.includes(v); });
        }
        return {
            relations: relations,
            select: select,
            totalsToSelect: totalsToSelect,
        };
    };
    CartService.prototype.decorateTotals_ = function (cart, totalsToSelect) {
        return __awaiter(this, void 0, void 0, function () {
            var totals, totalsToSelect_1, totalsToSelect_1_1, key, _a, _b, _c, e_1_1;
            var e_1, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        totals = {};
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 14, 15, 16]);
                        totalsToSelect_1 = __values(totalsToSelect), totalsToSelect_1_1 = totalsToSelect_1.next();
                        _e.label = 2;
                    case 2:
                        if (!!totalsToSelect_1_1.done) return [3 /*break*/, 13];
                        key = totalsToSelect_1_1.value;
                        _a = key;
                        switch (_a) {
                            case "total": return [3 /*break*/, 3];
                            case "shipping_total": return [3 /*break*/, 5];
                            case "discount_total": return [3 /*break*/, 6];
                            case "tax_total": return [3 /*break*/, 7];
                            case "gift_card_total": return [3 /*break*/, 9];
                            case "subtotal": return [3 /*break*/, 10];
                        }
                        return [3 /*break*/, 11];
                    case 3:
                        _b = totals;
                        return [4 /*yield*/, this.totalsService_.getTotal(cart)];
                    case 4:
                        _b.total = _e.sent();
                        return [3 /*break*/, 12];
                    case 5:
                        {
                            totals.shipping_total = this.totalsService_.getShippingTotal(cart);
                            return [3 /*break*/, 12];
                        }
                        _e.label = 6;
                    case 6:
                        totals.discount_total = this.totalsService_.getDiscountTotal(cart);
                        return [3 /*break*/, 12];
                    case 7:
                        _c = totals;
                        return [4 /*yield*/, this.totalsService_.getTaxTotal(cart)];
                    case 8:
                        _c.tax_total = _e.sent();
                        return [3 /*break*/, 12];
                    case 9:
                        totals.gift_card_total = this.totalsService_.getGiftCardTotal(cart);
                        return [3 /*break*/, 12];
                    case 10:
                        totals.subtotal = this.totalsService_.getSubtotal(cart);
                        return [3 /*break*/, 12];
                    case 11: return [3 /*break*/, 12];
                    case 12:
                        totalsToSelect_1_1 = totalsToSelect_1.next();
                        return [3 /*break*/, 2];
                    case 13: return [3 /*break*/, 16];
                    case 14:
                        e_1_1 = _e.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 15:
                        try {
                            if (totalsToSelect_1_1 && !totalsToSelect_1_1.done && (_d = totalsToSelect_1.return)) _d.call(totalsToSelect_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 16: return [2 /*return*/, Object.assign(cart, totals)];
                }
            });
        });
    };
    /**
     * @param {Object} selector - the query object for find
     * @param {Object} config - config object
     * @return {Promise} the result of the find operation
     */
    CartService.prototype.list = function (selector, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var cartRepo, query;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cartRepo = this.manager_.getCustomRepository(this.cartRepository_);
                        query = this.buildQuery_(selector, config);
                        return [4 /*yield*/, cartRepo.find(query)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Gets a cart by id.
     * @param {string} cartId - the id of the cart to get.
     * @param {Object} options - the options to get a cart
     * @return {Promise<Cart>} the cart document.
     */
    CartService.prototype.retrieve = function (cartId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var cartRepo, validatedId, _a, select, relations, totalsToSelect, query, rels, raw;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cartRepo = this.manager_.getCustomRepository(this.cartRepository_);
                        validatedId = this.validateId_(cartId);
                        _a = this.transformQueryForTotals_(options), select = _a.select, relations = _a.relations, totalsToSelect = _a.totalsToSelect;
                        query = this.buildQuery_({ id: validatedId }, __assign(__assign({}, options), { select: select, relations: relations }));
                        if (relations && relations.length > 0) {
                            query.relations = relations;
                        }
                        if (select && select.length > 0) {
                            query.select = select;
                        }
                        else {
                            delete query.select;
                        }
                        rels = query.relations;
                        delete query.relations;
                        return [4 /*yield*/, cartRepo.findOneWithRelations(rels, query)];
                    case 1:
                        raw = _b.sent();
                        if (!raw) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Cart with ".concat(cartId, " was not found"));
                        }
                        return [4 /*yield*/, this.decorateTotals_(raw, totalsToSelect)];
                    case 2: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    /**
     * Creates a cart.
     * @param {Object} data - the data to create the cart with
     * @return {Promise} the result of the create operation
     */
    CartService.prototype.create = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cartRepo, addressRepo, region_id, region, regCountries, toCreate, customer, addr, remainingFields, remainingFields_1, remainingFields_1_1, k, inProgress, result;
                        var e_2, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    cartRepo = manager.getCustomRepository(this.cartRepository_);
                                    addressRepo = manager.getCustomRepository(this.addressRepository_);
                                    region_id = data.region_id;
                                    if (!region_id) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "A region_id must be provided when creating a cart");
                                    }
                                    return [4 /*yield*/, this.regionService_.retrieve(region_id, {
                                            relations: ["countries"],
                                        })];
                                case 1:
                                    region = _b.sent();
                                    regCountries = region.countries.map(function (_a) {
                                        var iso_2 = _a.iso_2;
                                        return iso_2;
                                    });
                                    toCreate = {};
                                    toCreate.region_id = region.id;
                                    if (!(typeof data.email !== "undefined")) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.createOrFetchUserFromEmail_(data.email)];
                                case 2:
                                    customer = _b.sent();
                                    toCreate.customer = customer;
                                    toCreate.customer_id = customer.id;
                                    toCreate.email = customer.email;
                                    _b.label = 3;
                                case 3:
                                    if (!(typeof data.shipping_address_id !== "undefined")) return [3 /*break*/, 5];
                                    return [4 /*yield*/, addressRepo.findOne(data.shipping_address_id)];
                                case 4:
                                    addr = _b.sent();
                                    if (addr && !regCountries.includes(addr.country_code)) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Shipping country not in region");
                                    }
                                    toCreate.shipping_address = addr;
                                    _b.label = 5;
                                case 5:
                                    if (!data.shipping_address) {
                                        if (region.countries.length === 1) {
                                            // Preselect the country if the region only has 1
                                            // and create address entity
                                            toCreate.shipping_address = addressRepo.create({
                                                country_code: regCountries[0],
                                            });
                                        }
                                    }
                                    else {
                                        if (!regCountries.includes(data.shipping_address.country_code)) {
                                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Shipping country not in region");
                                        }
                                        toCreate.shipping_address = data.shipping_address;
                                    }
                                    remainingFields = [
                                        "billing_address_id",
                                        "context",
                                        "type",
                                        "metadata",
                                        "discounts",
                                        "gift_cards",
                                    ];
                                    try {
                                        for (remainingFields_1 = __values(remainingFields), remainingFields_1_1 = remainingFields_1.next(); !remainingFields_1_1.done; remainingFields_1_1 = remainingFields_1.next()) {
                                            k = remainingFields_1_1.value;
                                            if (typeof data[k] !== "undefined") {
                                                toCreate[k] = data[k];
                                            }
                                        }
                                    }
                                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                    finally {
                                        try {
                                            if (remainingFields_1_1 && !remainingFields_1_1.done && (_a = remainingFields_1.return)) _a.call(remainingFields_1);
                                        }
                                        finally { if (e_2) throw e_2.error; }
                                    }
                                    inProgress = cartRepo.create(toCreate);
                                    return [4 /*yield*/, cartRepo.save(inProgress)];
                                case 6:
                                    result = _b.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.CREATED, {
                                            id: result.id,
                                        })];
                                case 7:
                                    _b.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Removes a line item from the cart.
     * @param {string} cartId - the id of the cart that we will remove from
     * @param {LineItem} lineItemId - the line item to remove.
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.removeLineItem = function (cartId, lineItemId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, lineItem, _a, _b, method, e_3_1, _c, _d, itm, e_4_1, result;
                        var e_3, _e, e_4, _f;
                        return __generator(this, function (_g) {
                            switch (_g.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: [
                                            "items",
                                            "items.variant",
                                            "items.variant.product",
                                            "payment_sessions",
                                        ],
                                    })];
                                case 1:
                                    cart = _g.sent();
                                    lineItem = cart.items.find(function (li) { return li.id === lineItemId; });
                                    if (!lineItem) {
                                        return [2 /*return*/, cart];
                                    }
                                    if (!(cart.shipping_methods && cart.shipping_methods.length)) return [3 /*break*/, 9];
                                    _g.label = 2;
                                case 2:
                                    _g.trys.push([2, 7, 8, 9]);
                                    _a = __values(cart.shipping_methods), _b = _a.next();
                                    _g.label = 3;
                                case 3:
                                    if (!!_b.done) return [3 /*break*/, 6];
                                    method = _b.value;
                                    return [4 /*yield*/, this.shippingOptionService_
                                            .withTransaction(manager)
                                            .deleteShippingMethod(method)];
                                case 4:
                                    _g.sent();
                                    _g.label = 5;
                                case 5:
                                    _b = _a.next();
                                    return [3 /*break*/, 3];
                                case 6: return [3 /*break*/, 9];
                                case 7:
                                    e_3_1 = _g.sent();
                                    e_3 = { error: e_3_1 };
                                    return [3 /*break*/, 9];
                                case 8:
                                    try {
                                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                    return [7 /*endfinally*/];
                                case 9:
                                    _g.trys.push([9, 14, 15, 16]);
                                    _c = __values(cart.items), _d = _c.next();
                                    _g.label = 10;
                                case 10:
                                    if (!!_d.done) return [3 /*break*/, 13];
                                    itm = _d.value;
                                    return [4 /*yield*/, this.lineItemService_.withTransaction(manager).update(itm.id, {
                                            has_shipping: false,
                                        })];
                                case 11:
                                    _g.sent();
                                    _g.label = 12;
                                case 12:
                                    _d = _c.next();
                                    return [3 /*break*/, 10];
                                case 13: return [3 /*break*/, 16];
                                case 14:
                                    e_4_1 = _g.sent();
                                    e_4 = { error: e_4_1 };
                                    return [3 /*break*/, 16];
                                case 15:
                                    try {
                                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                                    }
                                    finally { if (e_4) throw e_4.error; }
                                    return [7 /*endfinally*/];
                                case 16: return [4 /*yield*/, this.lineItemService_.withTransaction(manager).delete(lineItem.id)];
                                case 17:
                                    _g.sent();
                                    return [4 /*yield*/, this.retrieve(cartId)
                                        // Notify subscribers
                                    ];
                                case 18:
                                    result = _g.sent();
                                    // Notify subscribers
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, {
                                            id: result.id,
                                        })];
                                case 19:
                                    // Notify subscribers
                                    _g.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Checks if a given line item has a shipping method that can fulfill it.
     * Returns true if all products in the cart can be fulfilled with the current
     * shipping methods.
     * @param {ShippingMethod[]} shippingMethods - the set of shipping methods to check from
     * @param {LineItem} lineItem - the line item
     * @return {boolean}
     */
    CartService.prototype.validateLineItemShipping_ = function (shippingMethods, lineItem) {
        if (!lineItem.variant_id) {
            return true;
        }
        if (shippingMethods &&
            shippingMethods.length &&
            lineItem.variant &&
            lineItem.variant.product) {
            var productProfile = lineItem.variant.product.profile_id;
            var selectedProfiles = shippingMethods.map(function (_a) {
                var shipping_option = _a.shipping_option;
                return shipping_option.profile_id;
            });
            return selectedProfiles.includes(productProfile);
        }
        return false;
    };
    /**
     * Adds a line item to the cart.
     * @param {string} cartId - the id of the cart that we will add to
     * @param {LineItem} lineItem - the line item to add.
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.addLineItem = function (cartId, lineItem) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, currentItem, newQuantity, _a, _b, itm, e_5_1, _c, _d, method, e_6_1, result;
                        var e_5, _e, e_6, _f;
                        return __generator(this, function (_g) {
                            switch (_g.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: [
                                            "shipping_methods",
                                            "items",
                                            "payment_sessions",
                                            "items.variant",
                                            "items.variant.product",
                                        ],
                                    })];
                                case 1:
                                    cart = _g.sent();
                                    if (lineItem.should_merge) {
                                        currentItem = cart.items.find(function (line) {
                                            if (line.should_merge && line.variant_id === lineItem.variant_id) {
                                                return lodash_1.default.isEqual(line.metadata, lineItem.metadata);
                                            }
                                            return false;
                                        });
                                    }
                                    if (!currentItem) return [3 /*break*/, 4];
                                    newQuantity = currentItem.quantity + lineItem.quantity;
                                    // Confirm inventory or throw error
                                    return [4 /*yield*/, this.inventoryService_
                                            .withTransaction(manager)
                                            .confirmInventory(lineItem.variant_id, newQuantity)];
                                case 2:
                                    // Confirm inventory or throw error
                                    _g.sent();
                                    return [4 /*yield*/, this.lineItemService_
                                            .withTransaction(manager)
                                            .update(currentItem.id, {
                                            quantity: newQuantity,
                                        })];
                                case 3:
                                    _g.sent();
                                    return [3 /*break*/, 7];
                                case 4: 
                                // Confirm inventory or throw error
                                return [4 /*yield*/, this.inventoryService_
                                        .withTransaction(manager)
                                        .confirmInventory(lineItem.variant_id, lineItem.quantity)];
                                case 5:
                                    // Confirm inventory or throw error
                                    _g.sent();
                                    return [4 /*yield*/, this.lineItemService_.withTransaction(manager).create(__assign(__assign({}, lineItem), { has_shipping: false, cart_id: cartId }))];
                                case 6:
                                    _g.sent();
                                    _g.label = 7;
                                case 7:
                                    _g.trys.push([7, 12, 13, 14]);
                                    _a = __values(cart.items), _b = _a.next();
                                    _g.label = 8;
                                case 8:
                                    if (!!_b.done) return [3 /*break*/, 11];
                                    itm = _b.value;
                                    return [4 /*yield*/, this.lineItemService_.withTransaction(manager).update(itm.id, {
                                            has_shipping: false,
                                        })];
                                case 9:
                                    _g.sent();
                                    _g.label = 10;
                                case 10:
                                    _b = _a.next();
                                    return [3 /*break*/, 8];
                                case 11: return [3 /*break*/, 14];
                                case 12:
                                    e_5_1 = _g.sent();
                                    e_5 = { error: e_5_1 };
                                    return [3 /*break*/, 14];
                                case 13:
                                    try {
                                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                                    }
                                    finally { if (e_5) throw e_5.error; }
                                    return [7 /*endfinally*/];
                                case 14:
                                    if (!(cart.shipping_methods && cart.shipping_methods.length)) return [3 /*break*/, 22];
                                    _g.label = 15;
                                case 15:
                                    _g.trys.push([15, 20, 21, 22]);
                                    _c = __values(cart.shipping_methods), _d = _c.next();
                                    _g.label = 16;
                                case 16:
                                    if (!!_d.done) return [3 /*break*/, 19];
                                    method = _d.value;
                                    return [4 /*yield*/, this.shippingOptionService_
                                            .withTransaction(manager)
                                            .deleteShippingMethod(method)];
                                case 17:
                                    _g.sent();
                                    _g.label = 18;
                                case 18:
                                    _d = _c.next();
                                    return [3 /*break*/, 16];
                                case 19: return [3 /*break*/, 22];
                                case 20:
                                    e_6_1 = _g.sent();
                                    e_6 = { error: e_6_1 };
                                    return [3 /*break*/, 22];
                                case 21:
                                    try {
                                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                                    }
                                    finally { if (e_6) throw e_6.error; }
                                    return [7 /*endfinally*/];
                                case 22: return [4 /*yield*/, this.retrieve(cartId)];
                                case 23:
                                    result = _g.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, result)];
                                case 24:
                                    _g.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Updates a cart's existing line item.
     * @param {string} cartId - the id of the cart to update
     * @param {string} lineItemId - the id of the line item to update.
     * @param {LineItemUpdate} lineItemUpdate - the line item to update. Must
     * include an id field.
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.updateLineItem = function (cartId, lineItemId, lineItemUpdate) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, lineItemExists, hasInventory, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: ["items", "payment_sessions"],
                                    })
                                    // Ensure that the line item exists in the cart
                                ];
                                case 1:
                                    cart = _a.sent();
                                    lineItemExists = cart.items.find(function (i) { return i.id === lineItemId; });
                                    if (!lineItemExists) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "A line item with the provided id doesn't exist in the cart");
                                    }
                                    if (!lineItemUpdate.quantity) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.inventoryService_
                                            .withTransaction(manager)
                                            .confirmInventory(lineItemExists.variant_id, lineItemUpdate.quantity)];
                                case 2:
                                    hasInventory = _a.sent();
                                    if (!hasInventory) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Inventory doesn't cover the desired quantity");
                                    }
                                    _a.label = 3;
                                case 3: return [4 /*yield*/, this.lineItemService_
                                        .withTransaction(manager)
                                        .update(lineItemId, lineItemUpdate)
                                    // Update the line item
                                ];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.retrieve(cartId)];
                                case 5:
                                    result = _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, result)];
                                case 6:
                                    _a.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Ensures shipping total on cart is correct in regards to a potential free
     * shipping discount
     * If a free shipping is present, we set shipping methods price to 0
     * if a free shipping was present, we set shipping methods to original amount
     * @param {Cart} cart - the the cart to adjust free shipping for
     * @param {boolean} shouldAdd - flag to indicate, if we should add or remove
     */
    CartService.prototype.adjustFreeShipping_ = function (cart, shouldAdd) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!((_a = cart.shipping_methods) === null || _a === void 0 ? void 0 : _a.length)) return [3 /*break*/, 4];
                        if (!shouldAdd) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all(cart.shipping_methods.map(function (sm) { return __awaiter(_this, void 0, void 0, function () {
                                var smRepo, method;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            smRepo = this.manager_.getCustomRepository(this.shippingMethodRepository_);
                                            return [4 /*yield*/, smRepo.findOne({ where: { id: sm.id } })];
                                        case 1:
                                            method = _a.sent();
                                            if (!method) return [3 /*break*/, 3];
                                            method.price = 0;
                                            return [4 /*yield*/, smRepo.save(method)];
                                        case 2:
                                            _a.sent();
                                            _a.label = 3;
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, Promise.all(cart.shipping_methods.map(function (sm) { return __awaiter(_this, void 0, void 0, function () {
                            var smRepo;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        smRepo = this.manager_.getCustomRepository(this.shippingMethodRepository_);
                                        // if free shipping discount is removed, we adjust the shipping
                                        // back to its original amount
                                        sm.price = sm.shipping_option.amount;
                                        return [4 /*yield*/, smRepo.save(sm)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    CartService.prototype.update = function (cartId, update) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cartRepo, cart, countryCode, customer, addrRepo, address, address, previousDiscounts, _a, _b, code, e_7_1, hasFreeShipping, _c, _d, code, e_8_1, prevContext, result;
                        var e_7, _e, e_8, _f;
                        var _g, _h;
                        return __generator(this, function (_j) {
                            switch (_j.label) {
                                case 0:
                                    cartRepo = manager.getCustomRepository(this.cartRepository_);
                                    return [4 /*yield*/, this.retrieve(cartId, {
                                            select: [
                                                "subtotal",
                                                "tax_total",
                                                "shipping_total",
                                                "discount_total",
                                                "total",
                                            ],
                                            relations: [
                                                "items",
                                                "shipping_methods",
                                                "shipping_address",
                                                "billing_address",
                                                "gift_cards",
                                                "customer",
                                                "region",
                                                "payment_sessions",
                                                "region.countries",
                                                "discounts",
                                                "discounts.rule",
                                                "discounts.rule.valid_for",
                                                "discounts.regions",
                                            ],
                                        })];
                                case 1:
                                    cart = _j.sent();
                                    if (!(typeof update.region_id !== "undefined")) return [3 /*break*/, 3];
                                    countryCode = (_h = (update.country_code || ((_g = update.shipping_address) === null || _g === void 0 ? void 0 : _g.country_code))) !== null && _h !== void 0 ? _h : null;
                                    return [4 /*yield*/, this.setRegion_(cart, update.region_id, countryCode)];
                                case 2:
                                    _j.sent();
                                    _j.label = 3;
                                case 3:
                                    if (!(typeof update.customer_id !== "undefined")) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.updateCustomerId_(cart, update.customer_id)];
                                case 4:
                                    _j.sent();
                                    return [3 /*break*/, 7];
                                case 5:
                                    if (!(typeof update.email !== "undefined")) return [3 /*break*/, 7];
                                    return [4 /*yield*/, this.createOrFetchUserFromEmail_(update.email)];
                                case 6:
                                    customer = _j.sent();
                                    cart.customer = customer;
                                    cart.customer_id = customer.id;
                                    cart.email = customer.email;
                                    _j.label = 7;
                                case 7:
                                    addrRepo = manager.getCustomRepository(this.addressRepository_);
                                    if (!("shipping_address_id" in update || "shipping_address" in update)) return [3 /*break*/, 9];
                                    address = void 0;
                                    if (typeof update.shipping_address_id !== "undefined") {
                                        address = update.shipping_address_id;
                                    }
                                    else if (typeof update.shipping_address !== "undefined") {
                                        address = update.shipping_address;
                                    }
                                    if (!(typeof address !== "undefined")) return [3 /*break*/, 9];
                                    return [4 /*yield*/, this.updateShippingAddress_(cart, address, addrRepo)];
                                case 8:
                                    _j.sent();
                                    _j.label = 9;
                                case 9:
                                    if (!("billing_address_id" in update || "billing_address" in update)) return [3 /*break*/, 11];
                                    address = void 0;
                                    if (typeof update.billing_address_id !== "undefined") {
                                        address = update.billing_address_id;
                                    }
                                    else if (typeof update.billing_address !== "undefined") {
                                        address = update.billing_address;
                                    }
                                    if (!(typeof address !== "undefined")) return [3 /*break*/, 11];
                                    return [4 /*yield*/, this.updateBillingAddress_(cart, address, addrRepo)];
                                case 10:
                                    _j.sent();
                                    _j.label = 11;
                                case 11:
                                    if (!(typeof update.discounts !== "undefined")) return [3 /*break*/, 23];
                                    previousDiscounts = cart.discounts;
                                    cart.discounts = [];
                                    _j.label = 12;
                                case 12:
                                    _j.trys.push([12, 17, 18, 19]);
                                    _a = __values(update.discounts), _b = _a.next();
                                    _j.label = 13;
                                case 13:
                                    if (!!_b.done) return [3 /*break*/, 16];
                                    code = _b.value.code;
                                    return [4 /*yield*/, this.applyDiscount(cart, code)];
                                case 14:
                                    _j.sent();
                                    _j.label = 15;
                                case 15:
                                    _b = _a.next();
                                    return [3 /*break*/, 13];
                                case 16: return [3 /*break*/, 19];
                                case 17:
                                    e_7_1 = _j.sent();
                                    e_7 = { error: e_7_1 };
                                    return [3 /*break*/, 19];
                                case 18:
                                    try {
                                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                                    }
                                    finally { if (e_7) throw e_7.error; }
                                    return [7 /*endfinally*/];
                                case 19:
                                    hasFreeShipping = cart.discounts.some(function (_a) {
                                        var rule = _a.rule;
                                        return rule.type === "free_shipping";
                                    });
                                    if (!(previousDiscounts.some(function (_a) {
                                        var rule = _a.rule;
                                        return rule.type === "free_shipping";
                                    }) &&
                                        !hasFreeShipping)) return [3 /*break*/, 21];
                                    return [4 /*yield*/, this.adjustFreeShipping_(cart, false)];
                                case 20:
                                    _j.sent();
                                    _j.label = 21;
                                case 21:
                                    if (!hasFreeShipping) return [3 /*break*/, 23];
                                    return [4 /*yield*/, this.adjustFreeShipping_(cart, true)];
                                case 22:
                                    _j.sent();
                                    _j.label = 23;
                                case 23:
                                    if (!("gift_cards" in update)) return [3 /*break*/, 31];
                                    cart.gift_cards = [];
                                    _j.label = 24;
                                case 24:
                                    _j.trys.push([24, 29, 30, 31]);
                                    _c = __values(update.gift_cards), _d = _c.next();
                                    _j.label = 25;
                                case 25:
                                    if (!!_d.done) return [3 /*break*/, 28];
                                    code = _d.value.code;
                                    return [4 /*yield*/, this.applyGiftCard_(cart, code)];
                                case 26:
                                    _j.sent();
                                    _j.label = 27;
                                case 27:
                                    _d = _c.next();
                                    return [3 /*break*/, 25];
                                case 28: return [3 /*break*/, 31];
                                case 29:
                                    e_8_1 = _j.sent();
                                    e_8 = { error: e_8_1 };
                                    return [3 /*break*/, 31];
                                case 30:
                                    try {
                                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                                    }
                                    finally { if (e_8) throw e_8.error; }
                                    return [7 /*endfinally*/];
                                case 31:
                                    if ("metadata" in update) {
                                        cart.metadata = this.setMetadata_(cart, update.metadata);
                                    }
                                    if ("context" in update) {
                                        prevContext = cart.context || {};
                                        cart.context = __assign(__assign({}, prevContext), update.context);
                                    }
                                    if ("completed_at" in update) {
                                        cart.completed_at = update.completed_at;
                                    }
                                    if ("payment_authorized_at" in update) {
                                        cart.payment_authorized_at = update.payment_authorized_at;
                                    }
                                    return [4 /*yield*/, cartRepo.save(cart)];
                                case 32:
                                    result = _j.sent();
                                    if (!("email" in update || "customer_id" in update)) return [3 /*break*/, 34];
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.CUSTOMER_UPDATED, result.id)];
                                case 33:
                                    _j.sent();
                                    _j.label = 34;
                                case 34: return [4 /*yield*/, this.eventBus_
                                        .withTransaction(manager)
                                        .emit(CartService.Events.UPDATED, result)];
                                case 35:
                                    _j.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Sets the customer id of a cart
     * @param {Cart} cart - the cart to add email to
     * @param {string} customerId - the customer to add to cart
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.updateCustomerId_ = function (cart, customerId) {
        return __awaiter(this, void 0, void 0, function () {
            var customer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.customerService_
                            .withTransaction(this.transactionManager_)
                            .retrieve(customerId)];
                    case 1:
                        customer = _a.sent();
                        cart.customer = customer;
                        cart.customer_id = customer.id;
                        cart.email = customer.email;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates or fetches a user based on an email.
     * @param {string} email - the email to use
     * @return {Promise} the resultign customer object
     */
    CartService.prototype.createOrFetchUserFromEmail_ = function (email) {
        return __awaiter(this, void 0, void 0, function () {
            var schema, _a, value, error, customer;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        schema = medusa_core_utils_1.Validator.string().email().required();
                        _a = schema.validate(email.toLowerCase()), value = _a.value, error = _a.error;
                        if (error) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "The email is not valid");
                        }
                        return [4 /*yield*/, this.customerService_
                                .withTransaction(this.transactionManager_)
                                .retrieveByEmail(value)
                                .catch(function () { return undefined; })];
                    case 1:
                        customer = _b.sent();
                        if (!!customer) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.customerService_
                                .withTransaction(this.transactionManager_)
                                .create({ email: value })];
                    case 2:
                        customer = _b.sent();
                        _b.label = 3;
                    case 3: return [2 /*return*/, customer];
                }
            });
        });
    };
    /**
     * Updates the cart's billing address.
     * @param {Cart} cart - the cart to update
     * @param {Address | string} addressOrId - the value to set the billing
     * address to
     * @param {AddressRepository} addrRepo - the repository to use for address
     * updates
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.updateBillingAddress_ = function (cart, addressOrId, addrRepo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var address, updated, addr, created;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(typeof addressOrId === "string")) return [3 /*break*/, 2];
                        return [4 /*yield*/, addrRepo.findOne({
                                where: { id: addressOrId },
                            })];
                    case 1:
                        address = (_c.sent());
                        return [3 /*break*/, 3];
                    case 2:
                        address = addressOrId;
                        _c.label = 3;
                    case 3:
                        address.country_code = (_b = (_a = address.country_code) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : null;
                        if (!address.id) return [3 /*break*/, 5];
                        return [4 /*yield*/, addrRepo.save(address)];
                    case 4:
                        updated = _c.sent();
                        cart.billing_address = updated;
                        return [3 /*break*/, 9];
                    case 5:
                        if (!cart.billing_address_id) return [3 /*break*/, 8];
                        return [4 /*yield*/, addrRepo.findOne({
                                where: { id: cart.billing_address_id },
                            })];
                    case 6:
                        addr = _c.sent();
                        return [4 /*yield*/, addrRepo.save(__assign(__assign({}, addr), address))];
                    case 7:
                        _c.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        created = addrRepo.create(__assign({}, address));
                        cart.billing_address = created;
                        _c.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates the cart's shipping address.
     * @param {Cart} cart - the cart to update
     * @param {Address | string} addressOrId - the value to set the shipping
     * address to
     * @param {AddressRepository} addrRepo - the repository to use for address
     * updates
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.updateShippingAddress_ = function (cart, addressOrId, addrRepo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var address, updated, addr, created;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (addressOrId === null) {
                            cart.shipping_address = null;
                            return [2 /*return*/];
                        }
                        if (!(typeof addressOrId === "string")) return [3 /*break*/, 2];
                        return [4 /*yield*/, addrRepo.findOne({
                                where: { id: addressOrId },
                            })];
                    case 1:
                        address = (_c.sent());
                        return [3 /*break*/, 3];
                    case 2:
                        address = addressOrId;
                        _c.label = 3;
                    case 3:
                        address.country_code = (_b = (_a = address.country_code) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : null;
                        if (address.country_code &&
                            !cart.region.countries.find(function (_a) {
                                var iso_2 = _a.iso_2;
                                return address.country_code === iso_2;
                            })) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Shipping country must be in the cart region");
                        }
                        if (!address.id) return [3 /*break*/, 5];
                        return [4 /*yield*/, addrRepo.save(address)];
                    case 4:
                        updated = _c.sent();
                        cart.shipping_address = updated;
                        return [3 /*break*/, 9];
                    case 5:
                        if (!cart.shipping_address_id) return [3 /*break*/, 8];
                        return [4 /*yield*/, addrRepo.findOne({
                                where: { id: cart.shipping_address_id },
                            })];
                    case 6:
                        addr = _c.sent();
                        return [4 /*yield*/, addrRepo.save(__assign(__assign({}, addr), address))];
                    case 7:
                        _c.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        created = addrRepo.create(__assign({}, address));
                        cart.shipping_address = created;
                        _c.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    CartService.prototype.applyGiftCard_ = function (cart, code) {
        return __awaiter(this, void 0, void 0, function () {
            var giftCard;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.giftCardService_.retrieveByCode(code)];
                    case 1:
                        giftCard = _a.sent();
                        if (giftCard.is_disabled) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "The gift card is disabled");
                        }
                        if (giftCard.region_id !== cart.region_id) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "The gift card cannot be used in the current region");
                        }
                        // if discount is already there, we simply resolve
                        if (cart.gift_cards.find(function (_a) {
                            var id = _a.id;
                            return id === giftCard.id;
                        })) {
                            return [2 /*return*/, Promise.resolve()];
                        }
                        cart.gift_cards = __spreadArray(__spreadArray([], __read(cart.gift_cards), false), [giftCard], false);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates the cart's discounts.
     * If discount besides free shipping is already applied, this
     * will be overwritten
     * Throws if discount regions does not include the cart region
     * @param {Cart} cart - the cart to update
     * @param {string} discountCode - the discount code
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.applyDiscount = function (cart, discountCode) {
        return __awaiter(this, void 0, void 0, function () {
            var discount, rule, today, regions, parent, toParse, sawNotShipping, newDiscounts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.discountService_.retrieveByCode(discountCode, [
                            "rule",
                            "rule.valid_for",
                            "regions",
                        ])];
                    case 1:
                        discount = _a.sent();
                        rule = discount.rule;
                        // if limit is set and reached, we make an early exit
                        if (discount.usage_limit) {
                            discount.usage_count = discount.usage_count || 0;
                            if (discount.usage_count >= discount.usage_limit) {
                                throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Discount has been used maximum allowed times");
                            }
                        }
                        today = new Date();
                        if (discount.starts_at > today) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Discount is not valid yet");
                        }
                        if (discount.ends_at && discount.ends_at < today) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Discount is expired");
                        }
                        regions = discount.regions;
                        if (!discount.parent_discount_id) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.discountService_.retrieve(discount.parent_discount_id, {
                                relations: ["rule", "regions"],
                            })];
                    case 2:
                        parent = _a.sent();
                        regions = parent.regions;
                        _a.label = 3;
                    case 3:
                        if (discount.is_disabled) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "The discount code is disabled");
                        }
                        if (!regions.find(function (_a) {
                            var id = _a.id;
                            return id === cart.region_id;
                        })) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "The discount is not available in current region");
                        }
                        // if discount is already there, we simply resolve
                        if (cart.discounts.find(function (_a) {
                            var id = _a.id;
                            return id === discount.id;
                        })) {
                            return [2 /*return*/, Promise.resolve()];
                        }
                        toParse = __spreadArray(__spreadArray([], __read(cart.discounts), false), [discount], false);
                        sawNotShipping = false;
                        newDiscounts = toParse.map(function (d) {
                            var drule = d.rule;
                            switch (drule.type) {
                                case "free_shipping":
                                    if (d.rule.type === rule.type) {
                                        return discount;
                                    }
                                    return d;
                                default:
                                    if (!sawNotShipping) {
                                        sawNotShipping = true;
                                        if (rule.type !== "free_shipping") {
                                            return discount;
                                        }
                                        return d;
                                    }
                                    return null;
                            }
                        });
                        cart.discounts = newDiscounts.filter(Boolean);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a discount based on a discount code.
     * @param {string} cartId - the id of the cart to remove from
     * @param {string} discountCode - the discount code to remove
     * @return {Promise<Cart>} the resulting cart
     */
    CartService.prototype.removeDiscount = function (cartId, discountCode) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, cartRepo, result;
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: [
                                            "discounts",
                                            "discounts.rule",
                                            "discounts.rule.valid_for",
                                            "payment_sessions",
                                            "shipping_methods",
                                        ],
                                    })];
                                case 1:
                                    cart = _b.sent();
                                    if (!cart.discounts.some(function (_a) {
                                        var rule = _a.rule;
                                        return rule.type === "free_shipping";
                                    })) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.adjustFreeShipping_(cart, false)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    cart.discounts = cart.discounts.filter(function (d) { return d.code !== discountCode; });
                                    cartRepo = manager.getCustomRepository(this.cartRepository_);
                                    return [4 /*yield*/, cartRepo.save(cart)];
                                case 4:
                                    result = _b.sent();
                                    if (!((_a = cart.payment_sessions) === null || _a === void 0 ? void 0 : _a.length)) return [3 /*break*/, 6];
                                    return [4 /*yield*/, this.setPaymentSessions(cartId)];
                                case 5:
                                    _b.sent();
                                    _b.label = 6;
                                case 6: return [4 /*yield*/, this.eventBus_
                                        .withTransaction(manager)
                                        .emit(CartService.Events.UPDATED, result)];
                                case 7:
                                    _b.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * A payment method represents a way for the customer to pay. The payment
     * method will typically come from one of the payment sessions.
     * @typedef {object} PaymentMethod
     * @property {string} provider_id - the identifier of the payment method's
     *     provider
     * @property {object} data - the data associated with the payment method
     */
    /**
     * Updates the currently selected payment session.
     * @param {string} cartId - the id of the cart to update the payment session for
     * @param {object} update - the data to update the payment session with
     */
    CartService.prototype.updatePaymentSession = function (cartId, update) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: ["payment_sessions"],
                                    })];
                                case 1:
                                    cart = _a.sent();
                                    if (!cart.payment_session) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.paymentProviderService_.updateSessionData(cart.payment_session, update)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3: return [4 /*yield*/, this.retrieve(cart.id)];
                                case 4:
                                    result = _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, result)];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Authorizes a payment for a cart.
     * Will authorize with chosen payment provider. This will return
     * a payment object, that we will use to update our cart payment with.
     * Additionally, if the payment does not require more or fails, we will
     * set the payment on the cart.
     * @param {string} cartId - the id of the cart to authorize payment for
     * @param {object} context - object containing whatever is relevant for
     *    authorizing the payment with the payment provider. As an example,
     *    this could be IP address or similar for fraud handling.
     * @return {Promise<Cart>} the resulting cart
     */
    CartService.prototype.authorizePayment = function (cartId, context) {
        if (context === void 0) { context = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cartRepository, cart, session, freshCart, payment, updated;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    cartRepository = manager.getCustomRepository(this.cartRepository_);
                                    return [4 /*yield*/, this.retrieve(cartId, {
                                            select: ["total"],
                                            relations: ["region", "payment_sessions"],
                                        })];
                                case 1:
                                    cart = _a.sent();
                                    if (typeof cart.total === "undefined") {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "cart.total should be defined");
                                    }
                                    // If cart total is 0, we don't perform anything payment related
                                    if (cart.total <= 0) {
                                        cart.payment_authorized_at = new Date();
                                        return [2 /*return*/, cartRepository.save(cart)];
                                    }
                                    return [4 /*yield*/, this.paymentProviderService_
                                            .withTransaction(manager)
                                            .authorizePayment(cart.payment_session, context)];
                                case 2:
                                    session = _a.sent();
                                    return [4 /*yield*/, this.retrieve(cart.id, {
                                            select: ["total"],
                                            relations: ["payment_sessions"],
                                        })];
                                case 3:
                                    freshCart = _a.sent();
                                    if (!(session.status === "authorized")) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.paymentProviderService_
                                            .withTransaction(manager)
                                            .createPayment(freshCart)];
                                case 4:
                                    payment = _a.sent();
                                    freshCart.payment = payment;
                                    freshCart.payment_authorized_at = new Date();
                                    _a.label = 5;
                                case 5: return [4 /*yield*/, cartRepository.save(freshCart)];
                                case 6:
                                    updated = _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, updated)];
                                case 7:
                                    _a.sent();
                                    return [2 /*return*/, updated];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Sets a payment method for a cart.
     * @param {string} cartId - the id of the cart to add payment method to
     * @param {string} providerId - the id of the provider to be set to the cart
     * @return {Promise} result of update operation
     */
    CartService.prototype.setPaymentSession = function (cartId, providerId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var psRepo, cart, sess, result;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    psRepo = manager.getCustomRepository(this.paymentSessionRepository_);
                                    return [4 /*yield*/, this.retrieve(cartId, {
                                            select: [
                                                "total",
                                                "subtotal",
                                                "tax_total",
                                                "discount_total",
                                                "gift_card_total",
                                            ],
                                            relations: ["region", "region.payment_providers", "payment_sessions"],
                                        })
                                        // The region must have the provider id in its providers array
                                    ];
                                case 1:
                                    cart = _a.sent();
                                    // The region must have the provider id in its providers array
                                    if (providerId !== "system" &&
                                        !(cart.region.payment_providers.length &&
                                            cart.region.payment_providers.find(function (_a) {
                                                var id = _a.id;
                                                return providerId === id;
                                            }))) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "The payment method is not available in this region");
                                    }
                                    return [4 /*yield*/, Promise.all(cart.payment_sessions.map(function (ps) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0: return [4 /*yield*/, psRepo.save(__assign(__assign({}, ps), { is_selected: null }))];
                                                    case 1: return [2 /*return*/, _a.sent()];
                                                }
                                            });
                                        }); }))];
                                case 2:
                                    _a.sent();
                                    sess = cart.payment_sessions.find(function (ps) { return ps.provider_id === providerId; });
                                    if (!sess) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Could not find payment session");
                                    }
                                    sess.is_selected = true;
                                    return [4 /*yield*/, psRepo.save(sess)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.retrieve(cartId)];
                                case 4:
                                    result = _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, result)];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); }, "SERIALIZABLE")];
            });
        });
    };
    /**
     * Creates, updates and sets payment sessions associated with the cart. The
     * first time the method is called payment sessions will be created for each
     * provider. Additional calls will ensure that payment sessions have correct
     * amounts, currencies, etc. as well as make sure to filter payment sessions
     * that are not available for the cart's region.
     * @param {Cart | string} cartOrCartId - the id of the cart to set payment
     * session for
     * @return {Promise} the result of the update operation.
     */
    CartService.prototype.setPaymentSessions = function (cartOrCartId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var psRepo, cartId, cart, region, seen, _loop_1, this_1, _a, _b, session, e_9_1, p, sess, _c, _d, provider, e_10_1;
                        var e_9, _e, e_10, _f;
                        return __generator(this, function (_g) {
                            switch (_g.label) {
                                case 0:
                                    psRepo = manager.getCustomRepository(this.paymentSessionRepository_);
                                    cartId = typeof cartOrCartId === "string" ? cartOrCartId : cartOrCartId.id;
                                    return [4 /*yield*/, this.retrieve(cartId, {
                                            select: [
                                                "gift_card_total",
                                                "subtotal",
                                                "tax_total",
                                                "shipping_total",
                                                "discount_total",
                                                "total",
                                            ],
                                            relations: [
                                                "items",
                                                "discounts",
                                                "discounts.rule",
                                                "discounts.rule.valid_for",
                                                "gift_cards",
                                                "billing_address",
                                                "shipping_address",
                                                "region",
                                                "region.payment_providers",
                                                "payment_sessions",
                                                "customer",
                                            ],
                                        })];
                                case 1:
                                    cart = _g.sent();
                                    region = cart.region;
                                    if (typeof cart.total === "undefined") {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "cart.total should be defined");
                                    }
                                    seen = [];
                                    if (!(cart.payment_sessions && cart.payment_sessions.length)) return [3 /*break*/, 9];
                                    _loop_1 = function (session) {
                                        return __generator(this, function (_h) {
                                            switch (_h.label) {
                                                case 0:
                                                    if (!(cart.total <= 0 ||
                                                        !region.payment_providers.find(function (_a) {
                                                            var id = _a.id;
                                                            return id === session.provider_id;
                                                        }))) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, this_1.paymentProviderService_
                                                            .withTransaction(manager)
                                                            .deleteSession(session)];
                                                case 1:
                                                    _h.sent();
                                                    return [3 /*break*/, 4];
                                                case 2:
                                                    seen.push(session.provider_id);
                                                    return [4 /*yield*/, this_1.paymentProviderService_
                                                            .withTransaction(manager)
                                                            .updateSession(session, cart)];
                                                case 3:
                                                    _h.sent();
                                                    _h.label = 4;
                                                case 4: return [2 /*return*/];
                                            }
                                        });
                                    };
                                    this_1 = this;
                                    _g.label = 2;
                                case 2:
                                    _g.trys.push([2, 7, 8, 9]);
                                    _a = __values(cart.payment_sessions), _b = _a.next();
                                    _g.label = 3;
                                case 3:
                                    if (!!_b.done) return [3 /*break*/, 6];
                                    session = _b.value;
                                    return [5 /*yield**/, _loop_1(session)];
                                case 4:
                                    _g.sent();
                                    _g.label = 5;
                                case 5:
                                    _b = _a.next();
                                    return [3 /*break*/, 3];
                                case 6: return [3 /*break*/, 9];
                                case 7:
                                    e_9_1 = _g.sent();
                                    e_9 = { error: e_9_1 };
                                    return [3 /*break*/, 9];
                                case 8:
                                    try {
                                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                                    }
                                    finally { if (e_9) throw e_9.error; }
                                    return [7 /*endfinally*/];
                                case 9:
                                    if (!(cart.total > 0)) return [3 /*break*/, 19];
                                    if (!(region.payment_providers.length === 1 && !cart.payment_session)) return [3 /*break*/, 12];
                                    p = region.payment_providers[0];
                                    return [4 /*yield*/, this.paymentProviderService_
                                            .withTransaction(manager)
                                            .createSession(p.id, cart)];
                                case 10:
                                    sess = _g.sent();
                                    sess.is_selected = true;
                                    return [4 /*yield*/, psRepo.save(sess)];
                                case 11:
                                    _g.sent();
                                    return [3 /*break*/, 19];
                                case 12:
                                    _g.trys.push([12, 17, 18, 19]);
                                    _c = __values(region.payment_providers), _d = _c.next();
                                    _g.label = 13;
                                case 13:
                                    if (!!_d.done) return [3 /*break*/, 16];
                                    provider = _d.value;
                                    if (!!seen.includes(provider.id)) return [3 /*break*/, 15];
                                    return [4 /*yield*/, this.paymentProviderService_
                                            .withTransaction(manager)
                                            .createSession(provider.id, cart)];
                                case 14:
                                    _g.sent();
                                    _g.label = 15;
                                case 15:
                                    _d = _c.next();
                                    return [3 /*break*/, 13];
                                case 16: return [3 /*break*/, 19];
                                case 17:
                                    e_10_1 = _g.sent();
                                    e_10 = { error: e_10_1 };
                                    return [3 /*break*/, 19];
                                case 18:
                                    try {
                                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                                    }
                                    finally { if (e_10) throw e_10.error; }
                                    return [7 /*endfinally*/];
                                case 19: return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Removes a payment session from the cart.
     * @param {string} cartId - the id of the cart to remove from
     * @param {string} providerId - the id of the provider whoose payment session
     *    should be removed.
     * @return {Promise<Cart>} the resulting cart.
     */
    CartService.prototype.deletePaymentSession = function (cartId, providerId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, cartRepo, session;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: ["payment_sessions"],
                                    })];
                                case 1:
                                    cart = _a.sent();
                                    cartRepo = manager.getCustomRepository(this.cartRepository_);
                                    if (!cart.payment_sessions) return [3 /*break*/, 3];
                                    session = cart.payment_sessions.find(function (_a) {
                                        var provider_id = _a.provider_id;
                                        return provider_id === providerId;
                                    });
                                    cart.payment_sessions = cart.payment_sessions.filter(function (_a) {
                                        var provider_id = _a.provider_id;
                                        return provider_id !== providerId;
                                    });
                                    if (!session) return [3 /*break*/, 3];
                                    // Delete the session with the provider
                                    return [4 /*yield*/, this.paymentProviderService_
                                            .withTransaction(manager)
                                            .deleteSession(session)];
                                case 2:
                                    // Delete the session with the provider
                                    _a.sent();
                                    _a.label = 3;
                                case 3: return [4 /*yield*/, cartRepo.save(cart)];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, cart)];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, cart];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Refreshes a payment session on a cart
     * @param {string} cartId - the id of the cart to remove from
     * @param {string} providerId - the id of the provider whoose payment session
     *    should be removed.
     * @return {Promise<Cart>} the resulting cart.
     */
    CartService.prototype.refreshPaymentSession = function (cartId, providerId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, session, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: ["payment_sessions"],
                                    })];
                                case 1:
                                    cart = _a.sent();
                                    if (!cart.payment_sessions) return [3 /*break*/, 3];
                                    session = cart.payment_sessions.find(function (_a) {
                                        var provider_id = _a.provider_id;
                                        return provider_id === providerId;
                                    });
                                    if (!session) return [3 /*break*/, 3];
                                    // Delete the session with the provider
                                    return [4 /*yield*/, this.paymentProviderService_
                                            .withTransaction(manager)
                                            .refreshSession(session, cart)];
                                case 2:
                                    // Delete the session with the provider
                                    _a.sent();
                                    _a.label = 3;
                                case 3: return [4 /*yield*/, this.retrieve(cartId)];
                                case 4:
                                    result = _a.sent();
                                    return [4 /*yield*/, this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, result)];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Adds the shipping method to the list of shipping methods associated with
     * the cart. Shipping Methods are the ways that an order is shipped, whereas a
     * Shipping Option is a possible way to ship an order. Shipping Methods may
     * also have additional details in the data field such as an id for a package
     * shop.
     * @param {string} cartId - the id of the cart to add shipping method to
     * @param {string} optionId - id of shipping option to add as valid method
     * @param {Object} data - the fulmillment data for the method
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.addShippingMethod = function (cartId, optionId, data) {
        if (data === void 0) { data = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cart, cartCustomShippingOptions, customShippingOption, shipping_methods, shippingMethodConfig, newMethod, methods, shipping_methods_1, shipping_methods_1_1, sm, e_11_1, _a, _b, item, e_12_1, result;
                        var e_11, _c, e_12, _d;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                        select: ["subtotal"],
                                        relations: [
                                            "shipping_methods",
                                            "discounts",
                                            "discounts.rule",
                                            "discounts.rule.valid_for",
                                            "shipping_methods.shipping_option",
                                            "items",
                                            "items.variant",
                                            "payment_sessions",
                                            "items.variant.product",
                                        ],
                                    })];
                                case 1:
                                    cart = _e.sent();
                                    return [4 /*yield*/, this.customShippingOptionService_.list({ cart_id: cart.id })];
                                case 2:
                                    cartCustomShippingOptions = _e.sent();
                                    customShippingOption = this.findCustomShippingOption(cartCustomShippingOptions, optionId);
                                    shipping_methods = cart.shipping_methods;
                                    shippingMethodConfig = customShippingOption
                                        ? { cart_id: cart.id, price: customShippingOption.price }
                                        : {
                                            cart: cart,
                                        };
                                    return [4 /*yield*/, this.shippingOptionService_
                                            .withTransaction(manager)
                                            .createShippingMethod(optionId, data, shippingMethodConfig)];
                                case 3:
                                    newMethod = _e.sent();
                                    methods = [newMethod];
                                    if (!shipping_methods.length) return [3 /*break*/, 12];
                                    _e.label = 4;
                                case 4:
                                    _e.trys.push([4, 10, 11, 12]);
                                    shipping_methods_1 = __values(shipping_methods), shipping_methods_1_1 = shipping_methods_1.next();
                                    _e.label = 5;
                                case 5:
                                    if (!!shipping_methods_1_1.done) return [3 /*break*/, 9];
                                    sm = shipping_methods_1_1.value;
                                    if (!(sm.shipping_option.profile_id ===
                                        newMethod.shipping_option.profile_id)) return [3 /*break*/, 7];
                                    return [4 /*yield*/, this.shippingOptionService_
                                            .withTransaction(manager)
                                            .deleteShippingMethod(sm)];
                                case 6:
                                    _e.sent();
                                    return [3 /*break*/, 8];
                                case 7:
                                    methods.push(sm);
                                    _e.label = 8;
                                case 8:
                                    shipping_methods_1_1 = shipping_methods_1.next();
                                    return [3 /*break*/, 5];
                                case 9: return [3 /*break*/, 12];
                                case 10:
                                    e_11_1 = _e.sent();
                                    e_11 = { error: e_11_1 };
                                    return [3 /*break*/, 12];
                                case 11:
                                    try {
                                        if (shipping_methods_1_1 && !shipping_methods_1_1.done && (_c = shipping_methods_1.return)) _c.call(shipping_methods_1);
                                    }
                                    finally { if (e_11) throw e_11.error; }
                                    return [7 /*endfinally*/];
                                case 12:
                                    _e.trys.push([12, 17, 18, 19]);
                                    _a = __values(cart.items), _b = _a.next();
                                    _e.label = 13;
                                case 13:
                                    if (!!_b.done) return [3 /*break*/, 16];
                                    item = _b.value;
                                    return [4 /*yield*/, this.lineItemService_.withTransaction(manager).update(item.id, {
                                            has_shipping: this.validateLineItemShipping_(methods, item),
                                        })];
                                case 14:
                                    _e.sent();
                                    _e.label = 15;
                                case 15:
                                    _b = _a.next();
                                    return [3 /*break*/, 13];
                                case 16: return [3 /*break*/, 19];
                                case 17:
                                    e_12_1 = _e.sent();
                                    e_12 = { error: e_12_1 };
                                    return [3 /*break*/, 19];
                                case 18:
                                    try {
                                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                                    }
                                    finally { if (e_12) throw e_12.error; }
                                    return [7 /*endfinally*/];
                                case 19: return [4 /*yield*/, this.retrieve(cartId, {
                                        relations: [
                                            "discounts",
                                            "discounts.rule",
                                            "discounts.rule.valid_for",
                                            "shipping_methods",
                                        ],
                                    })
                                    // if cart has freeshipping, adjust price
                                ];
                                case 20:
                                    result = _e.sent();
                                    if (!result.discounts.some(function (_a) {
                                        var rule = _a.rule;
                                        return rule.type === "free_shipping";
                                    })) return [3 /*break*/, 22];
                                    return [4 /*yield*/, this.adjustFreeShipping_(result, true)];
                                case 21:
                                    _e.sent();
                                    _e.label = 22;
                                case 22: return [4 /*yield*/, this.eventBus_
                                        .withTransaction(manager)
                                        .emit(CartService.Events.UPDATED, result)];
                                case 23:
                                    _e.sent();
                                    return [2 /*return*/, result];
                            }
                        });
                    }); }, "SERIALIZABLE")];
            });
        });
    };
    /**
     * Finds the cart's custom shipping options based on the passed option id.
     * throws if custom options is not empty and no shipping option corresponds to optionId
     * @param {Object} cartCustomShippingOptions - the cart's custom shipping options
     * @param {string} optionId - id of the normal or custom shipping option to find in the cartCustomShippingOptions
     * @return {CustomShippingOption | undefined}
     */
    CartService.prototype.findCustomShippingOption = function (cartCustomShippingOptions, optionId) {
        var customOption = cartCustomShippingOptions === null || cartCustomShippingOptions === void 0 ? void 0 : cartCustomShippingOptions.find(function (cso) { return cso.shipping_option_id === optionId; });
        var hasCustomOptions = cartCustomShippingOptions === null || cartCustomShippingOptions === void 0 ? void 0 : cartCustomShippingOptions.length;
        if (hasCustomOptions && !customOption) {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Wrong shipping option");
        }
        return customOption;
    };
    /**
     * Set's the region of a cart.
     * @param {Cart} cart - the cart to set region on
     * @param {string} regionId - the id of the region to set the region to
     * @param {string} countryCode - the country code to set the country to
     * @return {Promise} the result of the update operation
     */
    CartService.prototype.setRegion_ = function (cart, regionId, countryCode) {
        return __awaiter(this, void 0, void 0, function () {
            var region, addrRepo, _a, shippingAddress, updated, updated, smRepo, newDiscounts;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (cart.completed_at || cart.payment_authorized_at) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Cannot change the region of a completed cart");
                        }
                        return [4 /*yield*/, this.regionService_.retrieve(regionId, {
                                relations: ["countries"],
                            })];
                    case 1:
                        region = _b.sent();
                        addrRepo = this.manager_.getCustomRepository(this.addressRepository_);
                        cart.region = region;
                        cart.region_id = region.id;
                        if (!cart.items.length) return [3 /*break*/, 3];
                        _a = cart;
                        return [4 /*yield*/, Promise.all(cart.items
                                .map(function (item) { return __awaiter(_this, void 0, void 0, function () {
                                var availablePrice;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.productVariantService_
                                                .getRegionPrice(item.variant_id, regionId)
                                                .catch(function () { return undefined; })];
                                        case 1:
                                            availablePrice = _a.sent();
                                            if (!(availablePrice !== undefined)) return [3 /*break*/, 2];
                                            return [2 /*return*/, this.lineItemService_
                                                    .withTransaction(this.transactionManager_)
                                                    .update(item.id, {
                                                    has_shipping: false,
                                                    unit_price: availablePrice,
                                                })];
                                        case 2: return [4 /*yield*/, this.lineItemService_
                                                .withTransaction(this.transactionManager_)
                                                .delete(item.id)];
                                        case 3:
                                            _a.sent();
                                            return [2 /*return*/, null];
                                    }
                                });
                            }); })
                                .filter(Boolean))];
                    case 2:
                        _a.items = _b.sent();
                        _b.label = 3;
                    case 3:
                        shippingAddress = {};
                        if (!cart.shipping_address_id) return [3 /*break*/, 5];
                        return [4 /*yield*/, addrRepo.findOne({
                                where: { id: cart.shipping_address_id },
                            })];
                    case 4:
                        shippingAddress = (_b.sent());
                        _b.label = 5;
                    case 5:
                        if (!(countryCode !== null)) return [3 /*break*/, 7];
                        if (!region.countries.find(function (_a) {
                            var iso_2 = _a.iso_2;
                            return iso_2 === countryCode.toLowerCase();
                        })) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Country not available in region");
                        }
                        updated = __assign(__assign({}, shippingAddress), { country_code: countryCode.toLowerCase() });
                        return [4 /*yield*/, addrRepo.save(updated)];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 7:
                        updated = __assign({}, shippingAddress);
                        // If the country code of a shipping address is set we need to clear it
                        if (!lodash_1.default.isEmpty(shippingAddress) && shippingAddress.country_code) {
                            updated = __assign(__assign({}, updated), { country_code: null });
                        }
                        // If there is only one country in the region preset it
                        if (region.countries.length === 1) {
                            updated = __assign(__assign({}, updated), { country_code: region.countries[0].iso_2 });
                        }
                        return [4 /*yield*/, this.updateShippingAddress_(cart, updated, addrRepo)];
                    case 8:
                        _b.sent();
                        _b.label = 9;
                    case 9:
                        if (!(cart.shipping_methods && cart.shipping_methods.length)) return [3 /*break*/, 11];
                        smRepo = this.manager_.getCustomRepository(this.shippingMethodRepository_);
                        return [4 /*yield*/, smRepo.remove(cart.shipping_methods)];
                    case 10:
                        _b.sent();
                        _b.label = 11;
                    case 11:
                        if (cart.discounts && cart.discounts.length) {
                            newDiscounts = cart.discounts.map(function (d) {
                                if (d.regions.find(function (_a) {
                                    var id = _a.id;
                                    return id === regionId;
                                })) {
                                    return d;
                                }
                                return null;
                            });
                            cart.discounts = newDiscounts.filter(Boolean);
                        }
                        cart.gift_cards = [];
                        if (!(cart.payment_sessions && cart.payment_sessions.length)) return [3 /*break*/, 13];
                        return [4 /*yield*/, Promise.all(cart.payment_sessions.map(function (ps) {
                                return _this.paymentProviderService_
                                    .withTransaction(_this.manager_)
                                    .deleteSession(ps);
                            }))];
                    case 12:
                        _b.sent();
                        cart.payment_sessions = [];
                        cart.payment_session = null;
                        _b.label = 13;
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deletes a cart from the database. Completed carts cannot be deleted.
     * @param {string} cartId - the id of the cart to delete
     * @return {Promise<string>} the deleted cart or undefined if the cart was
     *    not found.
     */
    CartService.prototype.delete = function (cartId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                            var cart, cartRepo;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.retrieve(cartId, {
                                            relations: [
                                                "items",
                                                "discounts",
                                                "discounts.rule",
                                                "discounts.rule.valid_for",
                                                "payment_sessions",
                                            ],
                                        })];
                                    case 1:
                                        cart = _a.sent();
                                        if (cart.completed_at) {
                                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Completed carts cannot be deleted");
                                        }
                                        if (cart.payment_authorized_at) {
                                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_ALLOWED, "Can't delete a cart with an authorized payment");
                                        }
                                        cartRepo = manager.getCustomRepository(this.cartRepository_);
                                        return [2 /*return*/, cartRepo.remove(cart)];
                                }
                            });
                        }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Dedicated method to set metadata for a cart.
     * To ensure that plugins does not overwrite each
     * others metadata fields, setMetadata is provided.
     * @param {string} cartId - the cart to apply metadata to.
     * @param {string} key - key for metadata field
     * @param {string} value - value for metadata field.
     * @return {Promise} resolves to the updated result.
     */
    CartService.prototype.setMetadata = function (cartId, key, value) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                            var cartRepo, validatedId, cart, existing, result;
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        cartRepo = manager.getCustomRepository(this.cartRepository_);
                                        validatedId = this.validateId_(cartId);
                                        if (typeof key !== "string") {
                                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_ARGUMENT, "Key type is invalid. Metadata keys must be strings");
                                        }
                                        return [4 /*yield*/, cartRepo.findOne(validatedId)];
                                    case 1:
                                        cart = (_b.sent());
                                        existing = cart.metadata || {};
                                        cart.metadata = __assign(__assign({}, existing), (_a = {}, _a[key] = value, _a));
                                        return [4 /*yield*/, cartRepo.save(cart)];
                                    case 2:
                                        result = _b.sent();
                                        this.eventBus_
                                            .withTransaction(manager)
                                            .emit(CartService.Events.UPDATED, result);
                                        return [2 /*return*/, result];
                                }
                            });
                        }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Dedicated method to delete metadata for a cart.
     * @param {string} cartId - the cart to delete metadata from.
     * @param {string} key - key for metadata field
     * @return {Promise} resolves to the updated result.
     */
    CartService.prototype.deleteMetadata = function (cartId, key) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.atomicPhase_(function (manager) { return __awaiter(_this, void 0, void 0, function () {
                        var cartRepo, validatedId, cart, updated, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    cartRepo = manager.getCustomRepository(this.cartRepository_);
                                    validatedId = this.validateId_(cartId);
                                    if (typeof key !== "string") {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_ARGUMENT, "Key type is invalid. Metadata keys must be strings");
                                    }
                                    return [4 /*yield*/, cartRepo.findOne(validatedId)];
                                case 1:
                                    cart = _a.sent();
                                    if (!cart) {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, "Cart with id: ".concat(validatedId, " was not found"));
                                    }
                                    updated = cart.metadata || {};
                                    delete updated[key];
                                    cart.metadata = updated;
                                    return [4 /*yield*/, cartRepo.save(cart)];
                                case 2:
                                    result = _a.sent();
                                    this.eventBus_
                                        .withTransaction(manager)
                                        .emit(CartService.Events.UPDATED, result);
                                    return [2 /*return*/, result];
                            }
                        });
                    }); })];
            });
        });
    };
    CartService.Events = {
        CUSTOMER_UPDATED: "cart.customer_updated",
        CREATED: "cart.created",
        UPDATED: "cart.updated",
    };
    return CartService;
}(medusa_interfaces_1.BaseService));
exports.default = CartService;
//# sourceMappingURL=cart.js.map