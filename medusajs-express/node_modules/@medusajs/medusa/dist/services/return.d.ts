export default ReturnService;
declare const ReturnService_base: any;
/**
 * Handles Returns
 * @extends BaseService
 */
declare class ReturnService extends ReturnService_base {
    [x: string]: any;
    constructor({ manager, totalsService, lineItemService, returnRepository, returnItemRepository, shippingOptionService, returnReasonService, fulfillmentProviderService, inventoryService, orderService, }: {
        manager: any;
        totalsService: any;
        lineItemService: any;
        returnRepository: any;
        returnItemRepository: any;
        shippingOptionService: any;
        returnReasonService: any;
        fulfillmentProviderService: any;
        inventoryService: any;
        orderService: any;
    });
    /** @private @const {EntityManager} */
    private manager_;
    /** @private @const {TotalsService} */
    private totalsService_;
    /** @private @const {ReturnRepository} */
    private returnRepository_;
    /** @private @const {ReturnItemRepository} */
    private returnItemRepository_;
    /** @private @const {ReturnItemRepository} */
    private lineItemService_;
    /** @private @const {ShippingOptionService} */
    private shippingOptionService_;
    /** @private @const {FulfillmentProviderService} */
    private fulfillmentProviderService_;
    returnReasonService_: any;
    inventoryService_: any;
    /** @private @const {OrderService} */
    private orderService_;
    withTransaction(transactionManager: any): ReturnService;
    /**
     * Retrieves the order line items, given an array of items
     * @param {Order} order - the order to get line items from
     * @param {{ item_id: string, quantity: number }} items - the items to get
     * @param {function} transformer - a function to apply to each of the items
     *    retrieved from the order, should return a line item. If the transformer
     *    returns an undefined value the line item will be filtered from the
     *    returned array.
     * @return {Promise<Array<LineItem>>} the line items generated by the transformer.
     */
    getFulfillmentItems_(order: Order, items: {
        item_id: string;
        quantity: number;
    }, transformer: Function): Promise<Array<LineItem>>;
    /**
     * @param {Object} selector - the query object for find
     * @param {object} config - the config object for find
     * @return {Promise} the result of the find operation
     */
    list(selector: any, config?: object): Promise<any>;
    /**
     * Cancels a return if possible. Returns can be canceled if it has not been received.
     * @param {string} returnId - the id of the return to cancel.
     * @return {Promise<Return>} the updated Return
     */
    cancel(returnId: string): Promise<Return>;
    /**
     * Checks that an order has the statuses necessary to complete a return.
     * fulfillment_status cannot be not_fulfilled or returned.
     * payment_status must be captured.
     * @param {Order} order - the order to check statuses on
     * @throws when statuses are not sufficient for returns.
     */
    validateReturnStatuses_(order: Order): void;
    /**
     * Checks that a given quantity of a line item can be returned. Fails if the
     * item is undefined or if the returnable quantity of the item is lower, than
     * the quantity that is requested to be returned.
     * @param {LineItem?} item - the line item to check has sufficient returnable
     *   quantity.
     * @param {number} quantity - the quantity that is requested to be returned.
     * @param {object} additional - the quantity that is requested to be returned.
     * @return {LineItem} a line item where the quantity is set to the requested
     *   return quantity.
     */
    validateReturnLineItem_(item: LineItem | null, quantity: number, additional: object): LineItem;
    /**
     * Retrieves a return by its id.
     * @param {string} id - the id of the return to retrieve
     * @param {object} config - the config object
     * @return {Return} the return
     */
    retrieve(id: string, config?: object): Return;
    retrieveBySwap(swapId: any, relations?: any[]): Promise<any>;
    update(returnId: any, update: any): Promise<any>;
    /**
     * Creates a return request for an order, with given items, and a shipping
     * method. If no refund amount is provided the refund amount is calculated from
     * the return lines and the shipping cost.
     * @param {object} data - data to use for the return e.g. shipping_method,
     *    items or refund_amount
     * @param {object} orderLike - order object
     * @return {Promise<Return>} the created return
     */
    create(data: object): Promise<Return>;
    fulfill(returnId: any): any;
    /**
     * Registers a previously requested return as received. This will create a
     * refund to the customer. If the returned items don't match the requested
     * items the return status will be updated to requires_action. This behaviour
     * is useful in sitautions where a custom refund amount is requested, but the
     * retuned items are not matching the requested items. Setting the
     * allowMismatch argument to true, will process the return, ignoring any
     * mismatches.
     * @param {string} return_id - the orderId to return to
     * @param {Item[]} received_items - the items received after return.
     * @param {number | undefined} refund_amount - the amount to return
     * @param {bool} allow_mismatch - whether to ignore return/received
     * product mismatch
     * @return {Promise} the result of the update operation
     */
    receive(return_id: string, received_items: Item[], refund_amount: number | undefined, allow_mismatch?: bool): Promise<any>;
}
