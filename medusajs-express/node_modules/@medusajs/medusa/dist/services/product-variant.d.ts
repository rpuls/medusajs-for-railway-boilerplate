import { BaseService } from "medusa-interfaces";
import { EntityManager } from "typeorm";
import { MoneyAmount } from "../models/money-amount";
import { Product } from "../models/product";
import { ProductOptionValue } from "../models/product-option-value";
import { ProductVariant } from "../models/product-variant";
import { FindConfig } from "../types/common";
import { CreateProductVariantInput, FilterableProductVariantProps, ProductVariantPrice, UpdateProductVariantInput } from "../types/product-variant";
/**
 * Provides layer to manipulate product variants.
 * @extends BaseService
 */
declare class ProductVariantService extends BaseService {
    static Events: {
        UPDATED: string;
        CREATED: string;
        DELETED: string;
    };
    private manager_;
    private productVariantRepository_;
    private productRepository_;
    private eventBus_;
    private regionService_;
    private moneyAmountRepository_;
    private productOptionValueRepository_;
    constructor({ manager, productVariantRepository, productRepository, eventBusService, regionService, moneyAmountRepository, productOptionValueRepository, }: {
        manager: any;
        productVariantRepository: any;
        productRepository: any;
        eventBusService: any;
        regionService: any;
        moneyAmountRepository: any;
        productOptionValueRepository: any;
    });
    withTransaction(transactionManager: EntityManager): ProductVariantService;
    /**
     * Gets a product variant by id.
     * @param {string} variantId - the id of the product to get.
     * @param {FindConfig<ProductVariant>} config - query config object for variant retrieval.
     * @return {Promise<Product>} the product document.
     */
    retrieve(variantId: string, config?: FindConfig<ProductVariant>): Promise<ProductVariant>;
    /**
     * Gets a product variant by id.
     * @param {string} sku - The unique stock keeping unit used to identify the product variant.
     * @param {FindConfig<ProductVariant>} config - query config object for variant retrieval.
     * @return {Promise<Product>} the product document.
     */
    retrieveBySKU(sku: string, config?: FindConfig<ProductVariant>): Promise<ProductVariant>;
    /**
     * Creates an unpublished product variant. Will validate against parent product
     * to ensure that the variant can in fact be created.
     * @param {string} productOrProductId - the product the variant will be added to
     * @param {object} variant - the variant to create
     * @return {Promise} resolves to the creation result.
     */
    create(productOrProductId: string | Product, variant: CreateProductVariantInput): Promise<ProductVariant>;
    /**
     * Updates a variant.
     * Price updates should use dedicated methods.
     * The function will throw, if price updates are attempted.
     * @param {string | ProductVariant} variantOrVariantId - variant or id of a variant.
     * @param {object} update - an object with the update values.
     * @return {Promise} resolves to the update result.
     */
    update(variantOrVariantId: string | Partial<ProductVariant>, update: UpdateProductVariantInput): Promise<ProductVariant>;
    /**
     * Sets the default price for the given currency.
     * @param {string} variantId - the id of the variant to set prices for
     * @param {ProductVariantPrice} price - the price for the variant
     * @return {Promise} the result of the update operation
     */
    setCurrencyPrice(variantId: string, price: ProductVariantPrice): Promise<MoneyAmount>;
    /**
     * Gets the price specific to a region. If no region specific money amount
     * exists the function will try to use a currency price. If no default
     * currency price exists the function will throw an error.
     * @param {string} variantId - the id of the variant to get price from
     * @param {string} regionId - the id of the region to get price for
     * @return {number} the price specific to the region
     */
    getRegionPrice(variantId: string, regionId: string): Promise<number>;
    /**
     * Sets the price of a specific region
     * @param {string} variantId - the id of the variant to update
     * @param {string} price - the price for the variant.
     * @return {Promise} the result of the update operation
     */
    setRegionPrice(variantId: string, price: ProductVariantPrice): Promise<MoneyAmount>;
    /**
     * Updates variant's option value.
     * Option value must be of type string or number.
     * @param {string} variantId - the variant to decorate.
     * @param {string} optionId - the option from product.
     * @param {string} optionValue - option value to add.
     * @return {Promise} the result of the update operation.
     */
    updateOptionValue(variantId: string, optionId: string, optionValue: string): Promise<ProductOptionValue>;
    /**
     * Adds option value to a varaint.
     * Fails when product with variant does not exists or
     * if that product does not have an option with the given
     * option id. Fails if given variant is not found.
     * Option value must be of type string or number.
     * @param {string} variantId - the variant to decorate.
     * @param {string} optionId - the option from product.
     * @param {string} optionValue - option value to add.
     * @return {Promise} the result of the update operation.
     */
    addOptionValue(variantId: string, optionId: string, optionValue: string): Promise<ProductOptionValue>;
    /**
     * Deletes option value from given variant.
     * Will never fail due to delete being idempotent.
     * @param {string} variantId - the variant to decorate.
     * @param {string} optionId - the option from product.
     * @return {Promise} empty promise
     */
    deleteOptionValue(variantId: string, optionId: string): Promise<void>;
    /**
     * @param {FilterableProductVariantProps} selector - the query object for find
     * @param {FindConfig<ProductVariant>} config - query config object for variant retrieval
     * @return {Promise} the result of the find operation
     */
    list(selector: FilterableProductVariantProps, config?: FindConfig<ProductVariant>): Promise<ProductVariant[]>;
    /**
     * Deletes variant.
     * Will never fail due to delete being idempotent.
     * @param {string} variantId - the id of the variant to delete. Must be
     *   castable as an ObjectId
     * @return {Promise<void>} empty promise
     */
    delete(variantId: string): Promise<void>;
    /**
     * Dedicated method to set metadata for a variant.
     * @param {string} variant - the variant to set metadata for.
     * @param {Object} metadata - the metadata to set
     * @return {Object} updated metadata object
     */
    setMetadata_(variant: ProductVariant, metadata: object): object;
}
export default ProductVariantService;
