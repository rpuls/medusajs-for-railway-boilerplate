var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.defaults/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = defaults;
  }
});

// node_modules/lodash.flatten/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.flatten/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayPush(array, values2) {
      var index = -1, length = values2.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values2[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function isFlattenable(value) {
      return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function flatten3(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = flatten3;
  }
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash3 = __commonJS({
  "node_modules/ioredis/built/utils/lodash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var defaults = require_lodash();
    exports2.defaults = defaults;
    var flatten3 = require_lodash2();
    exports2.flatten = flatten3;
    function noop() {
    }
    exports2.noop = noop;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get2(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push2(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length *= 2;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/redis-commands/commands.json
var require_commands = __commonJS({
  "node_modules/redis-commands/commands.json"(exports2, module2) {
    module2.exports = {
      acl: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      append: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      asking: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      auth: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog",
          "fast",
          "no_auth"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgrewriteaof: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgsave: {
        arity: -1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bitcount: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield_ro: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitop: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: -1,
        step: 1
      },
      bitpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      blmove: {
        arity: 6,
        flags: [
          "write",
          "denyoom",
          "noscript"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      blpop: {
        arity: -3,
        flags: [
          "write",
          "noscript"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpop: {
        arity: -3,
        flags: [
          "write",
          "noscript"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpoplpush: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "noscript"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      bzpopmax: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      bzpopmin: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      client: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      cluster: {
        arity: -2,
        flags: [
          "admin",
          "random",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      command: {
        arity: -1,
        flags: [
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      config: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      copy: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      dbsize: {
        arity: 1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      debug: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      decr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      decrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      del: {
        arity: -2,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      discard: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      dump: {
        arity: 2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      echo: {
        arity: 2,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      eval: {
        arity: -3,
        flags: [
          "noscript",
          "may_replicate",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      evalsha: {
        arity: -3,
        flags: [
          "noscript",
          "may_replicate",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exec: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exists: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      expire: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      expireat: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      failover: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushall: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushdb: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      geoadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geodist: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geohash: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geopos: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius: {
        arity: -6,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius_ro: {
        arity: -6,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember_ro: {
        arity: -5,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearch: {
        arity: -7,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearchstore: {
        arity: -8,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      get: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getbit: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getdel: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getex: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getset: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hello: {
        arity: -1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog",
          "fast",
          "no_auth"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hexists: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hget: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hgetall: {
        arity: 2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrbyfloat: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hkeys: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmget: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "host:": {
        arity: -1,
        flags: [
          "readonly",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hrandfield: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hsetnx: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hstrlen: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hvals: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrbyfloat: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      info: {
        arity: -1,
        flags: [
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      keys: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lastsave: {
        arity: 1,
        flags: [
          "random",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      latency: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lindex: {
        arity: 3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      linsert: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      llen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lmove: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      lolwut: {
        arity: -1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrem: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lset: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      ltrim: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      memory: {
        arity: -2,
        flags: [
          "readonly",
          "random",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      mget: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      migrate: {
        arity: -6,
        flags: [
          "write",
          "random",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      module: {
        arity: -2,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      monitor: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      move: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      mset: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      msetnx: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      multi: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      object: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      persist: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpire: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpireat: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfadd: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfcount: {
        arity: -2,
        flags: [
          "readonly",
          "may_replicate"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfdebug: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "admin"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      pfmerge: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfselftest: {
        arity: 1,
        flags: [
          "admin"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      ping: {
        arity: -1,
        flags: [
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      post: {
        arity: -1,
        flags: [
          "readonly",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psetex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      psubscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psync: {
        arity: -3,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pttl: {
        arity: 2,
        flags: [
          "readonly",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      publish: {
        arity: 3,
        flags: [
          "pubsub",
          "loading",
          "stale",
          "fast",
          "may_replicate"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pubsub: {
        arity: -2,
        flags: [
          "pubsub",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      punsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      quit: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "readonly"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      randomkey: {
        arity: 1,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readonly: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readwrite: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rename: {
        arity: 3,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      renamenx: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      replconf: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      replicaof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      reset: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      restore: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "restore-asking": {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "asking"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      role: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpoplpush: {
        arity: 3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      rpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sadd: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      save: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scan: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      script: {
        arity: -2,
        flags: [
          "noscript",
          "may_replicate"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sdiff: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sdiffstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      select: {
        arity: 2,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      set: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setbit: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setnx: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setrange: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      shutdown: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sinter: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sinterstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sismember: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      slaveof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      slowlog: {
        arity: -2,
        flags: [
          "admin",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      smembers: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smismember: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smove: {
        arity: 4,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      sort: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      spop: {
        arity: -2,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srandmember: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      stralgo: {
        arity: -2,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      strlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      subscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      substr: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sunion: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sunionstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      swapdb: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sync: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      time: {
        arity: 1,
        flags: [
          "random",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      touch: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      ttl: {
        arity: 2,
        flags: [
          "readonly",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      type: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      unlink: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      unsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      unwatch: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      wait: {
        arity: 3,
        flags: [
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      watch: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      xack: {
        arity: -4,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xautoclaim: {
        arity: -6,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xclaim: {
        arity: -6,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xgroup: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      xinfo: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      xlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xpending: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xread: {
        arity: -4,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xreadgroup: {
        arity: -7,
        flags: [
          "write",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xsetid: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xtrim: {
        arity: -2,
        flags: [
          "write",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zadd: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zdiff: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zdiffstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zinter: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zinterstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zlexcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zmscore: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmax: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmin: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrandmember: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangestore: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      zrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebylex: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyrank: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyscore: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscore: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zunion: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zunionstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      }
    };
  }
});

// node_modules/redis-commands/index.js
var require_redis_commands = __commonJS({
  "node_modules/redis-commands/index.js"(exports2) {
    "use strict";
    var commands = require_commands();
    exports2.list = Object.keys(commands);
    var flags = {};
    exports2.list.forEach(function(commandName) {
      flags[commandName] = commands[commandName].flags.reduce(function(flags2, flag) {
        flags2[flag] = true;
        return flags2;
      }, {});
    });
    exports2.exists = function(commandName) {
      return Boolean(commands[commandName]);
    };
    exports2.hasFlag = function(commandName, flag) {
      if (!flags[commandName]) {
        throw new Error("Unknown command " + commandName);
      }
      return Boolean(flags[commandName][flag]);
    };
    exports2.getKeyIndexes = function(commandName, args, options) {
      var command2 = commands[commandName];
      if (!command2) {
        throw new Error("Unknown command " + commandName);
      }
      if (!Array.isArray(args)) {
        throw new Error("Expect args to be an array");
      }
      var keys2 = [];
      var i, keyStart, keyStop, parseExternalKey;
      switch (commandName) {
        case "zunionstore":
        case "zinterstore":
          keys2.push(0);
        case "eval":
        case "evalsha":
          keyStop = Number(args[1]) + 2;
          for (i = 2; i < keyStop; i++) {
            keys2.push(i);
          }
          break;
        case "sort":
          parseExternalKey = options && options.parseExternalKey;
          keys2.push(0);
          for (i = 1; i < args.length - 1; i++) {
            if (typeof args[i] !== "string") {
              continue;
            }
            var directive = args[i].toUpperCase();
            if (directive === "GET") {
              i += 1;
              if (args[i] !== "#") {
                if (parseExternalKey) {
                  keys2.push([i, getExternalKeyNameLength(args[i])]);
                } else {
                  keys2.push(i);
                }
              }
            } else if (directive === "BY") {
              i += 1;
              if (parseExternalKey) {
                keys2.push([i, getExternalKeyNameLength(args[i])]);
              } else {
                keys2.push(i);
              }
            } else if (directive === "STORE") {
              i += 1;
              keys2.push(i);
            }
          }
          break;
        case "migrate":
          if (args[2] === "") {
            for (i = 5; i < args.length - 1; i++) {
              if (args[i].toUpperCase() === "KEYS") {
                for (var j = i + 1; j < args.length; j++) {
                  keys2.push(j);
                }
                break;
              }
            }
          } else {
            keys2.push(2);
          }
          break;
        case "xreadgroup":
        case "xread":
          for (i = commandName === "xread" ? 0 : 3; i < args.length - 1; i++) {
            if (String(args[i]).toUpperCase() === "STREAMS") {
              for (j = i + 1; j <= i + (args.length - 1 - i) / 2; j++) {
                keys2.push(j);
              }
              break;
            }
          }
          break;
        default:
          if (command2.step > 0) {
            keyStart = command2.keyStart - 1;
            keyStop = command2.keyStop > 0 ? command2.keyStop : args.length + command2.keyStop + 1;
            for (i = keyStart; i < keyStop; i += command2.step) {
              keys2.push(i);
            }
          }
          break;
      }
      return keys2;
    };
    function getExternalKeyNameLength(key) {
      if (typeof key !== "string") {
        key = String(key);
      }
      var hashPos = key.indexOf("->");
      return hashPos === -1 ? key.length : hashPos;
    }
  }
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS({
  "node_modules/cluster-key-slot/lib/index.js"(exports2, module2) {
    var lookup = [
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ];
    var toUTF8Array = function toUTF8Array2(str) {
      var char;
      var i = 0;
      var p = 0;
      var utf8 = [];
      var len = str.length;
      for (; i < len; i++) {
        char = str.charCodeAt(i);
        if (char < 128) {
          utf8[p++] = char;
        } else if (char < 2048) {
          utf8[p++] = char >> 6 | 192;
          utf8[p++] = char & 63 | 128;
        } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
          char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          utf8[p++] = char >> 18 | 240;
          utf8[p++] = char >> 12 & 63 | 128;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        } else {
          utf8[p++] = char >> 12 | 224;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        }
      }
      return utf8;
    };
    var generate = module2.exports = function generate2(str) {
      var char;
      var i = 0;
      var start = -1;
      var result = 0;
      var resultHash = 0;
      var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
      var len = utf8.length;
      while (i < len) {
        char = utf8[i++];
        if (start === -1) {
          if (char === 123) {
            start = i;
          }
        } else if (char !== 125) {
          resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
        } else if (i - 1 !== start) {
          return resultHash & 16383;
        }
        result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
      }
      return result & 16383;
    };
    module2.exports.generateMulti = function generateMulti(keys2) {
      var i = 1;
      var len = keys2.length;
      var base = generate(keys2[0]);
      while (i < len) {
        if (generate(keys2[i++]) !== base)
          return -1;
      }
      return base;
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save2;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save2(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var {formatters} = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save2;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_3, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const {namespace: name, useColors: useColors2} = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save2(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var {formatters} = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/ioredis/built/utils/debug.js
var require_debug = __commonJS({
  "node_modules/ioredis/built/utils/debug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var debug_1 = require_src();
    var MAX_ARGUMENT_LENGTH = 200;
    exports2.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
    var NAMESPACE_PREFIX = "ioredis";
    function getStringValue(v) {
      if (v === null) {
        return;
      }
      switch (typeof v) {
        case "boolean":
          return;
        case "number":
          return;
        case "object":
          if (Buffer.isBuffer(v)) {
            return v.toString("hex");
          }
          if (Array.isArray(v)) {
            return v.join(",");
          }
          try {
            return JSON.stringify(v);
          } catch (e) {
            return;
          }
        case "string":
          return v;
      }
    }
    exports2.getStringValue = getStringValue;
    function genRedactedString(str, maxLen) {
      const {length} = str;
      return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
    }
    exports2.genRedactedString = genRedactedString;
    function genDebugFunction(namespace) {
      const fn = debug_1.default(`${NAMESPACE_PREFIX}:${namespace}`);
      function wrappedDebug(...args) {
        if (!fn.enabled) {
          return;
        }
        for (let i = 1; i < args.length; i++) {
          const str = getStringValue(args[i]);
          if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
            args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
          }
        }
        return fn.apply(null, args);
      }
      Object.defineProperties(wrappedDebug, {
        namespace: {
          get() {
            return fn.namespace;
          }
        },
        enabled: {
          get() {
            return fn.enabled;
          }
        },
        destroy: {
          get() {
            return fn.destroy;
          }
        },
        log: {
          get() {
            return fn.log;
          },
          set(l) {
            fn.log = l;
          }
        }
      });
      return wrappedDebug;
    }
    exports2.default = genDebugFunction;
  }
});

// node_modules/ioredis/built/utils/index.js
var require_utils = __commonJS({
  "node_modules/ioredis/built/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var url_1 = require("url");
    var lodash_1 = require_lodash3();
    exports2.defaults = lodash_1.defaults;
    exports2.noop = lodash_1.noop;
    exports2.flatten = lodash_1.flatten;
    var debug_1 = require_debug();
    exports2.Debug = debug_1.default;
    function bufferEqual(a, b) {
      if (typeof a.equals === "function") {
        return a.equals(b);
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.bufferEqual = bufferEqual;
    function convertBufferToString(value, encoding) {
      if (value instanceof Buffer) {
        return value.toString(encoding);
      }
      if (Array.isArray(value)) {
        const length = value.length;
        const res = Array(length);
        for (let i = 0; i < length; ++i) {
          res[i] = value[i] instanceof Buffer && encoding === "utf8" ? value[i].toString() : convertBufferToString(value[i], encoding);
        }
        return res;
      }
      return value;
    }
    exports2.convertBufferToString = convertBufferToString;
    function wrapMultiResult(arr) {
      if (!arr) {
        return null;
      }
      const result = [];
      const length = arr.length;
      for (let i = 0; i < length; ++i) {
        const item = arr[i];
        if (item instanceof Error) {
          result.push([item]);
        } else {
          result.push([null, item]);
        }
      }
      return result;
    }
    exports2.wrapMultiResult = wrapMultiResult;
    function isInt(value) {
      const x = parseFloat(value);
      return !isNaN(value) && (x | 0) === x;
    }
    exports2.isInt = isInt;
    function packObject(array) {
      const result = {};
      const length = array.length;
      for (let i = 1; i < length; i += 2) {
        result[array[i - 1]] = array[i];
      }
      return result;
    }
    exports2.packObject = packObject;
    function timeout(callback, timeout2) {
      let timer;
      const run = function() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
          callback.apply(this, arguments);
        }
      };
      timer = setTimeout(run, timeout2, new Error("timeout"));
      return run;
    }
    exports2.timeout = timeout;
    function convertObjectToArray(obj) {
      const result = [];
      const keys2 = Object.keys(obj);
      for (let i = 0, l = keys2.length; i < l; i++) {
        result.push(keys2[i], obj[keys2[i]]);
      }
      return result;
    }
    exports2.convertObjectToArray = convertObjectToArray;
    function convertMapToArray(map) {
      const result = [];
      let pos = 0;
      map.forEach(function(value, key) {
        result[pos] = key;
        result[pos + 1] = value;
        pos += 2;
      });
      return result;
    }
    exports2.convertMapToArray = convertMapToArray;
    function toArg(arg) {
      if (arg === null || typeof arg === "undefined") {
        return "";
      }
      return String(arg);
    }
    exports2.toArg = toArg;
    function optimizeErrorStack(error, friendlyStack, filterPath) {
      const stacks = friendlyStack.split("\n");
      let lines = "";
      let i;
      for (i = 1; i < stacks.length; ++i) {
        if (stacks[i].indexOf(filterPath) === -1) {
          break;
        }
      }
      for (let j = i; j < stacks.length; ++j) {
        lines += "\n" + stacks[j];
      }
      const pos = error.stack.indexOf("\n");
      error.stack = error.stack.slice(0, pos) + lines;
      return error;
    }
    exports2.optimizeErrorStack = optimizeErrorStack;
    function parseURL(url) {
      if (isInt(url)) {
        return {port: url};
      }
      let parsed = url_1.parse(url, true, true);
      if (!parsed.slashes && url[0] !== "/") {
        url = "//" + url;
        parsed = url_1.parse(url, true, true);
      }
      const options = parsed.query || {};
      const allowUsernameInURI = options.allowUsernameInURI && options.allowUsernameInURI !== "false";
      delete options.allowUsernameInURI;
      const result = {};
      if (parsed.auth) {
        const index = parsed.auth.indexOf(":");
        if (allowUsernameInURI) {
          result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
        }
        result.password = index === -1 ? "" : parsed.auth.slice(index + 1);
      }
      if (parsed.pathname) {
        if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
          if (parsed.pathname.length > 1) {
            result.db = parsed.pathname.slice(1);
          }
        } else {
          result.path = parsed.pathname;
        }
      }
      if (parsed.host) {
        result.host = parsed.hostname;
      }
      if (parsed.port) {
        result.port = parsed.port;
      }
      lodash_1.defaults(result, options);
      return result;
    }
    exports2.parseURL = parseURL;
    function sample(array, from = 0) {
      const length = array.length;
      if (from >= length) {
        return;
      }
      return array[from + Math.floor(Math.random() * (length - from))];
    }
    exports2.sample = sample;
    function shuffle2(array) {
      let counter = array.length;
      while (counter > 0) {
        const index = Math.floor(Math.random() * counter);
        counter--;
        [array[counter], array[index]] = [array[index], array[counter]];
      }
      return array;
    }
    exports2.shuffle = shuffle2;
    exports2.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
    function zipMap(keys2, values2) {
      const map = new Map();
      keys2.forEach((key, index) => {
        map.set(key, values2[index]);
      });
      return map;
    }
    exports2.zipMap = zipMap;
  }
});

// node_modules/ioredis/built/promiseContainer.js
var require_promiseContainer = __commonJS({
  "node_modules/ioredis/built/promiseContainer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
    exports2.isPromise = isPromise;
    var promise2 = Promise;
    function get2() {
      return promise2;
    }
    exports2.get = get2;
    function set2(lib) {
      if (typeof lib !== "function") {
        throw new Error(`Provided Promise must be a function, got ${lib}`);
      }
      promise2 = lib;
    }
    exports2.set = set2;
  }
});

// node_modules/ioredis/built/command.js
var require_command = __commonJS({
  "node_modules/ioredis/built/command.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var commands = require_redis_commands();
    var calculateSlot = require_lib();
    var standard_as_callback_1 = require("standard-as-callback");
    var utils_1 = require_utils();
    var lodash_1 = require_lodash3();
    var promiseContainer_1 = require_promiseContainer();
    var Command2 = class {
      constructor(name, args = [], options = {}, callback) {
        this.name = name;
        this.transformed = false;
        this.isCustomCommand = false;
        this.inTransaction = false;
        this.isResolved = false;
        this.replyEncoding = options.replyEncoding;
        this.errorStack = options.errorStack;
        this.args = lodash_1.flatten(args);
        this.callback = callback;
        this.initPromise();
        if (options.keyPrefix) {
          this._iterateKeys((key) => options.keyPrefix + key);
        }
        if (options.readOnly) {
          this.isReadOnly = true;
        }
      }
      static getFlagMap() {
        if (!this.flagMap) {
          this.flagMap = Object.keys(Command2.FLAGS).reduce((map, flagName) => {
            map[flagName] = {};
            Command2.FLAGS[flagName].forEach((commandName) => {
              map[flagName][commandName] = true;
            });
            return map;
          }, {});
        }
        return this.flagMap;
      }
      static checkFlag(flagName, commandName) {
        return !!this.getFlagMap()[flagName][commandName];
      }
      static setArgumentTransformer(name, func) {
        this._transformer.argument[name] = func;
      }
      static setReplyTransformer(name, func) {
        this._transformer.reply[name] = func;
      }
      initPromise() {
        const Promise2 = promiseContainer_1.get();
        const promise2 = new Promise2((resolve, reject) => {
          if (!this.transformed) {
            this.transformed = true;
            const transformer = Command2._transformer.argument[this.name];
            if (transformer) {
              this.args = transformer(this.args);
            }
            this.stringifyArguments();
          }
          this.resolve = this._convertValue(resolve);
          if (this.errorStack) {
            this.reject = (err) => {
              reject(utils_1.optimizeErrorStack(err, this.errorStack, __dirname));
            };
          } else {
            this.reject = reject;
          }
        });
        this.promise = standard_as_callback_1.default(promise2, this.callback);
      }
      getSlot() {
        if (typeof this.slot === "undefined") {
          const key = this.getKeys()[0];
          this.slot = key == null ? null : calculateSlot(key);
        }
        return this.slot;
      }
      getKeys() {
        return this._iterateKeys();
      }
      _iterateKeys(transform = (key) => key) {
        if (typeof this.keys === "undefined") {
          this.keys = [];
          if (commands.exists(this.name)) {
            const keyIndexes = commands.getKeyIndexes(this.name, this.args);
            for (const index of keyIndexes) {
              this.args[index] = transform(this.args[index]);
              this.keys.push(this.args[index]);
            }
          }
        }
        return this.keys;
      }
      toWritable() {
        let bufferMode = false;
        for (const arg of this.args) {
          if (arg instanceof Buffer) {
            bufferMode = true;
            break;
          }
        }
        let result;
        const commandStr = "*" + (this.args.length + 1) + "\r\n$" + Buffer.byteLength(this.name) + "\r\n" + this.name + "\r\n";
        if (bufferMode) {
          const buffers = new MixedBuffers();
          buffers.push(commandStr);
          for (const arg of this.args) {
            if (arg instanceof Buffer) {
              if (arg.length === 0) {
                buffers.push("$0\r\n\r\n");
              } else {
                buffers.push("$" + arg.length + "\r\n");
                buffers.push(arg);
                buffers.push("\r\n");
              }
            } else {
              buffers.push("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
            }
          }
          result = buffers.toBuffer();
        } else {
          result = commandStr;
          for (const arg of this.args) {
            result += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
          }
        }
        return result;
      }
      stringifyArguments() {
        for (let i = 0; i < this.args.length; ++i) {
          const arg = this.args[i];
          if (!(arg instanceof Buffer) && typeof arg !== "string") {
            this.args[i] = utils_1.toArg(arg);
          }
        }
      }
      _convertValue(resolve) {
        return (value) => {
          try {
            const existingTimer = this._commandTimeoutTimer;
            if (existingTimer) {
              clearTimeout(existingTimer);
              delete this._commandTimeoutTimer;
            }
            resolve(this.transformReply(value));
            this.isResolved = true;
          } catch (err) {
            this.reject(err);
          }
          return this.promise;
        };
      }
      transformReply(result) {
        if (this.replyEncoding) {
          result = utils_1.convertBufferToString(result, this.replyEncoding);
        }
        const transformer = Command2._transformer.reply[this.name];
        if (transformer) {
          result = transformer(result);
        }
        return result;
      }
      setTimeout(ms) {
        if (!this._commandTimeoutTimer) {
          this._commandTimeoutTimer = setTimeout(() => {
            if (!this.isResolved) {
              this.reject(new Error("Command timed out"));
            }
          }, ms);
        }
      }
    };
    exports2.default = Command2;
    Command2.FLAGS = {
      VALID_IN_SUBSCRIBER_MODE: [
        "subscribe",
        "psubscribe",
        "unsubscribe",
        "punsubscribe",
        "ping",
        "quit"
      ],
      VALID_IN_MONITOR_MODE: ["monitor", "auth"],
      ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe"],
      EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe"],
      WILL_DISCONNECT: ["quit"]
    };
    Command2._transformer = {
      argument: {},
      reply: {}
    };
    var msetArgumentTransformer = function(args) {
      if (args.length === 1) {
        if (typeof Map !== "undefined" && args[0] instanceof Map) {
          return utils_1.convertMapToArray(args[0]);
        }
        if (typeof args[0] === "object" && args[0] !== null) {
          return utils_1.convertObjectToArray(args[0]);
        }
      }
      return args;
    };
    var hsetArgumentTransformer = function(args) {
      if (args.length === 2) {
        if (typeof Map !== "undefined" && args[1] instanceof Map) {
          return [args[0]].concat(utils_1.convertMapToArray(args[1]));
        }
        if (typeof args[1] === "object" && args[1] !== null) {
          return [args[0]].concat(utils_1.convertObjectToArray(args[1]));
        }
      }
      return args;
    };
    Command2.setArgumentTransformer("mset", msetArgumentTransformer);
    Command2.setArgumentTransformer("msetnx", msetArgumentTransformer);
    Command2.setArgumentTransformer("hset", hsetArgumentTransformer);
    Command2.setArgumentTransformer("hmset", hsetArgumentTransformer);
    Command2.setReplyTransformer("hgetall", function(result) {
      if (Array.isArray(result)) {
        const obj = {};
        for (let i = 0; i < result.length; i += 2) {
          obj[result[i]] = result[i + 1];
        }
        return obj;
      }
      return result;
    });
    var MixedBuffers = class {
      constructor() {
        this.length = 0;
        this.items = [];
      }
      push(x) {
        this.length += Buffer.byteLength(x);
        this.items.push(x);
      }
      toBuffer() {
        const result = Buffer.allocUnsafe(this.length);
        let offset = 0;
        for (const item of this.items) {
          const length = Buffer.byteLength(item);
          Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);
          offset += length;
        }
        return result;
      }
    };
  }
});

// node_modules/ioredis/built/script.js
var require_script = __commonJS({
  "node_modules/ioredis/built/script.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var crypto_1 = require("crypto");
    var promiseContainer_1 = require_promiseContainer();
    var command_1 = require_command();
    var standard_as_callback_1 = require("standard-as-callback");
    var Script = class {
      constructor(lua3, numberOfKeys = null, keyPrefix = "", readOnly = false) {
        this.lua = lua3;
        this.numberOfKeys = numberOfKeys;
        this.keyPrefix = keyPrefix;
        this.readOnly = readOnly;
        this.sha = crypto_1.createHash("sha1").update(lua3).digest("hex");
      }
      execute(container, args, options, callback) {
        if (typeof this.numberOfKeys === "number") {
          args.unshift(this.numberOfKeys);
        }
        if (this.keyPrefix) {
          options.keyPrefix = this.keyPrefix;
        }
        if (this.readOnly) {
          options.readOnly = true;
        }
        const evalsha2 = new command_1.default("evalsha", [this.sha].concat(args), options);
        evalsha2.isCustomCommand = true;
        const result = container.sendCommand(evalsha2);
        if (promiseContainer_1.isPromise(result)) {
          return standard_as_callback_1.default(result.catch((err) => {
            if (err.toString().indexOf("NOSCRIPT") === -1) {
              throw err;
            }
            return container.sendCommand(new command_1.default("eval", [this.lua].concat(args), options));
          }), callback);
        }
        standard_as_callback_1.default(evalsha2.promise, callback);
        return result;
      }
    };
    exports2.default = Script;
  }
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS({
  "node_modules/ioredis/built/autoPipelining.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var PromiseContainer = require_promiseContainer();
    var calculateSlot = require_lib();
    var standard_as_callback_1 = require("standard-as-callback");
    exports2.kExec = Symbol("exec");
    exports2.kCallbacks = Symbol("callbacks");
    exports2.notAllowedAutoPipelineCommands = [
      "auth",
      "info",
      "script",
      "quit",
      "cluster",
      "pipeline",
      "multi",
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "unpsubscribe"
    ];
    function findAutoPipeline(client, _commandName, ...args) {
      if (!client.isCluster) {
        return "main";
      }
      return client.slots[calculateSlot(args[0])].join(",");
    }
    function executeAutoPipeline(client, slotKey) {
      if (client._runningAutoPipelines.has(slotKey)) {
        return;
      }
      client._runningAutoPipelines.add(slotKey);
      const pipeline = client._autoPipelines.get(slotKey);
      client._autoPipelines.delete(slotKey);
      const callbacks = pipeline[exports2.kCallbacks];
      pipeline.exec(function(err, results) {
        client._runningAutoPipelines.delete(slotKey);
        if (err) {
          for (let i = 0; i < callbacks.length; i++) {
            process.nextTick(callbacks[i], err);
          }
        } else {
          for (let i = 0; i < callbacks.length; i++) {
            process.nextTick(callbacks[i], ...results[i]);
          }
        }
        if (client._autoPipelines.has(slotKey)) {
          executeAutoPipeline(client, slotKey);
        }
      });
    }
    function shouldUseAutoPipelining(client, commandName) {
      return client.options.enableAutoPipelining && !client.isPipeline && !exports2.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);
    }
    exports2.shouldUseAutoPipelining = shouldUseAutoPipelining;
    function executeWithAutoPipelining(client, commandName, args, callback) {
      const CustomPromise = PromiseContainer.get();
      if (client.isCluster && !client.slots.length) {
        return new CustomPromise(function(resolve, reject) {
          client.delayUntilReady((err) => {
            if (err) {
              reject(err);
              return;
            }
            executeWithAutoPipelining(client, commandName, args, callback).then(resolve, reject);
          });
        });
      }
      const slotKey = findAutoPipeline(client, commandName, ...args);
      if (!client._autoPipelines.has(slotKey)) {
        const pipeline2 = client.pipeline();
        pipeline2[exports2.kExec] = false;
        pipeline2[exports2.kCallbacks] = [];
        client._autoPipelines.set(slotKey, pipeline2);
      }
      const pipeline = client._autoPipelines.get(slotKey);
      if (!pipeline[exports2.kExec]) {
        pipeline[exports2.kExec] = true;
        setImmediate(executeAutoPipeline, client, slotKey);
      }
      const autoPipelinePromise = new CustomPromise(function(resolve, reject) {
        pipeline[exports2.kCallbacks].push(function(err, value) {
          if (err) {
            reject(err);
            return;
          }
          resolve(value);
        });
        pipeline[commandName](...args);
      });
      return standard_as_callback_1.default(autoPipelinePromise, callback);
    }
    exports2.executeWithAutoPipelining = executeWithAutoPipelining;
  }
});

// node_modules/ioredis/built/commander.js
var require_commander = __commonJS({
  "node_modules/ioredis/built/commander.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var lodash_1 = require_lodash3();
    var command_1 = require_command();
    var script_1 = require_script();
    var PromiseContainer = require_promiseContainer();
    var standard_as_callback_1 = require("standard-as-callback");
    var autoPipelining_1 = require_autoPipelining();
    var DROP_BUFFER_SUPPORT_ERROR = '*Buffer methods are not available because "dropBufferSupport" option is enabled.Refer to https://github.com/luin/ioredis/wiki/Improve-Performance for more details.';
    function Commander() {
      this.options = lodash_1.defaults({}, this.options || {}, {
        showFriendlyErrorStack: false
      });
      this.scriptsSet = {};
    }
    exports2.default = Commander;
    var commands = require_redis_commands().list.filter(function(command2) {
      return command2 !== "monitor";
    });
    commands.push("sentinel");
    Commander.prototype.getBuiltinCommands = function() {
      return commands.slice(0);
    };
    Commander.prototype.createBuiltinCommand = function(commandName) {
      return {
        string: generateFunction(commandName, "utf8"),
        buffer: generateFunction(commandName, null)
      };
    };
    commands.forEach(function(commandName) {
      Commander.prototype[commandName] = generateFunction(commandName, "utf8");
      Commander.prototype[commandName + "Buffer"] = generateFunction(commandName, null);
    });
    Commander.prototype.call = generateFunction("utf8");
    Commander.prototype.callBuffer = generateFunction(null);
    Commander.prototype.send_command = Commander.prototype.call;
    Commander.prototype.defineCommand = function(name, definition) {
      const script = new script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);
      this.scriptsSet[name] = script;
      this[name] = generateScriptingFunction(name, script, "utf8");
      this[name + "Buffer"] = generateScriptingFunction(name, script, null);
    };
    Commander.prototype.sendCommand = function() {
    };
    function generateFunction(_commandName, _encoding) {
      if (typeof _encoding === "undefined") {
        _encoding = _commandName;
        _commandName = null;
      }
      return function(...args) {
        const commandName = _commandName || args.shift();
        let callback = args[args.length - 1];
        if (typeof callback === "function") {
          args.pop();
        } else {
          callback = void 0;
        }
        const options = {
          errorStack: this.options.showFriendlyErrorStack ? new Error().stack : void 0,
          keyPrefix: this.options.keyPrefix,
          replyEncoding: _encoding
        };
        if (this.options.dropBufferSupport && !_encoding) {
          return standard_as_callback_1.default(PromiseContainer.get().reject(new Error(DROP_BUFFER_SUPPORT_ERROR)), callback);
        }
        if (!autoPipelining_1.shouldUseAutoPipelining(this, commandName)) {
          return this.sendCommand(new command_1.default(commandName, args, options, callback));
        }
        return autoPipelining_1.executeWithAutoPipelining(this, commandName, args, callback);
      };
    }
    function generateScriptingFunction(name, script, encoding) {
      return function() {
        let length = arguments.length;
        const lastArgIndex = length - 1;
        let callback = arguments[lastArgIndex];
        if (typeof callback !== "function") {
          callback = void 0;
        } else {
          length = lastArgIndex;
        }
        const args = new Array(length);
        for (let i = 0; i < length; i++) {
          args[i] = arguments[i];
        }
        let options;
        if (this.options.dropBufferSupport) {
          if (!encoding) {
            return standard_as_callback_1.default(PromiseContainer.get().reject(new Error(DROP_BUFFER_SUPPORT_ERROR)), callback);
          }
          options = {replyEncoding: null};
        } else {
          options = {replyEncoding: encoding};
        }
        if (this.options.showFriendlyErrorStack) {
          options.errorStack = new Error().stack;
        }
        if (!autoPipelining_1.shouldUseAutoPipelining(this, name)) {
          return script.execute(this, args, options, callback);
        }
        return autoPipelining_1.executeWithAutoPipelining(this, name, args, callback);
      };
    }
  }
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS({
  "node_modules/redis-errors/lib/old.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var util = require("util");
    function RedisError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(RedisError, Error);
    Object.defineProperty(RedisError.prototype, "name", {
      value: "RedisError",
      configurable: true,
      writable: true
    });
    function ParserError(message, buffer, offset) {
      assert(buffer);
      assert.strictEqual(typeof offset, "number");
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer;
    }
    util.inherits(ParserError, RedisError);
    Object.defineProperty(ParserError.prototype, "name", {
      value: "ParserError",
      configurable: true,
      writable: true
    });
    function ReplyError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
    }
    util.inherits(ReplyError, RedisError);
    Object.defineProperty(ReplyError.prototype, "name", {
      value: "ReplyError",
      configurable: true,
      writable: true
    });
    function AbortError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(AbortError, RedisError);
    Object.defineProperty(AbortError.prototype, "name", {
      value: "AbortError",
      configurable: true,
      writable: true
    });
    function InterruptError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(InterruptError, AbortError);
    Object.defineProperty(InterruptError.prototype, "name", {
      value: "InterruptError",
      configurable: true,
      writable: true
    });
    module2.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError,
      InterruptError
    };
  }
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS({
  "node_modules/redis-errors/lib/modern.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var RedisError = class extends Error {
      get name() {
        return this.constructor.name;
      }
    };
    var ParserError = class extends RedisError {
      constructor(message, buffer, offset) {
        assert(buffer);
        assert.strictEqual(typeof offset, "number");
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
        this.offset = offset;
        this.buffer = buffer;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var ReplyError = class extends RedisError {
      constructor(message) {
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var AbortError = class extends RedisError {
      get name() {
        return this.constructor.name;
      }
    };
    var InterruptError = class extends AbortError {
      get name() {
        return this.constructor.name;
      }
    };
    module2.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError,
      InterruptError
    };
  }
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS({
  "node_modules/redis-errors/index.js"(exports2, module2) {
    "use strict";
    var Errors = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
    module2.exports = Errors;
  }
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS({
  "node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var redis_errors_1 = require_redis_errors();
    var MaxRetriesPerRequestError = class extends redis_errors_1.AbortError {
      constructor(maxRetriesPerRequest) {
        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
        super(message);
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
    };
    exports2.default = MaxRetriesPerRequestError;
  }
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS({
  "node_modules/ioredis/built/errors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
    exports2.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
  }
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/redis-parser/lib/parser.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var StringDecoder = require("string_decoder").StringDecoder;
    var decoder = new StringDecoder();
    var errors = require_redis_errors();
    var ReplyError = errors.ReplyError;
    var ParserError = errors.ParserError;
    var bufferPool = Buffer2.allocUnsafe(32 * 1024);
    var bufferOffset = 0;
    var interval = null;
    var counter = 0;
    var notDecreased = 0;
    function parseSimpleNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      var sign = 1;
      if (parser.buffer[offset] === 45) {
        sign = -1;
        offset++;
      }
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return sign * number;
        }
        number = number * 10 + (c1 - 48);
      }
    }
    function parseStringNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      var res = "";
      if (parser.buffer[offset] === 45) {
        res += "-";
        offset++;
      }
      while (offset < length) {
        var c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          if (number !== 0) {
            res += number;
          }
          return res;
        } else if (number > 429496728) {
          res += number * 10 + (c1 - 48);
          number = 0;
        } else if (c1 === 48 && number === 0) {
          res += 0;
        } else {
          number = number * 10 + (c1 - 48);
        }
      }
    }
    function parseSimpleString(parser) {
      const start = parser.offset;
      const buffer = parser.buffer;
      const length = buffer.length - 1;
      var offset = start;
      while (offset < length) {
        if (buffer[offset++] === 13) {
          parser.offset = offset + 1;
          if (parser.optionReturnBuffers === true) {
            return parser.buffer.slice(start, offset - 1);
          }
          return parser.buffer.toString("utf8", start, offset - 1);
        }
      }
    }
    function parseLength(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return number;
        }
        number = number * 10 + (c1 - 48);
      }
    }
    function parseInteger(parser) {
      if (parser.optionStringNumbers === true) {
        return parseStringNumbers(parser);
      }
      return parseSimpleNumbers(parser);
    }
    function parseBulkString(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const offset = parser.offset + length;
      if (offset + 2 > parser.buffer.length) {
        parser.bigStrSize = offset + 2;
        parser.totalChunkSize = parser.buffer.length;
        parser.bufferCache.push(parser.buffer);
        return;
      }
      const start = parser.offset;
      parser.offset = offset + 2;
      if (parser.optionReturnBuffers === true) {
        return parser.buffer.slice(start, offset);
      }
      return parser.buffer.toString("utf8", start, offset);
    }
    function parseError(parser) {
      var string = parseSimpleString(parser);
      if (string !== void 0) {
        if (parser.optionReturnBuffers === true) {
          string = string.toString();
        }
        return new ReplyError(string);
      }
    }
    function handleError(parser, type2) {
      const err = new ParserError("Protocol error, got " + JSON.stringify(String.fromCharCode(type2)) + " as reply type byte", JSON.stringify(parser.buffer), parser.offset);
      parser.buffer = null;
      parser.returnFatalError(err);
    }
    function parseArray(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const responses = new Array(length);
      return parseArrayElements(parser, responses, 0);
    }
    function pushArrayCache(parser, array, pos) {
      parser.arrayCache.push(array);
      parser.arrayPos.push(pos);
    }
    function parseArrayChunks(parser) {
      const tmp = parser.arrayCache.pop();
      var pos = parser.arrayPos.pop();
      if (parser.arrayCache.length) {
        const res = parseArrayChunks(parser);
        if (res === void 0) {
          pushArrayCache(parser, tmp, pos);
          return;
        }
        tmp[pos++] = res;
      }
      return parseArrayElements(parser, tmp, pos);
    }
    function parseArrayElements(parser, responses, i) {
      const bufferLength = parser.buffer.length;
      while (i < responses.length) {
        const offset = parser.offset;
        if (parser.offset >= bufferLength) {
          pushArrayCache(parser, responses, i);
          return;
        }
        const response = parseType(parser, parser.buffer[parser.offset++]);
        if (response === void 0) {
          if (!(parser.arrayCache.length || parser.bufferCache.length)) {
            parser.offset = offset;
          }
          pushArrayCache(parser, responses, i);
          return;
        }
        responses[i] = response;
        i++;
      }
      return responses;
    }
    function parseType(parser, type2) {
      switch (type2) {
        case 36:
          return parseBulkString(parser);
        case 43:
          return parseSimpleString(parser);
        case 42:
          return parseArray(parser);
        case 58:
          return parseInteger(parser);
        case 45:
          return parseError(parser);
        default:
          return handleError(parser, type2);
      }
    }
    function decreaseBufferPool() {
      if (bufferPool.length > 50 * 1024) {
        if (counter === 1 || notDecreased > counter * 2) {
          const minSliceLen = Math.floor(bufferPool.length / 10);
          const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
          bufferOffset = 0;
          bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
        } else {
          notDecreased++;
          counter--;
        }
      } else {
        clearInterval(interval);
        counter = 0;
        notDecreased = 0;
        interval = null;
      }
    }
    function resizeBuffer(length) {
      if (bufferPool.length < length + bufferOffset) {
        const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
        if (bufferOffset > 1024 * 1024 * 111) {
          bufferOffset = 1024 * 1024 * 50;
        }
        bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
        bufferOffset = 0;
        counter++;
        if (interval === null) {
          interval = setInterval(decreaseBufferPool, 50);
        }
      }
    }
    function concatBulkString(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      var res = decoder.write(list[0].slice(oldOffset));
      for (var i = 1; i < chunks - 1; i++) {
        res += decoder.write(list[i]);
      }
      res += decoder.end(list[i].slice(0, offset - 2));
      return res;
    }
    function concatBulkBuffer(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      const length = parser.bigStrSize - oldOffset - 2;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].slice(oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      resizeBuffer(length);
      const start = bufferOffset;
      list[0].copy(bufferPool, start, oldOffset, list[0].length);
      bufferOffset += list[0].length - oldOffset;
      for (var i = 1; i < chunks - 1; i++) {
        list[i].copy(bufferPool, bufferOffset);
        bufferOffset += list[i].length;
      }
      list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
      bufferOffset += offset - 2;
      return bufferPool.slice(start, bufferOffset);
    }
    var JavascriptRedisParser = class {
      constructor(options) {
        if (!options) {
          throw new TypeError("Options are mandatory.");
        }
        if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
          throw new TypeError("The returnReply and returnError options have to be functions.");
        }
        this.setReturnBuffers(!!options.returnBuffers);
        this.setStringNumbers(!!options.stringNumbers);
        this.returnError = options.returnError;
        this.returnFatalError = options.returnFatalError || options.returnError;
        this.returnReply = options.returnReply;
        this.reset();
      }
      reset() {
        this.offset = 0;
        this.buffer = null;
        this.bigStrSize = 0;
        this.totalChunkSize = 0;
        this.bufferCache = [];
        this.arrayCache = [];
        this.arrayPos = [];
      }
      setReturnBuffers(returnBuffers) {
        if (typeof returnBuffers !== "boolean") {
          throw new TypeError("The returnBuffers argument has to be a boolean");
        }
        this.optionReturnBuffers = returnBuffers;
      }
      setStringNumbers(stringNumbers) {
        if (typeof stringNumbers !== "boolean") {
          throw new TypeError("The stringNumbers argument has to be a boolean");
        }
        this.optionStringNumbers = stringNumbers;
      }
      execute(buffer) {
        if (this.buffer === null) {
          this.buffer = buffer;
          this.offset = 0;
        } else if (this.bigStrSize === 0) {
          const oldLength = this.buffer.length;
          const remainingLength = oldLength - this.offset;
          const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer.length);
          this.buffer.copy(newBuffer, 0, this.offset, oldLength);
          buffer.copy(newBuffer, remainingLength, 0, buffer.length);
          this.buffer = newBuffer;
          this.offset = 0;
          if (this.arrayCache.length) {
            const arr = parseArrayChunks(this);
            if (arr === void 0) {
              return;
            }
            this.returnReply(arr);
          }
        } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {
          this.bufferCache.push(buffer);
          var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
          this.bigStrSize = 0;
          this.bufferCache = [];
          this.buffer = buffer;
          if (this.arrayCache.length) {
            this.arrayCache[0][this.arrayPos[0]++] = tmp;
            tmp = parseArrayChunks(this);
            if (tmp === void 0) {
              return;
            }
          }
          this.returnReply(tmp);
        } else {
          this.bufferCache.push(buffer);
          this.totalChunkSize += buffer.length;
          return;
        }
        while (this.offset < this.buffer.length) {
          const offset = this.offset;
          const type2 = this.buffer[this.offset++];
          const response = parseType(this, type2);
          if (response === void 0) {
            if (!(this.arrayCache.length || this.bufferCache.length)) {
              this.offset = offset;
            }
            return;
          }
          if (type2 === 45) {
            this.returnError(response);
          } else {
            this.returnReply(response);
          }
        }
        this.buffer = null;
      }
    };
    module2.exports = JavascriptRedisParser;
  }
});

// node_modules/redis-parser/index.js
var require_redis_parser = __commonJS({
  "node_modules/redis-parser/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_parser();
  }
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS({
  "node_modules/ioredis/built/SubscriptionSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var SubscriptionSet = class {
      constructor() {
        this.set = {
          subscribe: {},
          psubscribe: {}
        };
      }
      add(set2, channel) {
        this.set[mapSet(set2)][channel] = true;
      }
      del(set2, channel) {
        delete this.set[mapSet(set2)][channel];
      }
      channels(set2) {
        return Object.keys(this.set[mapSet(set2)]);
      }
      isEmpty() {
        return this.channels("subscribe").length === 0 && this.channels("psubscribe").length === 0;
      }
    };
    exports2.default = SubscriptionSet;
    function mapSet(set2) {
      if (set2 === "unsubscribe") {
        return "subscribe";
      }
      if (set2 === "punsubscribe") {
        return "psubscribe";
      }
      return set2;
    }
  }
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS({
  "node_modules/ioredis/built/DataHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var command_1 = require_command();
    var utils_1 = require_utils();
    var RedisParser = require_redis_parser();
    var SubscriptionSet_1 = require_SubscriptionSet();
    var debug = utils_1.Debug("dataHandler");
    var DataHandler = class {
      constructor(redis, parserOptions) {
        this.redis = redis;
        const parser = new RedisParser({
          stringNumbers: parserOptions.stringNumbers,
          returnBuffers: !parserOptions.dropBufferSupport,
          returnError: (err) => {
            this.returnError(err);
          },
          returnFatalError: (err) => {
            this.returnFatalError(err);
          },
          returnReply: (reply) => {
            this.returnReply(reply);
          }
        });
        redis.stream.on("data", (data) => {
          parser.execute(data);
        });
      }
      returnFatalError(err) {
        err.message += ". Please report this.";
        this.redis.recoverFromFatalError(err, err, {offlineQueue: false});
      }
      returnError(err) {
        const item = this.shiftCommand(err);
        if (!item) {
          return;
        }
        err.command = {
          name: item.command.name,
          args: item.command.args
        };
        this.redis.handleReconnection(err, item);
      }
      returnReply(reply) {
        if (this.handleMonitorReply(reply)) {
          return;
        }
        if (this.handleSubscriberReply(reply)) {
          return;
        }
        const item = this.shiftCommand(reply);
        if (!item) {
          return;
        }
        if (command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
          this.redis.condition.subscriber = new SubscriptionSet_1.default();
          this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
          if (!fillSubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
        } else if (command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
          if (!fillUnsubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
        } else {
          item.command.resolve(reply);
        }
      }
      handleSubscriberReply(reply) {
        if (!this.redis.condition.subscriber) {
          return false;
        }
        const replyType = Array.isArray(reply) ? reply[0].toString() : null;
        debug('receive reply "%s" in subscriber mode', replyType);
        switch (replyType) {
          case "message":
            if (this.redis.listeners("message").length > 0) {
              this.redis.emit("message", reply[1].toString(), reply[2].toString());
            }
            this.redis.emit("messageBuffer", reply[1], reply[2]);
            break;
          case "pmessage": {
            const pattern2 = reply[1].toString();
            if (this.redis.listeners("pmessage").length > 0) {
              this.redis.emit("pmessage", pattern2, reply[2].toString(), reply[3].toString());
            }
            this.redis.emit("pmessageBuffer", pattern2, reply[2], reply[3]);
            break;
          }
          case "subscribe":
          case "psubscribe": {
            const channel = reply[1].toString();
            this.redis.condition.subscriber.add(replyType, channel);
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            if (!fillSubCommand(item.command, reply[2])) {
              this.redis.commandQueue.unshift(item);
            }
            break;
          }
          case "unsubscribe":
          case "punsubscribe": {
            const channel = reply[1] ? reply[1].toString() : null;
            if (channel) {
              this.redis.condition.subscriber.del(replyType, channel);
            }
            const count = reply[2];
            if (count === 0) {
              this.redis.condition.subscriber = false;
            }
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            if (!fillUnsubCommand(item.command, count)) {
              this.redis.commandQueue.unshift(item);
            }
            break;
          }
          default: {
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            item.command.resolve(reply);
          }
        }
        return true;
      }
      handleMonitorReply(reply) {
        if (this.redis.status !== "monitoring") {
          return false;
        }
        const replyStr = reply.toString();
        if (replyStr === "OK") {
          return false;
        }
        const len = replyStr.indexOf(" ");
        const timestamp = replyStr.slice(0, len);
        const argindex = replyStr.indexOf('"');
        const args = replyStr.slice(argindex + 1, -1).split('" "').map((elem) => elem.replace(/\\"/g, '"'));
        const dbAndSource = replyStr.slice(len + 2, argindex - 2).split(" ");
        this.redis.emit("monitor", timestamp, args, dbAndSource[1], dbAndSource[0]);
        return true;
      }
      shiftCommand(reply) {
        const item = this.redis.commandQueue.shift();
        if (!item) {
          const message = "Command queue state error. If you can reproduce this, please report it.";
          const error = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));
          this.redis.emit("error", error);
          return null;
        }
        return item;
      }
    };
    exports2.default = DataHandler;
    function fillSubCommand(command2, count) {
      if (typeof command2.remainReplies === "undefined") {
        command2.remainReplies = command2.args.length;
      }
      if (--command2.remainReplies === 0) {
        command2.resolve(count);
        return true;
      }
      return false;
    }
    function fillUnsubCommand(command2, count) {
      if (typeof command2.remainReplies === "undefined") {
        command2.remainReplies = command2.args.length;
      }
      if (command2.remainReplies === 0) {
        if (count === 0) {
          command2.resolve(count);
          return true;
        }
        return false;
      }
      if (--command2.remainReplies === 0) {
        command2.resolve(count);
        return true;
      }
      return false;
    }
  }
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS({
  "node_modules/ioredis/built/redis/event_handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var redis_errors_1 = require_redis_errors();
    var command_1 = require_command();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    var DataHandler_1 = require_DataHandler();
    var debug = utils_1.Debug("connection");
    function connectHandler(self2) {
      return function() {
        self2.setStatus("connect");
        self2.resetCommandQueue();
        let flushed = false;
        const {connectionEpoch} = self2;
        if (self2.condition.auth) {
          self2.auth(self2.condition.auth, function(err) {
            if (connectionEpoch !== self2.connectionEpoch) {
              return;
            }
            if (err) {
              if (err.message.indexOf("no password is set") !== -1) {
                console.warn("[WARN] Redis server does not require a password, but a password was supplied.");
              } else if (err.message.indexOf("without any password configured for the default user") !== -1) {
                console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied");
              } else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
                console.warn(`[ERROR] The server returned "wrong number of arguments for 'auth' command". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);
              } else {
                flushed = true;
                self2.recoverFromFatalError(err, err);
              }
            }
          });
        }
        if (self2.condition.select) {
          self2.select(self2.condition.select).catch((err) => {
            self2.silentEmit("error", err);
          });
        }
        if (!self2.options.enableReadyCheck) {
          exports2.readyHandler(self2)();
        }
        new DataHandler_1.default(self2, {
          stringNumbers: self2.options.stringNumbers,
          dropBufferSupport: self2.options.dropBufferSupport
        });
        if (self2.options.enableReadyCheck) {
          self2._readyCheck(function(err, info2) {
            if (connectionEpoch !== self2.connectionEpoch) {
              return;
            }
            if (err) {
              if (!flushed) {
                self2.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
              }
            } else {
              self2.serverInfo = info2;
              if (self2.connector.check(info2)) {
                exports2.readyHandler(self2)();
              } else {
                self2.disconnect(true);
              }
            }
          });
        }
      };
    }
    exports2.connectHandler = connectHandler;
    function abortError(command2) {
      const err = new redis_errors_1.AbortError("Command aborted due to connection close");
      err.command = {
        name: command2.name,
        args: command2.args
      };
      return err;
    }
    function abortIncompletePipelines(commandQueue) {
      let expectedIndex = 0;
      for (let i = 0; i < commandQueue.length; ) {
        const command2 = commandQueue.peekAt(i).command;
        const pipelineIndex = command2.pipelineIndex;
        if (pipelineIndex === void 0 || pipelineIndex === 0) {
          expectedIndex = 0;
        }
        if (pipelineIndex !== void 0 && pipelineIndex !== expectedIndex++) {
          commandQueue.remove(i, 1);
          command2.reject(abortError(command2));
          continue;
        }
        i++;
      }
    }
    function abortTransactionFragments(commandQueue) {
      for (let i = 0; i < commandQueue.length; ) {
        const command2 = commandQueue.peekAt(i).command;
        if (command2.name === "multi") {
          break;
        }
        if (command2.name === "exec") {
          commandQueue.remove(i, 1);
          command2.reject(abortError(command2));
          break;
        }
        if (command2.inTransaction) {
          commandQueue.remove(i, 1);
          command2.reject(abortError(command2));
        } else {
          i++;
        }
      }
    }
    function closeHandler(self2) {
      return function() {
        self2.setStatus("close");
        if (!self2.prevCondition) {
          self2.prevCondition = self2.condition;
        }
        if (self2.commandQueue.length) {
          abortIncompletePipelines(self2.commandQueue);
          self2.prevCommandQueue = self2.commandQueue;
        }
        if (self2.offlineQueue.length) {
          abortTransactionFragments(self2.offlineQueue);
        }
        if (self2.manuallyClosing) {
          self2.manuallyClosing = false;
          debug("skip reconnecting since the connection is manually closed.");
          return close();
        }
        if (typeof self2.options.retryStrategy !== "function") {
          debug("skip reconnecting because `retryStrategy` is not a function");
          return close();
        }
        const retryDelay = self2.options.retryStrategy(++self2.retryAttempts);
        if (typeof retryDelay !== "number") {
          debug("skip reconnecting because `retryStrategy` doesn't return a number");
          return close();
        }
        debug("reconnect in %sms", retryDelay);
        self2.setStatus("reconnecting", retryDelay);
        self2.reconnectTimeout = setTimeout(function() {
          self2.reconnectTimeout = null;
          self2.connect().catch(utils_1.noop);
        }, retryDelay);
        const {maxRetriesPerRequest} = self2.options;
        if (typeof maxRetriesPerRequest === "number") {
          if (maxRetriesPerRequest < 0) {
            debug("maxRetriesPerRequest is negative, ignoring...");
          } else {
            const remainder = self2.retryAttempts % (maxRetriesPerRequest + 1);
            if (remainder === 0) {
              debug("reach maxRetriesPerRequest limitation, flushing command queue...");
              self2.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
            }
          }
        }
      };
      function close() {
        self2.setStatus("end");
        self2.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
      }
    }
    exports2.closeHandler = closeHandler;
    function errorHandler(self2) {
      return function(error) {
        debug("error: %s", error);
        self2.silentEmit("error", error);
      };
    }
    exports2.errorHandler = errorHandler;
    function readyHandler(self2) {
      return function() {
        self2.setStatus("ready");
        self2.retryAttempts = 0;
        if (self2.options.monitor) {
          self2.call("monitor");
          const {sendCommand} = self2;
          self2.sendCommand = function(command2) {
            if (command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command2.name)) {
              return sendCommand.call(self2, command2);
            }
            command2.reject(new Error("Connection is in monitoring mode, can't process commands."));
            return command2.promise;
          };
          self2.once("close", function() {
            delete self2.sendCommand;
          });
          self2.setStatus("monitoring");
          return;
        }
        const finalSelect = self2.prevCondition ? self2.prevCondition.select : self2.condition.select;
        if (self2.options.connectionName) {
          debug("set the connection name [%s]", self2.options.connectionName);
          self2.client("setname", self2.options.connectionName).catch(utils_1.noop);
        }
        if (self2.options.readOnly) {
          debug("set the connection to readonly mode");
          self2.readonly().catch(utils_1.noop);
        }
        if (self2.prevCondition) {
          const condition = self2.prevCondition;
          self2.prevCondition = null;
          if (condition.subscriber && self2.options.autoResubscribe) {
            if (self2.condition.select !== finalSelect) {
              debug("connect to db [%d]", finalSelect);
              self2.select(finalSelect);
            }
            const subscribeChannels = condition.subscriber.channels("subscribe");
            if (subscribeChannels.length) {
              debug("subscribe %d channels", subscribeChannels.length);
              self2.subscribe(subscribeChannels);
            }
            const psubscribeChannels = condition.subscriber.channels("psubscribe");
            if (psubscribeChannels.length) {
              debug("psubscribe %d channels", psubscribeChannels.length);
              self2.psubscribe(psubscribeChannels);
            }
          }
        }
        if (self2.prevCommandQueue) {
          if (self2.options.autoResendUnfulfilledCommands) {
            debug("resend %d unfulfilled commands", self2.prevCommandQueue.length);
            while (self2.prevCommandQueue.length > 0) {
              const item = self2.prevCommandQueue.shift();
              if (item.select !== self2.condition.select && item.command.name !== "select") {
                self2.select(item.select);
              }
              self2.sendCommand(item.command, item.stream);
            }
          } else {
            self2.prevCommandQueue = null;
          }
        }
        if (self2.offlineQueue.length) {
          debug("send %d commands in offline queue", self2.offlineQueue.length);
          const offlineQueue = self2.offlineQueue;
          self2.resetOfflineQueue();
          while (offlineQueue.length > 0) {
            const item = offlineQueue.shift();
            if (item.select !== self2.condition.select && item.command.name !== "select") {
              self2.select(item.select);
            }
            self2.sendCommand(item.command, item.stream);
          }
        }
        if (self2.condition.select !== finalSelect) {
          debug("connect to db [%d]", finalSelect);
          self2.select(finalSelect);
        }
      };
    }
    exports2.readyHandler = readyHandler;
  }
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS({
  "node_modules/ioredis/built/connectors/AbstractConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils_1 = require_utils();
    var debug = utils_1.Debug("AbstractConnector");
    var AbstractConnector = class {
      constructor(disconnectTimeout) {
        this.connecting = false;
        this.disconnectTimeout = disconnectTimeout;
      }
      check(info2) {
        return true;
      }
      disconnect() {
        this.connecting = false;
        if (this.stream) {
          const stream = this.stream;
          const timeout = setTimeout(() => {
            debug("stream %s:%s still open, destroying it", stream.remoteAddress, stream.remotePort);
            stream.destroy();
          }, this.disconnectTimeout);
          stream.on("close", () => clearTimeout(timeout));
          stream.end();
        }
      }
    };
    exports2.default = AbstractConnector;
  }
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS({
  "node_modules/ioredis/built/connectors/StandaloneConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var net_1 = require("net");
    var tls_1 = require("tls");
    var utils_1 = require_utils();
    var AbstractConnector_1 = require_AbstractConnector();
    function isIIpcConnectionOptions(value) {
      return value.path;
    }
    exports2.isIIpcConnectionOptions = isIIpcConnectionOptions;
    var StandaloneConnector = class extends AbstractConnector_1.default {
      constructor(options) {
        super(options.disconnectTimeout);
        this.options = options;
      }
      connect(_3) {
        const {options} = this;
        this.connecting = true;
        let connectionOptions;
        if (isIIpcConnectionOptions(options)) {
          connectionOptions = {
            path: options.path
          };
        } else {
          connectionOptions = {};
          if (options.port != null) {
            connectionOptions.port = options.port;
          }
          if (options.host != null) {
            connectionOptions.host = options.host;
          }
          if (options.family != null) {
            connectionOptions.family = options.family;
          }
        }
        if (options.tls) {
          Object.assign(connectionOptions, options.tls);
        }
        return new Promise((resolve, reject) => {
          process.nextTick(() => {
            if (!this.connecting) {
              reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
              return;
            }
            try {
              if (options.tls) {
                this.stream = tls_1.connect(connectionOptions);
              } else {
                this.stream = net_1.createConnection(connectionOptions);
              }
            } catch (err) {
              reject(err);
              return;
            }
            this.stream.once("error", (err) => {
              this.firstError = err;
            });
            resolve(this.stream);
          });
        });
      }
    };
    exports2.default = StandaloneConnector;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function isSentinelEql(a, b) {
      return (a.host || "127.0.0.1") === (b.host || "127.0.0.1") && (a.port || 26379) === (b.port || 26379);
    }
    var SentinelIterator = class {
      constructor(sentinels) {
        this.cursor = 0;
        this.sentinels = sentinels.slice(0);
      }
      next() {
        const done = this.cursor >= this.sentinels.length;
        return {done, value: done ? void 0 : this.sentinels[this.cursor++]};
      }
      reset(moveCurrentEndpointToFirst) {
        if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
          this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
        }
        this.cursor = 0;
      }
      add(sentinel) {
        for (let i = 0; i < this.sentinels.length; i++) {
          if (isSentinelEql(sentinel, this.sentinels[i])) {
            return false;
          }
        }
        this.sentinels.push(sentinel);
        return true;
      }
      toString() {
        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
      }
    };
    exports2.default = SentinelIterator;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils_1 = require_utils();
    var debug = utils_1.Debug("FailoverDetector");
    var CHANNEL_NAME = "+switch-master";
    var FailoverDetector = class {
      constructor(connector, sentinels) {
        this.isDisconnected = false;
        this.connector = connector;
        this.sentinels = sentinels;
      }
      cleanup() {
        this.isDisconnected = true;
        for (const sentinel of this.sentinels) {
          sentinel.client.disconnect();
        }
      }
      subscribe() {
        return __awaiter(this, void 0, void 0, function* () {
          debug("Starting FailoverDetector");
          const promises = [];
          for (const sentinel of this.sentinels) {
            const promise2 = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
              debug("Failed to subscribe to failover messages on sentinel %s:%s (%s)", sentinel.address.host || "127.0.0.1", sentinel.address.port || 26739, err.message);
            });
            promises.push(promise2);
            sentinel.client.on("message", (channel) => {
              if (!this.isDisconnected && channel === CHANNEL_NAME) {
                this.disconnect();
              }
            });
          }
          yield Promise.all(promises);
        });
      }
      disconnect() {
        this.isDisconnected = true;
        debug("Failover detected, disconnecting");
        this.connector.disconnect();
      }
    };
    exports2.FailoverDetector = FailoverDetector;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/index.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var net_1 = require("net");
    var utils_1 = require_utils();
    var tls_1 = require("tls");
    var StandaloneConnector_1 = require_StandaloneConnector();
    var SentinelIterator_1 = require_SentinelIterator();
    exports2.SentinelIterator = SentinelIterator_1.default;
    var AbstractConnector_1 = require_AbstractConnector();
    var redis_1 = require_redis();
    var FailoverDetector_1 = require_FailoverDetector();
    var debug = utils_1.Debug("SentinelConnector");
    var SentinelConnector = class extends AbstractConnector_1.default {
      constructor(options) {
        super(options.disconnectTimeout);
        this.options = options;
        this.failoverDetector = null;
        this.emitter = null;
        if (!this.options.sentinels.length) {
          throw new Error("Requires at least one sentinel to connect to.");
        }
        if (!this.options.name) {
          throw new Error("Requires the name of master.");
        }
        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
      }
      check(info2) {
        const roleMatches = !info2.role || this.options.role === info2.role;
        if (!roleMatches) {
          debug("role invalid, expected %s, but got %s", this.options.role, info2.role);
          this.sentinelIterator.next();
          this.sentinelIterator.next();
          this.sentinelIterator.reset(true);
        }
        return roleMatches;
      }
      disconnect() {
        super.disconnect();
        if (this.failoverDetector) {
          this.failoverDetector.cleanup();
        }
      }
      connect(eventEmitter) {
        this.connecting = true;
        this.retryAttempts = 0;
        let lastError;
        const connectToNext = () => __awaiter(this, void 0, void 0, function* () {
          const endpoint = this.sentinelIterator.next();
          if (endpoint.done) {
            this.sentinelIterator.reset(false);
            const retryDelay = typeof this.options.sentinelRetryStrategy === "function" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;
            let errorMsg = typeof retryDelay !== "number" ? "All sentinels are unreachable and retry is disabled." : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
            if (lastError) {
              errorMsg += ` Last error: ${lastError.message}`;
            }
            debug(errorMsg);
            const error = new Error(errorMsg);
            if (typeof retryDelay === "number") {
              eventEmitter("error", error);
              yield new Promise((resolve) => setTimeout(resolve, retryDelay));
              return connectToNext();
            } else {
              throw error;
            }
          }
          let resolved = null;
          let err = null;
          try {
            resolved = yield this.resolve(endpoint.value);
          } catch (error) {
            err = error;
          }
          if (!this.connecting) {
            throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
          }
          const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
          if (resolved) {
            debug("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
            if (this.options.enableTLSForSentinelMode && this.options.tls) {
              Object.assign(resolved, this.options.tls);
              this.stream = tls_1.connect(resolved);
            } else {
              this.stream = net_1.createConnection(resolved);
            }
            this.stream.once("connect", () => this.initFailoverDetector());
            this.stream.once("error", (err2) => {
              this.firstError = err2;
            });
            return this.stream;
          } else {
            const errorMsg = err ? "failed to connect to sentinel " + endpointAddress + " because " + err.message : "connected to sentinel " + endpointAddress + " successfully, but got an invalid reply: " + resolved;
            debug(errorMsg);
            eventEmitter("sentinelError", new Error(errorMsg));
            if (err) {
              lastError = err;
            }
            return connectToNext();
          }
        });
        return connectToNext();
      }
      updateSentinels(client) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.options.updateSentinels) {
            return;
          }
          const result = yield client.sentinel("sentinels", this.options.name);
          if (!Array.isArray(result)) {
            return;
          }
          result.map(utils_1.packObject).forEach((sentinel) => {
            const flags = sentinel.flags ? sentinel.flags.split(",") : [];
            if (flags.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
              const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
              if (this.sentinelIterator.add(endpoint)) {
                debug("adding sentinel %s:%s", endpoint.host, endpoint.port);
              }
            }
          });
          debug("Updated internal sentinels: %s", this.sentinelIterator);
        });
      }
      resolveMaster(client) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield client.sentinel("get-master-addr-by-name", this.options.name);
          yield this.updateSentinels(client);
          return this.sentinelNatResolve(Array.isArray(result) ? {host: result[0], port: Number(result[1])} : null);
        });
      }
      resolveSlave(client) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield client.sentinel("slaves", this.options.name);
          if (!Array.isArray(result)) {
            return null;
          }
          const availableSlaves = result.map(utils_1.packObject).filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
          return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));
        });
      }
      sentinelNatResolve(item) {
        if (!item || !this.options.natMap)
          return item;
        return this.options.natMap[`${item.host}:${item.port}`] || item;
      }
      connectToSentinel(endpoint, options) {
        return new redis_1.default(Object.assign({port: endpoint.port || 26379, host: endpoint.host, username: this.options.sentinelUsername || null, password: this.options.sentinelPassword || null, family: endpoint.family || (StandaloneConnector_1.isIIpcConnectionOptions(this.options) ? void 0 : this.options.family), tls: this.options.sentinelTLS, retryStrategy: null, enableReadyCheck: false, connectTimeout: this.options.connectTimeout, commandTimeout: this.options.sentinelCommandTimeout, dropBufferSupport: true}, options));
      }
      resolve(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
          const client = this.connectToSentinel(endpoint);
          client.on("error", noop);
          try {
            if (this.options.role === "slave") {
              return yield this.resolveSlave(client);
            } else {
              return yield this.resolveMaster(client);
            }
          } finally {
            client.disconnect();
          }
        });
      }
      initFailoverDetector() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          this.sentinelIterator.reset(true);
          const sentinels = [];
          while (sentinels.length < this.options.sentinelMaxConnections) {
            const {done, value} = this.sentinelIterator.next();
            if (done) {
              break;
            }
            const client = this.connectToSentinel(value, {
              lazyConnect: true,
              retryStrategy: this.options.sentinelReconnectStrategy
            });
            client.on("reconnecting", () => {
              var _a2;
              (_a2 = this.emitter) === null || _a2 === void 0 ? void 0 : _a2.emit("sentinelReconnecting");
            });
            sentinels.push({address: value, client});
          }
          this.sentinelIterator.reset(false);
          if (this.failoverDetector) {
            this.failoverDetector.cleanup();
          }
          this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
          yield this.failoverDetector.subscribe();
          (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit("failoverSubscribed");
        });
      }
    };
    exports2.default = SentinelConnector;
    function selectPreferredSentinel(availableSlaves, preferredSlaves) {
      if (availableSlaves.length === 0) {
        return null;
      }
      let selectedSlave;
      if (typeof preferredSlaves === "function") {
        selectedSlave = preferredSlaves(availableSlaves);
      } else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
        const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];
        preferredSlavesArray.sort((a, b) => {
          if (!a.prio) {
            a.prio = 1;
          }
          if (!b.prio) {
            b.prio = 1;
          }
          if (a.prio < b.prio) {
            return -1;
          }
          if (a.prio > b.prio) {
            return 1;
          }
          return 0;
        });
        for (let p = 0; p < preferredSlavesArray.length; p++) {
          for (let a = 0; a < availableSlaves.length; a++) {
            const slave = availableSlaves[a];
            if (slave.ip === preferredSlavesArray[p].ip) {
              if (slave.port === preferredSlavesArray[p].port) {
                selectedSlave = slave;
                break;
              }
            }
          }
          if (selectedSlave) {
            break;
          }
        }
      }
      if (!selectedSlave) {
        selectedSlave = utils_1.sample(availableSlaves);
      }
      return addressResponseToAddress(selectedSlave);
    }
    function addressResponseToAddress(input) {
      return {host: input.ip, port: Number(input.port)};
    }
    function noop() {
    }
  }
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS({
  "node_modules/ioredis/built/connectors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var StandaloneConnector_1 = require_StandaloneConnector();
    exports2.StandaloneConnector = StandaloneConnector_1.default;
    var SentinelConnector_1 = require_SentinelConnector();
    exports2.SentinelConnector = SentinelConnector_1.default;
  }
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS({
  "node_modules/ioredis/built/ScanStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var ScanStream = class extends stream_1.Readable {
      constructor(opt) {
        super(opt);
        this.opt = opt;
        this._redisCursor = "0";
        this._redisDrained = false;
      }
      _read() {
        if (this._redisDrained) {
          this.push(null);
          return;
        }
        const args = [this._redisCursor];
        if (this.opt.key) {
          args.unshift(this.opt.key);
        }
        if (this.opt.match) {
          args.push("MATCH", this.opt.match);
        }
        if (this.opt.type) {
          args.push("TYPE", this.opt.type);
        }
        if (this.opt.count) {
          args.push("COUNT", String(this.opt.count));
        }
        this.opt.redis[this.opt.command](args, (err, res) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
          if (this._redisCursor === "0") {
            this._redisDrained = true;
          }
          this.push(res[1]);
        });
      }
      close() {
        this._redisDrained = true;
      }
    };
    exports2.default = ScanStream;
  }
});

// node_modules/p-map/index.js
var require_p_map = __commonJS({
  "node_modules/p-map/index.js"(exports2, module2) {
    "use strict";
    var pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {
      options = Object.assign({
        concurrency: Infinity
      }, options);
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      const {concurrency} = options;
      if (!(typeof concurrency === "number" && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const ret = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const i = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            resolve(ret);
          }
          return;
        }
        resolvingCount++;
        Promise.resolve(nextItem.value).then((element) => mapper(element, i)).then((value) => {
          ret[i] = value;
          resolvingCount--;
          next();
        }, (error) => {
          isRejected = true;
          reject(error);
        });
      };
      for (let i = 0; i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
    module2.exports = pMap;
    module2.exports.default = pMap;
  }
});

// node_modules/ioredis/built/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/ioredis/built/pipeline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var command_1 = require_command();
    var util_1 = require("util");
    var standard_as_callback_1 = require("standard-as-callback");
    var redis_commands_1 = require_redis_commands();
    var calculateSlot = require_lib();
    var pMap = require_p_map();
    var PromiseContainer = require_promiseContainer();
    var commander_1 = require_commander();
    function generateMultiWithNodes(redis, keys2) {
      const slot = calculateSlot(keys2[0]);
      const target = redis.slots[slot].join(",");
      for (let i = 1; i < keys2.length; i++) {
        const currentTarget = redis.slots[calculateSlot(keys2[i])].join(",");
        if (currentTarget !== target) {
          return -1;
        }
      }
      return slot;
    }
    function Pipeline2(redis) {
      commander_1.default.call(this);
      this.redis = redis;
      this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
      this.isPipeline = true;
      this.options = redis.options;
      this._queue = [];
      this._result = [];
      this._transactions = 0;
      this._shaToScript = {};
      Object.keys(redis.scriptsSet).forEach((name) => {
        const script = redis.scriptsSet[name];
        this._shaToScript[script.sha] = script;
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      const Promise2 = PromiseContainer.get();
      this.promise = new Promise2((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      const _this = this;
      Object.defineProperty(this, "length", {
        get: function() {
          return _this._queue.length;
        }
      });
    }
    exports2.default = Pipeline2;
    Object.assign(Pipeline2.prototype, commander_1.default.prototype);
    Pipeline2.prototype.fillResult = function(value, position) {
      if (this._queue[position].name === "exec" && Array.isArray(value[1])) {
        const execLength = value[1].length;
        for (let i = 0; i < execLength; i++) {
          if (value[1][i] instanceof Error) {
            continue;
          }
          const cmd = this._queue[position - (execLength - i)];
          try {
            value[1][i] = cmd.transformReply(value[1][i]);
          } catch (err) {
            value[1][i] = err;
          }
        }
      }
      this._result[position] = value;
      if (--this.replyPending) {
        return;
      }
      if (this.isCluster) {
        let retriable = true;
        let commonError;
        for (let i = 0; i < this._result.length; ++i) {
          const error = this._result[i][0];
          const command2 = this._queue[i];
          if (error) {
            if (command2.name === "exec" && error.message === "EXECABORT Transaction discarded because of previous errors.") {
              continue;
            }
            if (!commonError) {
              commonError = {
                name: error.name,
                message: error.message
              };
            } else if (commonError.name !== error.name || commonError.message !== error.message) {
              retriable = false;
              break;
            }
          } else if (!command2.inTransaction) {
            const isReadOnly = redis_commands_1.exists(command2.name) && redis_commands_1.hasFlag(command2.name, "readonly");
            if (!isReadOnly) {
              retriable = false;
              break;
            }
          }
        }
        if (commonError && retriable) {
          const _this = this;
          const errv = commonError.message.split(" ");
          const queue = this._queue;
          let inTransaction = false;
          this._queue = [];
          for (let i = 0; i < queue.length; ++i) {
            if (errv[0] === "ASK" && !inTransaction && queue[i].name !== "asking" && (!queue[i - 1] || queue[i - 1].name !== "asking")) {
              const asking = new command_1.default("asking");
              asking.ignore = true;
              this.sendCommand(asking);
            }
            queue[i].initPromise();
            this.sendCommand(queue[i]);
            inTransaction = queue[i].inTransaction;
          }
          let matched = true;
          if (typeof this.leftRedirections === "undefined") {
            this.leftRedirections = {};
          }
          const exec2 = function() {
            _this.exec();
          };
          this.redis.handleError(commonError, this.leftRedirections, {
            moved: function(slot, key) {
              _this.preferKey = key;
              _this.redis.slots[errv[1]] = [key];
              _this.redis.refreshSlotsCache();
              _this.exec();
            },
            ask: function(slot, key) {
              _this.preferKey = key;
              _this.exec();
            },
            tryagain: exec2,
            clusterDown: exec2,
            connectionClosed: exec2,
            maxRedirections: () => {
              matched = false;
            },
            defaults: () => {
              matched = false;
            }
          });
          if (matched) {
            return;
          }
        }
      }
      let ignoredCount = 0;
      for (let i = 0; i < this._queue.length - ignoredCount; ++i) {
        if (this._queue[i + ignoredCount].ignore) {
          ignoredCount += 1;
        }
        this._result[i] = this._result[i + ignoredCount];
      }
      this.resolve(this._result.slice(0, this._result.length - ignoredCount));
    };
    Pipeline2.prototype.sendCommand = function(command2) {
      if (this._transactions > 0) {
        command2.inTransaction = true;
      }
      const position = this._queue.length;
      command2.pipelineIndex = position;
      command2.promise.then((result) => {
        this.fillResult([null, result], position);
      }).catch((error) => {
        this.fillResult([error], position);
      });
      this._queue.push(command2);
      return this;
    };
    Pipeline2.prototype.addBatch = function(commands) {
      let command2, commandName, args;
      for (let i = 0; i < commands.length; ++i) {
        command2 = commands[i];
        commandName = command2[0];
        args = command2.slice(1);
        this[commandName].apply(this, args);
      }
      return this;
    };
    var multi = Pipeline2.prototype.multi;
    Pipeline2.prototype.multi = function() {
      this._transactions += 1;
      return multi.apply(this, arguments);
    };
    var execBuffer = Pipeline2.prototype.execBuffer;
    var exec = Pipeline2.prototype.exec;
    Pipeline2.prototype.execBuffer = util_1.deprecate(function() {
      if (this._transactions > 0) {
        this._transactions -= 1;
      }
      return execBuffer.apply(this, arguments);
    }, "Pipeline#execBuffer: Use Pipeline#exec instead");
    Pipeline2.prototype.exec = function(callback) {
      if (this.isCluster && !this.redis.slots.length) {
        this.redis.delayUntilReady((err) => {
          if (err) {
            callback(err);
            return;
          }
          this.exec(callback);
        });
        return this.promise;
      }
      if (this._transactions > 0) {
        this._transactions -= 1;
        return (this.options.dropBufferSupport ? exec : execBuffer).apply(this, arguments);
      }
      if (!this.nodeifiedPromise) {
        this.nodeifiedPromise = true;
        standard_as_callback_1.default(this.promise, callback);
      }
      if (!this._queue.length) {
        this.resolve([]);
      }
      let pipelineSlot;
      if (this.isCluster) {
        const sampleKeys = [];
        for (let i = 0; i < this._queue.length; i++) {
          const keys2 = this._queue[i].getKeys();
          if (keys2.length) {
            sampleKeys.push(keys2[0]);
          }
          if (keys2.length && calculateSlot.generateMulti(keys2) < 0) {
            this.reject(new Error("All the keys in a pipeline command should belong to the same slot"));
            return this.promise;
          }
        }
        if (sampleKeys.length) {
          pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
          if (pipelineSlot < 0) {
            this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group"));
            return this.promise;
          }
        } else {
          pipelineSlot = Math.random() * 16384 | 0;
        }
      }
      const scripts = [];
      for (let i = 0; i < this._queue.length; ++i) {
        const item = this._queue[i];
        if (item.name !== "evalsha") {
          continue;
        }
        const script = this._shaToScript[item.args[0]];
        if (!script || this.redis._addedScriptHashes[script.sha] || scripts.includes(script)) {
          continue;
        }
        scripts.push(script);
      }
      const _this = this;
      if (!scripts.length) {
        return execPipeline();
      }
      if (this.isCluster) {
        return pMap(scripts, (script) => _this.redis.script("load", script.lua), {
          concurrency: 10
        }).then(function() {
          for (let i = 0; i < scripts.length; i++) {
            _this.redis._addedScriptHashes[scripts[i].sha] = true;
          }
          return execPipeline();
        });
      }
      return this.redis.script("exists", scripts.map(({sha}) => sha)).then(function(results) {
        const pending = [];
        for (let i = 0; i < results.length; ++i) {
          if (!results[i]) {
            pending.push(scripts[i]);
          }
        }
        const Promise2 = PromiseContainer.get();
        return Promise2.all(pending.map(function(script) {
          return _this.redis.script("load", script.lua);
        }));
      }).then(function() {
        for (let i = 0; i < scripts.length; i++) {
          _this.redis._addedScriptHashes[scripts[i].sha] = true;
        }
        return execPipeline();
      });
      function execPipeline() {
        let data = "";
        let buffers;
        let writePending = _this.replyPending = _this._queue.length;
        let node;
        if (_this.isCluster) {
          node = {
            slot: pipelineSlot,
            redis: _this.redis.connectionPool.nodes.all[_this.preferKey]
          };
        }
        let bufferMode = false;
        const stream = {
          write: function(writable) {
            if (writable instanceof Buffer) {
              bufferMode = true;
            }
            if (bufferMode) {
              if (!buffers) {
                buffers = [];
              }
              if (typeof data === "string") {
                buffers.push(Buffer.from(data, "utf8"));
                data = void 0;
              }
              buffers.push(typeof writable === "string" ? Buffer.from(writable, "utf8") : writable);
            } else {
              data += writable;
            }
            if (!--writePending) {
              let sendData;
              if (buffers) {
                sendData = Buffer.concat(buffers);
              } else {
                sendData = data;
              }
              if (_this.isCluster) {
                node.redis.stream.write(sendData);
              } else {
                _this.redis.stream.write(sendData);
              }
              writePending = _this._queue.length;
              data = "";
              buffers = void 0;
              bufferMode = false;
            }
          }
        };
        for (let i = 0; i < _this._queue.length; ++i) {
          _this.redis.sendCommand(_this._queue[i], stream, node);
        }
        return _this.promise;
      }
    };
  }
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS({
  "node_modules/ioredis/built/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils_1 = require_utils();
    var standard_as_callback_1 = require("standard-as-callback");
    var pipeline_1 = require_pipeline();
    function addTransactionSupport(redis) {
      redis.pipeline = function(commands) {
        const pipeline = new pipeline_1.default(this);
        if (Array.isArray(commands)) {
          pipeline.addBatch(commands);
        }
        return pipeline;
      };
      const {multi} = redis;
      redis.multi = function(commands, options) {
        if (typeof options === "undefined" && !Array.isArray(commands)) {
          options = commands;
          commands = null;
        }
        if (options && options.pipeline === false) {
          return multi.call(this);
        }
        const pipeline = new pipeline_1.default(this);
        pipeline.multi();
        if (Array.isArray(commands)) {
          pipeline.addBatch(commands);
        }
        const exec2 = pipeline.exec;
        pipeline.exec = function(callback) {
          if (this.isCluster && !this.redis.slots.length) {
            return standard_as_callback_1.default(new Promise((resolve, reject) => {
              this.redis.delayUntilReady((err) => {
                if (err) {
                  reject(err);
                  return;
                }
                this.exec(pipeline).then(resolve, reject);
              });
            }), callback);
          }
          if (this._transactions > 0) {
            exec2.call(pipeline);
          }
          if (this.nodeifiedPromise) {
            return exec2.call(pipeline);
          }
          const promise2 = exec2.call(pipeline);
          return standard_as_callback_1.default(promise2.then(function(result) {
            const execResult = result[result.length - 1];
            if (typeof execResult === "undefined") {
              throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");
            }
            if (execResult[0]) {
              execResult[0].previousErrors = [];
              for (let i = 0; i < result.length - 1; ++i) {
                if (result[i][0]) {
                  execResult[0].previousErrors.push(result[i][0]);
                }
              }
              throw execResult[0];
            }
            return utils_1.wrapMultiResult(execResult[1]);
          }), callback);
        };
        const {execBuffer} = pipeline;
        pipeline.execBuffer = function(callback) {
          if (this._transactions > 0) {
            execBuffer.call(pipeline);
          }
          return pipeline.exec(callback);
        };
        return pipeline;
      };
      const {exec} = redis;
      redis.exec = function(callback) {
        return standard_as_callback_1.default(exec.call(this).then(function(results) {
          if (Array.isArray(results)) {
            results = utils_1.wrapMultiResult(results);
          }
          return results;
        }), callback);
      };
    }
    exports2.addTransactionSupport = addTransactionSupport;
  }
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS({
  "node_modules/ioredis/built/redis/RedisOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.DEFAULT_REDIS_OPTIONS = {
      port: 6379,
      host: "localhost",
      family: 4,
      connectTimeout: 1e4,
      disconnectTimeout: 2e3,
      retryStrategy: function(times) {
        return Math.min(times * 50, 2e3);
      },
      keepAlive: 0,
      noDelay: true,
      connectionName: null,
      sentinels: null,
      name: null,
      role: "master",
      sentinelRetryStrategy: function(times) {
        return Math.min(times * 10, 1e3);
      },
      sentinelReconnectStrategy: function() {
        return 6e4;
      },
      natMap: null,
      enableTLSForSentinelMode: false,
      updateSentinels: true,
      username: null,
      password: null,
      db: 0,
      dropBufferSupport: false,
      enableOfflineQueue: true,
      enableReadyCheck: true,
      autoResubscribe: true,
      autoResendUnfulfilledCommands: true,
      lazyConnect: false,
      keyPrefix: "",
      reconnectOnError: null,
      readOnly: false,
      stringNumbers: false,
      maxRetriesPerRequest: 20,
      maxLoadingRetryTime: 1e4,
      enableAutoPipelining: false,
      autoPipeliningIgnoredCommands: [],
      maxScriptsCachingTime: 6e4,
      sentinelMaxConnections: 10
    };
  }
});

// node_modules/ioredis/built/redis/index.js
var require_redis = __commonJS({
  "node_modules/ioredis/built/redis/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var lodash_1 = require_lodash3();
    var util_1 = require("util");
    var events_1 = require("events");
    var Deque = require_denque();
    var command_1 = require_command();
    var commander_1 = require_commander();
    var utils_1 = require_utils();
    var standard_as_callback_1 = require("standard-as-callback");
    var eventHandler = require_event_handler();
    var connectors_1 = require_connectors();
    var ScanStream_1 = require_ScanStream();
    var commands = require_redis_commands();
    var PromiseContainer = require_promiseContainer();
    var transaction_1 = require_transaction();
    var RedisOptions_1 = require_RedisOptions();
    var debug = utils_1.Debug("redis");
    exports2.default = Redis;
    function Redis() {
      if (!(this instanceof Redis)) {
        console.error(new Error("Calling `Redis()` like a function is deprecated. Using `new Redis()` instead.").stack.replace("Error", "Warning"));
        return new Redis(arguments[0], arguments[1], arguments[2]);
      }
      this.parseOptions(arguments[0], arguments[1], arguments[2]);
      events_1.EventEmitter.call(this);
      commander_1.default.call(this);
      this.resetCommandQueue();
      this.resetOfflineQueue();
      this.connectionEpoch = 0;
      if (this.options.Connector) {
        this.connector = new this.options.Connector(this.options);
      } else if (this.options.sentinels) {
        const sentinelConnector = new connectors_1.SentinelConnector(this.options);
        sentinelConnector.emitter = this;
        this.connector = sentinelConnector;
      } else {
        this.connector = new connectors_1.StandaloneConnector(this.options);
      }
      this.retryAttempts = 0;
      this._addedScriptHashes = {};
      this._autoPipelines = new Map();
      this._runningAutoPipelines = new Set();
      Object.defineProperty(this, "autoPipelineQueueSize", {
        get() {
          let queued = 0;
          for (const pipeline of this._autoPipelines.values()) {
            queued += pipeline.length;
          }
          return queued;
        }
      });
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch(lodash_1.noop);
      }
    }
    util_1.inherits(Redis, events_1.EventEmitter);
    Object.assign(Redis.prototype, commander_1.default.prototype);
    Redis.createClient = function(...args) {
      return new Redis(...args);
    };
    Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
    Redis.prototype.resetCommandQueue = function() {
      this.commandQueue = new Deque();
    };
    Redis.prototype.resetOfflineQueue = function() {
      this.offlineQueue = new Deque();
    };
    Redis.prototype.parseOptions = function() {
      this.options = {};
      let isTls = false;
      for (let i = 0; i < arguments.length; ++i) {
        const arg = arguments[i];
        if (arg === null || typeof arg === "undefined") {
          continue;
        }
        if (typeof arg === "object") {
          lodash_1.defaults(this.options, arg);
        } else if (typeof arg === "string") {
          lodash_1.defaults(this.options, utils_1.parseURL(arg));
          if (arg.startsWith("rediss://")) {
            isTls = true;
          }
        } else if (typeof arg === "number") {
          this.options.port = arg;
        } else {
          throw new Error("Invalid argument " + arg);
        }
      }
      if (isTls) {
        lodash_1.defaults(this.options, {tls: true});
      }
      lodash_1.defaults(this.options, Redis.defaultOptions);
      if (typeof this.options.port === "string") {
        this.options.port = parseInt(this.options.port, 10);
      }
      if (typeof this.options.db === "string") {
        this.options.db = parseInt(this.options.db, 10);
      }
      if (this.options.parser === "hiredis") {
        console.warn("Hiredis parser is abandoned since ioredis v3.0, and JavaScript parser will be used");
      }
    };
    Redis.prototype.setStatus = function(status, arg) {
      if (debug.enabled) {
        debug("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status);
      }
      this.status = status;
      process.nextTick(this.emit.bind(this, status, arg));
    };
    Redis.prototype.connect = function(callback) {
      const _Promise = PromiseContainer.get();
      const promise2 = new _Promise((resolve, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = setInterval(() => {
          this._addedScriptHashes = {};
        }, this.options.maxScriptsCachingTime);
        this.connectionEpoch += 1;
        this.setStatus("connecting");
        const {options} = this;
        this.condition = {
          select: options.db,
          auth: options.username ? [options.username, options.password] : options.password,
          subscriber: false
        };
        const _this = this;
        standard_as_callback_1.default(this.connector.connect(function(type2, err) {
          _this.silentEmit(type2, err);
        }), function(err, stream) {
          if (err) {
            _this.flushQueue(err);
            _this.silentEmit("error", err);
            reject(err);
            _this.setStatus("end");
            return;
          }
          let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
          if (options.sentinels && !options.enableTLSForSentinelMode) {
            CONNECT_EVENT = "connect";
          }
          _this.stream = stream;
          if (typeof options.keepAlive === "number") {
            stream.setKeepAlive(true, options.keepAlive);
          }
          if (stream.connecting) {
            stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
            if (options.connectTimeout) {
              let connectTimeoutCleared = false;
              stream.setTimeout(options.connectTimeout, function() {
                if (connectTimeoutCleared) {
                  return;
                }
                stream.setTimeout(0);
                stream.destroy();
                const err2 = new Error("connect ETIMEDOUT");
                err2.errorno = "ETIMEDOUT";
                err2.code = "ETIMEDOUT";
                err2.syscall = "connect";
                eventHandler.errorHandler(_this)(err2);
              });
              stream.once(CONNECT_EVENT, function() {
                connectTimeoutCleared = true;
                stream.setTimeout(0);
              });
            }
          } else if (stream.destroyed) {
            const firstError = _this.connector.firstError;
            if (firstError) {
              process.nextTick(() => {
                eventHandler.errorHandler(_this)(firstError);
              });
            }
            process.nextTick(eventHandler.closeHandler(_this));
          } else {
            process.nextTick(eventHandler.connectHandler(_this));
          }
          if (!stream.destroyed) {
            stream.once("error", eventHandler.errorHandler(_this));
            stream.once("close", eventHandler.closeHandler(_this));
          }
          if (options.noDelay) {
            stream.setNoDelay(true);
          }
          const connectionReadyHandler = function() {
            _this.removeListener("close", connectionCloseHandler);
            resolve();
          };
          var connectionCloseHandler = function() {
            _this.removeListener("ready", connectionReadyHandler);
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
          };
          _this.once("ready", connectionReadyHandler);
          _this.once("close", connectionCloseHandler);
        });
      });
      return standard_as_callback_1.default(promise2, callback);
    };
    Redis.prototype.disconnect = function(reconnect) {
      clearInterval(this._addedScriptHashesCleanInterval);
      this._addedScriptHashesCleanInterval = null;
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      if (this.status === "wait") {
        eventHandler.closeHandler(this)();
      } else {
        this.connector.disconnect();
      }
    };
    Redis.prototype.end = function() {
      this.disconnect();
    };
    Redis.prototype.duplicate = function(override) {
      return new Redis(Object.assign({}, this.options, override || {}));
    };
    Redis.prototype.recoverFromFatalError = function(commandError, err, options) {
      this.flushQueue(err, options);
      this.silentEmit("error", err);
      this.disconnect(true);
    };
    Redis.prototype.handleReconnection = function handleReconnection(err, item) {
      let needReconnect = false;
      if (this.options.reconnectOnError) {
        needReconnect = this.options.reconnectOnError(err);
      }
      switch (needReconnect) {
        case 1:
        case true:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          item.command.reject(err);
          break;
        case 2:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          if (this.condition.select !== item.select && item.command.name !== "select") {
            this.select(item.select);
          }
          this.sendCommand(item.command);
          break;
        default:
          item.command.reject(err);
      }
    };
    Redis.prototype.flushQueue = function(error, options) {
      options = lodash_1.defaults({}, options, {
        offlineQueue: true,
        commandQueue: true
      });
      let item;
      if (options.offlineQueue) {
        while (this.offlineQueue.length > 0) {
          item = this.offlineQueue.shift();
          item.command.reject(error);
        }
      }
      if (options.commandQueue) {
        if (this.commandQueue.length > 0) {
          if (this.stream) {
            this.stream.removeAllListeners("data");
          }
          while (this.commandQueue.length > 0) {
            item = this.commandQueue.shift();
            item.command.reject(error);
          }
        }
      }
    };
    Redis.prototype._readyCheck = function(callback) {
      const _this = this;
      this.info(function(err, res) {
        if (err) {
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback(null, res);
        }
        const info2 = {};
        const lines = res.split("\r\n");
        for (let i = 0; i < lines.length; ++i) {
          const [fieldName, ...fieldValueParts] = lines[i].split(":");
          const fieldValue = fieldValueParts.join(":");
          if (fieldValue) {
            info2[fieldName] = fieldValue;
          }
        }
        if (!info2.loading || info2.loading === "0") {
          callback(null, info2);
        } else {
          const loadingEtaMs = (info2.loading_eta_seconds || 1) * 1e3;
          const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;
          debug("Redis server still loading, trying again in " + retryTime + "ms");
          setTimeout(function() {
            _this._readyCheck(callback);
          }, retryTime);
        }
      });
    };
    Redis.prototype.silentEmit = function(eventName) {
      let error;
      if (eventName === "error") {
        error = arguments[1];
        if (this.status === "end") {
          return;
        }
        if (this.manuallyClosing) {
          if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || error.syscall === "connect" || error.syscall === "read")) {
            return;
          }
        }
      }
      if (this.listeners(eventName).length > 0) {
        return this.emit.apply(this, arguments);
      }
      if (error && error instanceof Error) {
        console.error("[ioredis] Unhandled error event:", error.stack);
      }
      return false;
    };
    Redis.prototype.monitor = function(callback) {
      const monitorInstance = this.duplicate({
        monitor: true,
        lazyConnect: false
      });
      const Promise2 = PromiseContainer.get();
      return standard_as_callback_1.default(new Promise2(function(resolve) {
        monitorInstance.once("monitoring", function() {
          resolve(monitorInstance);
        });
      }), callback);
    };
    transaction_1.addTransactionSupport(Redis.prototype);
    Redis.prototype.sendCommand = function(command2, stream) {
      if (this.status === "wait") {
        this.connect().catch(lodash_1.noop);
      }
      if (this.status === "end") {
        command2.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command2.promise;
      }
      if (this.condition.subscriber && !command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command2.name)) {
        command2.reject(new Error("Connection in subscriber mode, only subscriber commands may be used"));
        return command2.promise;
      }
      if (typeof this.options.commandTimeout === "number") {
        command2.setTimeout(this.options.commandTimeout);
      }
      if (command2.name === "quit") {
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = null;
      }
      let writable = this.status === "ready" || !stream && this.status === "connect" && commands.exists(command2.name) && commands.hasFlag(command2.name, "loading");
      if (!this.stream) {
        writable = false;
      } else if (!this.stream.writable) {
        writable = false;
      } else if (this.stream._writableState && this.stream._writableState.ended) {
        writable = false;
      }
      if (!writable && !this.options.enableOfflineQueue) {
        command2.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false"));
        return command2.promise;
      }
      if (!writable && command2.name === "quit" && this.offlineQueue.length === 0) {
        this.disconnect();
        command2.resolve(Buffer.from("OK"));
        return command2.promise;
      }
      if (writable) {
        if (debug.enabled) {
          debug("write command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command2.name, command2.args);
        }
        (stream || this.stream).write(command2.toWritable());
        this.commandQueue.push({
          command: command2,
          stream,
          select: this.condition.select
        });
        if (command_1.default.checkFlag("WILL_DISCONNECT", command2.name)) {
          this.manuallyClosing = true;
        }
      } else if (this.options.enableOfflineQueue) {
        if (debug.enabled) {
          debug("queue command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command2.name, command2.args);
        }
        this.offlineQueue.push({
          command: command2,
          stream,
          select: this.condition.select
        });
      }
      if (command2.name === "select" && utils_1.isInt(command2.args[0])) {
        const db = parseInt(command2.args[0], 10);
        if (this.condition.select !== db) {
          this.condition.select = db;
          this.emit("select", db);
          debug("switch to db [%d]", this.condition.select);
        }
      }
      return command2.promise;
    };
    Redis.prototype._getDescription = function() {
      let description;
      if (this.options.path) {
        description = this.options.path;
      } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
        description = this.stream.remoteAddress + ":" + this.stream.remotePort;
      } else {
        description = this.options.host + ":" + this.options.port;
      }
      if (this.options.connectionName) {
        description += ` (${this.options.connectionName})`;
      }
      return description;
    };
    [
      "scan",
      "sscan",
      "hscan",
      "zscan",
      "scanBuffer",
      "sscanBuffer",
      "hscanBuffer",
      "zscanBuffer"
    ].forEach(function(command2) {
      Redis.prototype[command2 + "Stream"] = function(key, options) {
        if (command2 === "scan" || command2 === "scanBuffer") {
          options = key;
          key = null;
        }
        return new ScanStream_1.default(lodash_1.defaults({
          objectMode: true,
          key,
          redis: this,
          command: command2
        }, options));
      };
    });
  }
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS({
  "node_modules/ioredis/built/errors/ClusterAllFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var redis_errors_1 = require_redis_errors();
    var ClusterAllFailedError = class extends redis_errors_1.RedisError {
      constructor(message, lastNodeError) {
        super(message);
        this.lastNodeError = lastNodeError;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
    };
    exports2.default = ClusterAllFailedError;
  }
});

// node_modules/ioredis/built/cluster/util.js
var require_util = __commonJS({
  "node_modules/ioredis/built/cluster/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils_1 = require_utils();
    var net_1 = require("net");
    function getNodeKey(node) {
      node.port = node.port || 6379;
      node.host = node.host || "127.0.0.1";
      return node.host + ":" + node.port;
    }
    exports2.getNodeKey = getNodeKey;
    function nodeKeyToRedisOptions(nodeKey) {
      const portIndex = nodeKey.lastIndexOf(":");
      if (portIndex === -1) {
        throw new Error(`Invalid node key ${nodeKey}`);
      }
      return {
        host: nodeKey.slice(0, portIndex),
        port: Number(nodeKey.slice(portIndex + 1))
      };
    }
    exports2.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
    function normalizeNodeOptions(nodes) {
      return nodes.map((node) => {
        const options = {};
        if (typeof node === "object") {
          Object.assign(options, node);
        } else if (typeof node === "string") {
          Object.assign(options, utils_1.parseURL(node));
        } else if (typeof node === "number") {
          options.port = node;
        } else {
          throw new Error("Invalid argument " + node);
        }
        if (typeof options.port === "string") {
          options.port = parseInt(options.port, 10);
        }
        delete options.db;
        if (!options.port) {
          options.port = 6379;
        }
        if (!options.host) {
          options.host = "127.0.0.1";
        }
        return options;
      });
    }
    exports2.normalizeNodeOptions = normalizeNodeOptions;
    function getUniqueHostnamesFromOptions(nodes) {
      const uniqueHostsMap = {};
      nodes.forEach((node) => {
        uniqueHostsMap[node.host] = true;
      });
      return Object.keys(uniqueHostsMap).filter((host) => !net_1.isIP(host));
    }
    exports2.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
    function groupSrvRecords(records) {
      const recordsByPriority = {};
      for (const record of records) {
        if (!recordsByPriority.hasOwnProperty(record.priority)) {
          recordsByPriority[record.priority] = {
            totalWeight: record.weight,
            records: [record]
          };
        } else {
          recordsByPriority[record.priority].totalWeight += record.weight;
          recordsByPriority[record.priority].records.push(record);
        }
      }
      return recordsByPriority;
    }
    exports2.groupSrvRecords = groupSrvRecords;
    function weightSrvRecords(recordsGroup) {
      if (recordsGroup.records.length === 1) {
        recordsGroup.totalWeight = 0;
        return recordsGroup.records.shift();
      }
      const random3 = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));
      let total = 0;
      for (const [i, record] of recordsGroup.records.entries()) {
        total += 1 + record.weight;
        if (total > random3) {
          recordsGroup.totalWeight -= record.weight;
          recordsGroup.records.splice(i, 1);
          return record;
        }
      }
    }
    exports2.weightSrvRecords = weightSrvRecords;
    function getConnectionName(component, nodeConnectionName) {
      const prefix = `ioredis-cluster(${component})`;
      return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
    }
    exports2.getConnectionName = getConnectionName;
  }
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS({
  "node_modules/ioredis/built/cluster/ConnectionPool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var events_1 = require("events");
    var utils_1 = require_utils();
    var util_1 = require_util();
    var redis_1 = require_redis();
    var debug = utils_1.Debug("cluster:connectionPool");
    var ConnectionPool = class extends events_1.EventEmitter {
      constructor(redisOptions) {
        super();
        this.redisOptions = redisOptions;
        this.nodes = {
          all: {},
          master: {},
          slave: {}
        };
        this.specifiedOptions = {};
      }
      getNodes(role2 = "all") {
        const nodes = this.nodes[role2];
        return Object.keys(nodes).map((key) => nodes[key]);
      }
      getInstanceByKey(key) {
        return this.nodes.all[key];
      }
      getSampleInstance(role2) {
        const keys2 = Object.keys(this.nodes[role2]);
        const sampleKey = utils_1.sample(keys2);
        return this.nodes[role2][sampleKey];
      }
      findOrCreate(node, readOnly = false) {
        const key = util_1.getNodeKey(node);
        readOnly = Boolean(readOnly);
        if (this.specifiedOptions[key]) {
          Object.assign(node, this.specifiedOptions[key]);
        } else {
          this.specifiedOptions[key] = node;
        }
        let redis;
        if (this.nodes.all[key]) {
          redis = this.nodes.all[key];
          if (redis.options.readOnly !== readOnly) {
            redis.options.readOnly = readOnly;
            debug("Change role of %s to %s", key, readOnly ? "slave" : "master");
            redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
            if (readOnly) {
              delete this.nodes.master[key];
              this.nodes.slave[key] = redis;
            } else {
              delete this.nodes.slave[key];
              this.nodes.master[key] = redis;
            }
          }
        } else {
          debug("Connecting to %s as %s", key, readOnly ? "slave" : "master");
          redis = new redis_1.default(utils_1.defaults({
            retryStrategy: null,
            enableOfflineQueue: true,
            readOnly
          }, node, this.redisOptions, {lazyConnect: true}));
          this.nodes.all[key] = redis;
          this.nodes[readOnly ? "slave" : "master"][key] = redis;
          redis.once("end", () => {
            this.removeNode(key);
            this.emit("-node", redis, key);
            if (!Object.keys(this.nodes.all).length) {
              this.emit("drain");
            }
          });
          this.emit("+node", redis, key);
          redis.on("error", function(error) {
            this.emit("nodeError", error, key);
          });
        }
        return redis;
      }
      removeNode(key) {
        const {nodes} = this;
        if (nodes.all[key]) {
          debug("Remove %s from the pool", key);
          delete nodes.all[key];
        }
        delete nodes.master[key];
        delete nodes.slave[key];
      }
      reset(nodes) {
        debug("Reset with %O", nodes);
        const newNodes = {};
        nodes.forEach((node) => {
          const key = util_1.getNodeKey(node);
          if (!(node.readOnly && newNodes[key])) {
            newNodes[key] = node;
          }
        });
        Object.keys(this.nodes.all).forEach((key) => {
          if (!newNodes[key]) {
            debug("Disconnect %s because the node does not hold any slot", key);
            this.nodes.all[key].disconnect();
            this.removeNode(key);
          }
        });
        Object.keys(newNodes).forEach((key) => {
          const node = newNodes[key];
          this.findOrCreate(node, node.readOnly);
        });
      }
    };
    exports2.default = ConnectionPool;
  }
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS({
  "node_modules/ioredis/built/cluster/ClusterSubscriber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var util_1 = require_util();
    var utils_1 = require_utils();
    var redis_1 = require_redis();
    var debug = utils_1.Debug("cluster:subscriber");
    var ClusterSubscriber = class {
      constructor(connectionPool, emitter) {
        this.connectionPool = connectionPool;
        this.emitter = emitter;
        this.started = false;
        this.subscriber = null;
        this.connectionPool.on("-node", (_3, key) => {
          if (!this.started || !this.subscriber) {
            return;
          }
          if (util_1.getNodeKey(this.subscriber.options) === key) {
            debug("subscriber has left, selecting a new one...");
            this.selectSubscriber();
          }
        });
        this.connectionPool.on("+node", () => {
          if (!this.started || this.subscriber) {
            return;
          }
          debug("a new node is discovered and there is no subscriber, selecting a new one...");
          this.selectSubscriber();
        });
      }
      getInstance() {
        return this.subscriber;
      }
      selectSubscriber() {
        const lastActiveSubscriber = this.lastActiveSubscriber;
        if (lastActiveSubscriber) {
          lastActiveSubscriber.disconnect();
        }
        if (this.subscriber) {
          this.subscriber.disconnect();
        }
        const sampleNode = utils_1.sample(this.connectionPool.getNodes());
        if (!sampleNode) {
          debug("selecting subscriber failed since there is no node discovered in the cluster yet");
          this.subscriber = null;
          return;
        }
        const {options} = sampleNode;
        debug("selected a subscriber %s:%s", options.host, options.port);
        this.subscriber = new redis_1.default({
          port: options.port,
          host: options.host,
          username: options.username,
          password: options.password,
          enableReadyCheck: true,
          connectionName: util_1.getConnectionName("subscriber", options.connectionName),
          lazyConnect: true,
          tls: options.tls
        });
        this.subscriber.on("error", utils_1.noop);
        const previousChannels = {subscribe: [], psubscribe: []};
        if (lastActiveSubscriber) {
          const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
          if (condition && condition.subscriber) {
            previousChannels.subscribe = condition.subscriber.channels("subscribe");
            previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
          }
        }
        if (previousChannels.subscribe.length || previousChannels.psubscribe.length) {
          let pending = 0;
          for (const type2 of ["subscribe", "psubscribe"]) {
            const channels = previousChannels[type2];
            if (channels.length) {
              pending += 1;
              debug("%s %d channels", type2, channels.length);
              this.subscriber[type2](channels).then(() => {
                if (!--pending) {
                  this.lastActiveSubscriber = this.subscriber;
                }
              }).catch(() => {
                debug("failed to %s %d channels", type2, channels.length);
              });
            }
          }
        } else {
          this.lastActiveSubscriber = this.subscriber;
        }
        for (const event of ["message", "messageBuffer"]) {
          this.subscriber.on(event, (arg1, arg2) => {
            this.emitter.emit(event, arg1, arg2);
          });
        }
        for (const event of ["pmessage", "pmessageBuffer"]) {
          this.subscriber.on(event, (arg1, arg2, arg3) => {
            this.emitter.emit(event, arg1, arg2, arg3);
          });
        }
      }
      start() {
        this.started = true;
        this.selectSubscriber();
        debug("started");
      }
      stop() {
        this.started = false;
        if (this.subscriber) {
          this.subscriber.disconnect();
          this.subscriber = null;
        }
        debug("stopped");
      }
    };
    exports2.default = ClusterSubscriber;
  }
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS({
  "node_modules/ioredis/built/cluster/DelayQueue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils_1 = require_utils();
    var Deque = require_denque();
    var debug = utils_1.Debug("delayqueue");
    var DelayQueue = class {
      constructor() {
        this.queues = {};
        this.timeouts = {};
      }
      push(bucket, item, options) {
        const callback = options.callback || process.nextTick;
        if (!this.queues[bucket]) {
          this.queues[bucket] = new Deque();
        }
        const queue = this.queues[bucket];
        queue.push(item);
        if (!this.timeouts[bucket]) {
          this.timeouts[bucket] = setTimeout(() => {
            callback(() => {
              this.timeouts[bucket] = null;
              this.execute(bucket);
            });
          }, options.timeout);
        }
      }
      execute(bucket) {
        const queue = this.queues[bucket];
        if (!queue) {
          return;
        }
        const {length} = queue;
        if (!length) {
          return;
        }
        debug("send %d commands in %s queue", length, bucket);
        this.queues[bucket] = null;
        while (queue.length > 0) {
          queue.shift()();
        }
      }
    };
    exports2.default = DelayQueue;
  }
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS({
  "node_modules/ioredis/built/cluster/ClusterOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var dns_1 = require("dns");
    exports2.DEFAULT_CLUSTER_OPTIONS = {
      clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2e3),
      enableOfflineQueue: true,
      enableReadyCheck: true,
      scaleReads: "master",
      maxRedirections: 16,
      retryDelayOnMoved: 0,
      retryDelayOnFailover: 100,
      retryDelayOnClusterDown: 100,
      retryDelayOnTryAgain: 100,
      slotsRefreshTimeout: 1e3,
      slotsRefreshInterval: 5e3,
      useSRVRecords: false,
      resolveSrv: dns_1.resolveSrv,
      dnsLookup: dns_1.lookup,
      enableAutoPipelining: false,
      autoPipeliningIgnoredCommands: [],
      maxScriptsCachingTime: 6e4
    };
  }
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS({
  "node_modules/ioredis/built/cluster/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var events_1 = require("events");
    var ClusterAllFailedError_1 = require_ClusterAllFailedError();
    var utils_1 = require_utils();
    var ConnectionPool_1 = require_ConnectionPool();
    var util_1 = require_util();
    var ClusterSubscriber_1 = require_ClusterSubscriber();
    var DelayQueue_1 = require_DelayQueue();
    var ScanStream_1 = require_ScanStream();
    var redis_errors_1 = require_redis_errors();
    var standard_as_callback_1 = require("standard-as-callback");
    var PromiseContainer = require_promiseContainer();
    var ClusterOptions_1 = require_ClusterOptions();
    var utils_2 = require_utils();
    var commands = require_redis_commands();
    var command_1 = require_command();
    var redis_1 = require_redis();
    var commander_1 = require_commander();
    var Deque = require_denque();
    var debug = utils_1.Debug("cluster");
    var Cluster = class extends events_1.EventEmitter {
      constructor(startupNodes, options = {}) {
        super();
        this.slots = [];
        this.retryAttempts = 0;
        this.delayQueue = new DelayQueue_1.default();
        this.offlineQueue = new Deque();
        this.isRefreshing = false;
        this.isCluster = true;
        this._autoPipelines = new Map();
        this._runningAutoPipelines = new Set();
        this._readyDelayedCallbacks = [];
        this._addedScriptHashes = {};
        this.connectionEpoch = 0;
        commander_1.default.call(this);
        this.startupNodes = startupNodes;
        this.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
        if (typeof this.options.scaleReads !== "function" && ["all", "master", "slave"].indexOf(this.options.scaleReads) === -1) {
          throw new Error('Invalid option scaleReads "' + this.options.scaleReads + '". Expected "all", "master", "slave" or a custom function');
        }
        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
        this.connectionPool.on("-node", (redis, key) => {
          this.emit("-node", redis);
        });
        this.connectionPool.on("+node", (redis) => {
          this.emit("+node", redis);
        });
        this.connectionPool.on("drain", () => {
          this.setStatus("close");
        });
        this.connectionPool.on("nodeError", (error, key) => {
          this.emit("node error", error, key);
        });
        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
        if (this.options.lazyConnect) {
          this.setStatus("wait");
        } else {
          this.connect().catch((err) => {
            debug("connecting failed: %s", err);
          });
        }
      }
      resetOfflineQueue() {
        this.offlineQueue = new Deque();
      }
      clearNodesRefreshInterval() {
        if (this.slotsTimer) {
          clearTimeout(this.slotsTimer);
          this.slotsTimer = null;
        }
      }
      resetNodesRefreshInterval() {
        if (this.slotsTimer) {
          return;
        }
        const nextRound = () => {
          this.slotsTimer = setTimeout(() => {
            debug('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
            this.refreshSlotsCache(() => {
              nextRound();
            });
          }, this.options.slotsRefreshInterval);
        };
        nextRound();
      }
      connect() {
        const Promise2 = PromiseContainer.get();
        return new Promise2((resolve, reject) => {
          if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
            reject(new Error("Redis is already connecting/connected"));
            return;
          }
          clearInterval(this._addedScriptHashesCleanInterval);
          this._addedScriptHashesCleanInterval = setInterval(() => {
            this._addedScriptHashes = {};
          }, this.options.maxScriptsCachingTime);
          const epoch = ++this.connectionEpoch;
          this.setStatus("connecting");
          this.resolveStartupNodeHostnames().then((nodes) => {
            if (this.connectionEpoch !== epoch) {
              debug("discard connecting after resolving startup nodes because epoch not match: %d != %d", epoch, this.connectionEpoch);
              reject(new redis_errors_1.RedisError("Connection is discarded because a new connection is made"));
              return;
            }
            if (this.status !== "connecting") {
              debug("discard connecting after resolving startup nodes because the status changed to %s", this.status);
              reject(new redis_errors_1.RedisError("Connection is aborted"));
              return;
            }
            this.connectionPool.reset(nodes);
            function readyHandler() {
              this.setStatus("ready");
              this.retryAttempts = 0;
              this.executeOfflineCommands();
              this.resetNodesRefreshInterval();
              resolve();
            }
            let closeListener = void 0;
            const refreshListener = () => {
              this.invokeReadyDelayedCallbacks(void 0);
              this.removeListener("close", closeListener);
              this.manuallyClosing = false;
              this.setStatus("connect");
              if (this.options.enableReadyCheck) {
                this.readyCheck((err, fail) => {
                  if (err || fail) {
                    debug("Ready check failed (%s). Reconnecting...", err || fail);
                    if (this.status === "connect") {
                      this.disconnect(true);
                    }
                  } else {
                    readyHandler.call(this);
                  }
                });
              } else {
                readyHandler.call(this);
              }
            };
            closeListener = function() {
              const error = new Error("None of startup nodes is available");
              this.removeListener("refresh", refreshListener);
              this.invokeReadyDelayedCallbacks(error);
              reject(error);
            };
            this.once("refresh", refreshListener);
            this.once("close", closeListener);
            this.once("close", this.handleCloseEvent.bind(this));
            this.refreshSlotsCache(function(err) {
              if (err && err.message === "Failed to refresh slots cache.") {
                redis_1.default.prototype.silentEmit.call(this, "error", err);
                this.connectionPool.reset([]);
              }
            }.bind(this));
            this.subscriber.start();
          }).catch((err) => {
            this.setStatus("close");
            this.handleCloseEvent(err);
            this.invokeReadyDelayedCallbacks(err);
            reject(err);
          });
        });
      }
      handleCloseEvent(reason) {
        if (reason) {
          debug("closed because %s", reason);
        }
        let retryDelay;
        if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
          retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
        }
        if (typeof retryDelay === "number") {
          this.setStatus("reconnecting");
          this.reconnectTimeout = setTimeout(function() {
            this.reconnectTimeout = null;
            debug("Cluster is disconnected. Retrying after %dms", retryDelay);
            this.connect().catch(function(err) {
              debug("Got error %s when reconnecting. Ignoring...", err);
            });
          }.bind(this), retryDelay);
        } else {
          this.setStatus("end");
          this.flushQueue(new Error("None of startup nodes is available"));
        }
      }
      disconnect(reconnect = false) {
        const status = this.status;
        this.setStatus("disconnecting");
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = null;
        if (!reconnect) {
          this.manuallyClosing = true;
        }
        if (this.reconnectTimeout && !reconnect) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
          debug("Canceled reconnecting attempts");
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        if (status === "wait") {
          this.setStatus("close");
          this.handleCloseEvent();
        } else {
          this.connectionPool.reset([]);
        }
      }
      quit(callback) {
        const status = this.status;
        this.setStatus("disconnecting");
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = null;
        this.manuallyClosing = true;
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        const Promise2 = PromiseContainer.get();
        if (status === "wait") {
          const ret = standard_as_callback_1.default(Promise2.resolve("OK"), callback);
          setImmediate(function() {
            this.setStatus("close");
            this.handleCloseEvent();
          }.bind(this));
          return ret;
        }
        return standard_as_callback_1.default(Promise2.all(this.nodes().map((node) => node.quit().catch((err) => {
          if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {
            return "OK";
          }
          throw err;
        }))).then(() => "OK"), callback);
      }
      duplicate(overrideStartupNodes = [], overrideOptions = {}) {
        const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
        const options = Object.assign({}, this.options, overrideOptions);
        return new Cluster(startupNodes, options);
      }
      nodes(role2 = "all") {
        if (role2 !== "all" && role2 !== "master" && role2 !== "slave") {
          throw new Error('Invalid role "' + role2 + '". Expected "all", "master" or "slave"');
        }
        return this.connectionPool.getNodes(role2);
      }
      delayUntilReady(callback) {
        this._readyDelayedCallbacks.push(callback);
      }
      get autoPipelineQueueSize() {
        let queued = 0;
        for (const pipeline of this._autoPipelines.values()) {
          queued += pipeline.length;
        }
        return queued;
      }
      setStatus(status) {
        debug("status: %s -> %s", this.status || "[empty]", status);
        this.status = status;
        process.nextTick(() => {
          this.emit(status);
        });
      }
      refreshSlotsCache(callback) {
        if (this.isRefreshing) {
          if (typeof callback === "function") {
            process.nextTick(callback);
          }
          return;
        }
        this.isRefreshing = true;
        const _this = this;
        const wrapper = function(error) {
          _this.isRefreshing = false;
          if (typeof callback === "function") {
            callback(error);
          }
        };
        const nodes = utils_2.shuffle(this.connectionPool.getNodes());
        let lastNodeError = null;
        function tryNode(index) {
          if (index === nodes.length) {
            const error = new ClusterAllFailedError_1.default("Failed to refresh slots cache.", lastNodeError);
            return wrapper(error);
          }
          const node = nodes[index];
          const key = `${node.options.host}:${node.options.port}`;
          debug("getting slot cache from %s", key);
          _this.getInfoFromNode(node, function(err) {
            switch (_this.status) {
              case "close":
              case "end":
                return wrapper(new Error("Cluster is disconnected."));
              case "disconnecting":
                return wrapper(new Error("Cluster is disconnecting."));
            }
            if (err) {
              _this.emit("node error", err, key);
              lastNodeError = err;
              tryNode(index + 1);
            } else {
              _this.emit("refresh");
              wrapper();
            }
          });
        }
        tryNode(0);
      }
      flushQueue(error) {
        let item;
        while (this.offlineQueue.length > 0) {
          item = this.offlineQueue.shift();
          item.command.reject(error);
        }
      }
      executeOfflineCommands() {
        if (this.offlineQueue.length) {
          debug("send %d commands in offline queue", this.offlineQueue.length);
          const offlineQueue = this.offlineQueue;
          this.resetOfflineQueue();
          while (offlineQueue.length > 0) {
            const item = offlineQueue.shift();
            this.sendCommand(item.command, item.stream, item.node);
          }
        }
      }
      natMapper(nodeKey) {
        if (this.options.natMap && typeof this.options.natMap === "object") {
          const key = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
          const mapped = this.options.natMap[key];
          if (mapped) {
            debug("NAT mapping %s -> %O", key, mapped);
            return Object.assign({}, mapped);
          }
        }
        return typeof nodeKey === "string" ? util_1.nodeKeyToRedisOptions(nodeKey) : nodeKey;
      }
      sendCommand(command2, stream, node) {
        if (this.status === "wait") {
          this.connect().catch(utils_1.noop);
        }
        if (this.status === "end") {
          command2.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));
          return command2.promise;
        }
        let to = this.options.scaleReads;
        if (to !== "master") {
          const isCommandReadOnly = command2.isReadOnly || commands.exists(command2.name) && commands.hasFlag(command2.name, "readonly");
          if (!isCommandReadOnly) {
            to = "master";
          }
        }
        let targetSlot = node ? node.slot : command2.getSlot();
        const ttl2 = {};
        const _this = this;
        if (!node && !command2.__is_reject_overwritten) {
          command2.__is_reject_overwritten = true;
          const reject = command2.reject;
          command2.reject = function(err) {
            const partialTry = tryConnection.bind(null, true);
            _this.handleError(err, ttl2, {
              moved: function(slot, key) {
                debug("command %s is moved to %s", command2.name, key);
                targetSlot = Number(slot);
                if (_this.slots[slot]) {
                  _this.slots[slot][0] = key;
                } else {
                  _this.slots[slot] = [key];
                }
                _this.connectionPool.findOrCreate(_this.natMapper(key));
                tryConnection();
                debug("refreshing slot caches... (triggered by MOVED error)");
                _this.refreshSlotsCache();
              },
              ask: function(slot, key) {
                debug("command %s is required to ask %s:%s", command2.name, key);
                const mapped = _this.natMapper(key);
                _this.connectionPool.findOrCreate(mapped);
                tryConnection(false, `${mapped.host}:${mapped.port}`);
              },
              tryagain: partialTry,
              clusterDown: partialTry,
              connectionClosed: partialTry,
              maxRedirections: function(redirectionError) {
                reject.call(command2, redirectionError);
              },
              defaults: function() {
                reject.call(command2, err);
              }
            });
          };
        }
        tryConnection();
        function tryConnection(random3, asking) {
          if (_this.status === "end") {
            command2.reject(new redis_errors_1.AbortError("Cluster is ended."));
            return;
          }
          let redis;
          if (_this.status === "ready" || command2.name === "cluster") {
            if (node && node.redis) {
              redis = node.redis;
            } else if (command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command2.name) || command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command2.name)) {
              redis = _this.subscriber.getInstance();
              if (!redis) {
                command2.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
                return;
              }
            } else {
              if (!random3) {
                if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
                  const nodeKeys = _this.slots[targetSlot];
                  if (typeof to === "function") {
                    const nodes = nodeKeys.map(function(key) {
                      return _this.connectionPool.getInstanceByKey(key);
                    });
                    redis = to(nodes, command2);
                    if (Array.isArray(redis)) {
                      redis = utils_2.sample(redis);
                    }
                    if (!redis) {
                      redis = nodes[0];
                    }
                  } else {
                    let key;
                    if (to === "all") {
                      key = utils_2.sample(nodeKeys);
                    } else if (to === "slave" && nodeKeys.length > 1) {
                      key = utils_2.sample(nodeKeys, 1);
                    } else {
                      key = nodeKeys[0];
                    }
                    redis = _this.connectionPool.getInstanceByKey(key);
                  }
                }
                if (asking) {
                  redis = _this.connectionPool.getInstanceByKey(asking);
                  redis.asking();
                }
              }
              if (!redis) {
                redis = (typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance("all");
              }
            }
            if (node && !node.redis) {
              node.redis = redis;
            }
          }
          if (redis) {
            redis.sendCommand(command2, stream);
          } else if (_this.options.enableOfflineQueue) {
            _this.offlineQueue.push({
              command: command2,
              stream,
              node
            });
          } else {
            command2.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
          }
        }
        return command2.promise;
      }
      handleError(error, ttl2, handlers) {
        if (typeof ttl2.value === "undefined") {
          ttl2.value = this.options.maxRedirections;
        } else {
          ttl2.value -= 1;
        }
        if (ttl2.value <= 0) {
          handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error));
          return;
        }
        const errv = error.message.split(" ");
        if (errv[0] === "MOVED") {
          const timeout = this.options.retryDelayOnMoved;
          if (timeout && typeof timeout === "number") {
            this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), {timeout});
          } else {
            handlers.moved(errv[1], errv[2]);
          }
        } else if (errv[0] === "ASK") {
          handlers.ask(errv[1], errv[2]);
        } else if (errv[0] === "TRYAGAIN") {
          this.delayQueue.push("tryagain", handlers.tryagain, {
            timeout: this.options.retryDelayOnTryAgain
          });
        } else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
          this.delayQueue.push("clusterdown", handlers.connectionClosed, {
            timeout: this.options.retryDelayOnClusterDown,
            callback: this.refreshSlotsCache.bind(this)
          });
        } else if (error.message === utils_2.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === "ready") {
          this.delayQueue.push("failover", handlers.connectionClosed, {
            timeout: this.options.retryDelayOnFailover,
            callback: this.refreshSlotsCache.bind(this)
          });
        } else {
          handlers.defaults();
        }
      }
      getInfoFromNode(redis, callback) {
        if (!redis) {
          return callback(new Error("Node is disconnected"));
        }
        const duplicatedConnection = redis.duplicate({
          enableOfflineQueue: true,
          enableReadyCheck: false,
          retryStrategy: null,
          connectionName: util_1.getConnectionName("refresher", this.options.redisOptions && this.options.redisOptions.connectionName)
        });
        duplicatedConnection.on("error", utils_1.noop);
        duplicatedConnection.cluster("slots", utils_2.timeout((err, result) => {
          duplicatedConnection.disconnect();
          if (err) {
            return callback(err);
          }
          if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
            debug("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s", result.length, this.status);
            callback();
            return;
          }
          const nodes = [];
          debug("cluster slots result count: %d", result.length);
          for (let i = 0; i < result.length; ++i) {
            const items = result[i];
            const slotRangeStart = items[0];
            const slotRangeEnd = items[1];
            const keys2 = [];
            for (let j = 2; j < items.length; j++) {
              if (!items[j][0]) {
                continue;
              }
              items[j] = this.natMapper({host: items[j][0], port: items[j][1]});
              items[j].readOnly = j !== 2;
              nodes.push(items[j]);
              keys2.push(items[j].host + ":" + items[j].port);
            }
            debug("cluster slots result [%d]: slots %d~%d served by %s", i, slotRangeStart, slotRangeEnd, keys2);
            for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {
              this.slots[slot] = keys2;
            }
          }
          this.connectionPool.reset(nodes);
          callback();
        }, this.options.slotsRefreshTimeout));
      }
      invokeReadyDelayedCallbacks(err) {
        for (const c of this._readyDelayedCallbacks) {
          process.nextTick(c, err);
        }
        this._readyDelayedCallbacks = [];
      }
      readyCheck(callback) {
        this.cluster("info", function(err, res) {
          if (err) {
            return callback(err);
          }
          if (typeof res !== "string") {
            return callback();
          }
          let state;
          const lines = res.split("\r\n");
          for (let i = 0; i < lines.length; ++i) {
            const parts = lines[i].split(":");
            if (parts[0] === "cluster_state") {
              state = parts[1];
              break;
            }
          }
          if (state === "fail") {
            debug("cluster state not ok (%s)", state);
            callback(null, state);
          } else {
            callback();
          }
        });
      }
      resolveSrv(hostname) {
        return new Promise((resolve, reject) => {
          this.options.resolveSrv(hostname, (err, records) => {
            if (err) {
              return reject(err);
            }
            const self2 = this, groupedRecords = util_1.groupSrvRecords(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));
            function tryFirstOne(err2) {
              if (!sortedKeys.length) {
                return reject(err2);
              }
              const key = sortedKeys[0], group = groupedRecords[key], record = util_1.weightSrvRecords(group);
              if (!group.records.length) {
                sortedKeys.shift();
              }
              self2.dnsLookup(record.name).then((host) => resolve({
                host,
                port: record.port
              }), tryFirstOne);
            }
            tryFirstOne();
          });
        });
      }
      dnsLookup(hostname) {
        return new Promise((resolve, reject) => {
          this.options.dnsLookup(hostname, (err, address) => {
            if (err) {
              debug("failed to resolve hostname %s to IP: %s", hostname, err.message);
              reject(err);
            } else {
              debug("resolved hostname %s to IP %s", hostname, address);
              resolve(address);
            }
          });
        });
      }
      resolveStartupNodeHostnames() {
        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
          return Promise.reject(new Error("`startupNodes` should contain at least one node."));
        }
        const startupNodes = util_1.normalizeNodeOptions(this.startupNodes);
        const hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);
        if (hostnames.length === 0) {
          return Promise.resolve(startupNodes);
        }
        return Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this))).then((configs) => {
          const hostnameToConfig = utils_2.zipMap(hostnames, configs);
          return startupNodes.map((node) => {
            const config = hostnameToConfig.get(node.host);
            if (!config) {
              return node;
            } else if (this.options.useSRVRecords) {
              return Object.assign({}, node, config);
            } else {
              return Object.assign({}, node, {host: config});
            }
          });
        });
      }
    };
    Object.getOwnPropertyNames(commander_1.default.prototype).forEach((name) => {
      if (!Cluster.prototype.hasOwnProperty(name)) {
        Cluster.prototype[name] = commander_1.default.prototype[name];
      }
    });
    var scanCommands = [
      "sscan",
      "hscan",
      "zscan",
      "sscanBuffer",
      "hscanBuffer",
      "zscanBuffer"
    ];
    scanCommands.forEach((command2) => {
      Cluster.prototype[command2 + "Stream"] = function(key, options) {
        return new ScanStream_1.default(utils_1.defaults({
          objectMode: true,
          key,
          redis: this,
          command: command2
        }, options));
      };
    });
    require_transaction().addTransactionSupport(Cluster.prototype);
    exports2.default = Cluster;
  }
});

// node_modules/ioredis/built/index.js
var require_built = __commonJS({
  "node_modules/ioredis/built/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2 = module2.exports = require_redis().default;
    var redis_1 = require_redis();
    exports2.default = redis_1.default;
    var cluster_1 = require_cluster();
    exports2.Cluster = cluster_1.default;
    var command_1 = require_command();
    exports2.Command = command_1.default;
    var ScanStream_1 = require_ScanStream();
    exports2.ScanStream = ScanStream_1.default;
    var pipeline_1 = require_pipeline();
    exports2.Pipeline = pipeline_1.default;
    var AbstractConnector_1 = require_AbstractConnector();
    exports2.AbstractConnector = AbstractConnector_1.default;
    var SentinelConnector_1 = require_SentinelConnector();
    exports2.SentinelConnector = SentinelConnector_1.default;
    exports2.SentinelIterator = SentinelConnector_1.SentinelIterator;
    exports2.ReplyError = require_redis_errors().ReplyError;
    var PromiseContainer = require_promiseContainer();
    Object.defineProperty(exports2, "Promise", {
      get() {
        return PromiseContainer.get();
      },
      set(lib) {
        PromiseContainer.set(lib);
      }
    });
    function print(err, reply) {
      if (err) {
        console.log("Error: " + err);
      } else {
        console.log("Reply: " + reply);
      }
    }
    exports2.print = print;
  }
});

// src/index.js
var import_events = __toModule(require("events"));
var import_ioredis = __toModule(require_built());
var import_redis_commands = __toModule(require_redis_commands());

// src/commands/index.js
var commands_exports = {};
__export(commands_exports, {
  append: () => append,
  auth: () => auth,
  bgrewriteaof: () => bgrewriteaof,
  bgsave: () => bgsave,
  brpoplpush: () => brpoplpush,
  brpoplpushBuffer: () => brpoplpushBuffer,
  connect: () => connect,
  customCommand: () => customCommand,
  dbsize: () => dbsize,
  decr: () => decr,
  decrby: () => decrby,
  defineArgv: () => defineArgv,
  defineCommand: () => defineCommand,
  defineKeys: () => defineKeys,
  defineRedisObject: () => defineRedisObject,
  del: () => del,
  discard: () => discard,
  echo: () => echo,
  evalsha: () => evalsha,
  evaluate: () => evaluate,
  exists: () => exists,
  expire: () => expire,
  expireat: () => expireat,
  flushall: () => flushall,
  flushdb: () => flushdb,
  get: () => get,
  getBuffer: () => getBuffer,
  getbit: () => getbit,
  getrange: () => getrange,
  getset: () => getset,
  hdel: () => hdel,
  hexists: () => hexists,
  hget: () => hget,
  hgetBuffer: () => hgetBuffer,
  hgetall: () => hgetall,
  hgetallBuffer: () => hgetallBuffer,
  hincrby: () => hincrby,
  hincrbyfloat: () => hincrbyfloat,
  hkeys: () => hkeys,
  hlen: () => hlen,
  hmget: () => hmget,
  hmgetBuffer: () => hmgetBuffer,
  hmset: () => hmset,
  hscan: () => hscan,
  hset: () => hset,
  hsetnx: () => hsetnx,
  hstrlen: () => hstrlen,
  hvals: () => hvals,
  incr: () => incr,
  incrby: () => incrby,
  incrbyfloat: () => incrbyfloat,
  info: () => info,
  keys: () => keys,
  lastsave: () => lastsave,
  lindex: () => lindex,
  linsert: () => linsert,
  llen: () => llen,
  lpop: () => lpop,
  lpopBuffer: () => lpopBuffer,
  lpush: () => lpush,
  lpushx: () => lpushx,
  lrange: () => lrange,
  lrem: () => lrem,
  lset: () => lset,
  ltrim: () => ltrim,
  mget: () => mget,
  mset: () => mset,
  msetnx: () => msetnx,
  persist: () => persist,
  pexpire: () => pexpire,
  pexpireat: () => pexpireat,
  ping: () => ping,
  psetex: () => psetex,
  psubscribe: () => psubscribe,
  pttl: () => pttl,
  publish: () => publish,
  punsubscribe: () => punsubscribe,
  quit: () => quit,
  randomkey: () => randomkey,
  rename: () => rename,
  renamenx: () => renamenx,
  role: () => role,
  rpop: () => rpop,
  rpopBuffer: () => rpopBuffer,
  rpoplpush: () => rpoplpush,
  rpoplpushBuffer: () => rpoplpushBuffer,
  rpush: () => rpush,
  rpushx: () => rpushx,
  sadd: () => sadd,
  save: () => save,
  scan: () => scan,
  scard: () => scard,
  sdiff: () => sdiff,
  sdiffstore: () => sdiffstore,
  set: () => set,
  setbit: () => setbit,
  setex: () => setex,
  setnx: () => setnx,
  sinter: () => sinter,
  sinterstore: () => sinterstore,
  sismember: () => sismember,
  smembers: () => smembers,
  smismember: () => smismember,
  smove: () => smove,
  spop: () => spop,
  srandmember: () => srandmember,
  srem: () => srem,
  sscan: () => sscan,
  strlen: () => strlen,
  subscribe: () => subscribe,
  sunion: () => sunion,
  sunionstore: () => sunionstore,
  time: () => time,
  ttl: () => ttl,
  type: () => type,
  unlink: () => unlink,
  unsubscribe: () => unsubscribe,
  xadd: () => xadd,
  xlen: () => xlen,
  xrange: () => xrange,
  xread: () => xread,
  xrevrange: () => xrevrange,
  zadd: () => zadd,
  zcard: () => zcard,
  zcount: () => zcount,
  zincrby: () => zincrby,
  zinterstore: () => zinterstore,
  zpopmax: () => zpopmax,
  zpopmin: () => zpopmin,
  zrange: () => zrange,
  zrangebyscore: () => zrangebyscore,
  zrank: () => zrank,
  zrem: () => zrem,
  zremrangebyrank: () => zremrangebyrank,
  zremrangebyscore: () => zremrangebyscore,
  zrevrange: () => zrevrange,
  zrevrangebyscore: () => zrevrangebyscore,
  zrevrank: () => zrevrank,
  zscan: () => zscan,
  zscore: () => zscore
});

// src/commands/append.js
function append(key, value) {
  if (!this.data.has(key)) {
    this.data.set(key, "");
  }
  if (value instanceof Buffer) {
    this.data.set(key, Buffer.concat([Buffer.from(this.data.get(key)), value]));
  } else {
    this.data.set(key, this.data.get(key) + value);
  }
  return this.data.get(key).length;
}

// src/commands/auth.js
function auth() {
  return "OK";
}

// src/commands/bgrewriteaof.js
function bgrewriteaof() {
  return "OK";
}

// src/commands/bgsave.js
function bgsave() {
  return "OK";
}

// src/commands/brpoplpush.js
function brpoplpush(source, destination) {
  return this.rpoplpush(source, destination);
}

// src/commands/brpoplpushBuffer.js
function brpoplpushBuffer(source, destination) {
  const valP = brpoplpush.apply(this, [source, destination]);
  return valP.then((val) => val ? Buffer.from(val) : val);
}

// src/commands-utils/emitConnectEvent.js
function emitConnectEvent(redisMock) {
  process.nextTick(() => {
    redisMock.emit("connect");
    redisMock.emit("ready");
  });
}

// src/commands/connect.js
function connect() {
  if (this.connected) {
    throw new Error("Redis is already connecting/connected");
  }
  this.connected = true;
  emitConnectEvent(this);
  return void 0;
}

// src/commands/dbsize.js
function dbsize() {
  return this.data.keys().length;
}

// src/commands/decr.js
function decr(key) {
  if (!this.data.has(key)) {
    this.data.set(key, "0");
  }
  const curVal = Number(this.data.get(key));
  const nextVal = curVal - 1;
  this.data.set(key, nextVal.toString());
  return nextVal;
}

// src/commands/decrby.js
function decrby(key, decrement = 0) {
  if (!this.data.has(key)) {
    this.data.set(key, "0");
  }
  const curVal = Number(this.data.get(key));
  const nextVal = curVal - parseInt(decrement, 10);
  this.data.set(key, nextVal.toString());
  return nextVal;
}

// src/commands/defineCommand.js
var import_fengari2 = __toModule(require("fengari"));
var import_fengari_interop2 = __toModule(require("fengari-interop"));

// src/command.js
var import_lodash = __toModule(require("lodash"));
var import_standard_as_callback = __toModule(require("standard-as-callback"));

// src/promise-container.js
var promise = global.Promise;
var promiseContainer = {
  get: () => promise,
  set: (lib) => {
    if (typeof lib !== "function") {
      throw new Error(`Provided Promise must be a function, got ${lib}`);
    }
    promise = lib;
  }
};
var promise_container_default = promiseContainer;

// src/command.js
function isInSubscriberMode(RedisMock2) {
  if (RedisMock2.channels === void 0) {
    return false;
  }
  return RedisMock2.subscriberMode;
}
function isNotConnected(RedisMock2) {
  if (RedisMock2.connected === void 0) {
    return false;
  }
  return !RedisMock2.connected;
}
function throwIfInSubscriberMode(commandName, RedisMock2) {
  if (isInSubscriberMode(RedisMock2)) {
    const allowedCommands = [
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "punsubscribe",
      "ping",
      "quit",
      "disconnect"
    ];
    if (allowedCommands.indexOf(commandName) > -1) {
    } else {
      throw new Error("Connection in subscriber mode, only subscriber commands may be used");
    }
  }
}
function throwIfNotConnected(commandName, RedisMock2) {
  if (isNotConnected(RedisMock2)) {
    if (commandName !== "connect" && commandName !== "defineCommand") {
      throw new Error("Stream isn't writeable and enableOfflineQueue options is false");
    }
  }
}
function throwIfCommandIsNotAllowed(commandName, RedisMock2) {
  throwIfInSubscriberMode(commandName, RedisMock2);
  throwIfNotConnected(commandName, RedisMock2);
}
var argMapper = (arg) => {
  if (arg === null || arg === void 0)
    return "";
  return arg instanceof Buffer ? arg : arg.toString();
};
function processArguments(args, commandName, RedisMock2) {
  if (commandName === "defineCommand")
    return args;
  let commandArgs = args ? import_lodash.default.flatten(args) : [];
  if (RedisMock2.Command.transformers.argument[commandName]) {
    commandArgs = RedisMock2.Command.transformers.argument[commandName](args);
  }
  commandArgs = commandArgs.map(argMapper);
  return commandArgs;
}
function processReply(result, commandName, RedisMock2) {
  if (RedisMock2.Command.transformers.reply[commandName]) {
    return RedisMock2.Command.transformers.reply[commandName](result);
  }
  return result;
}
function safelyExecuteCommand(commandEmulator, commandName, RedisMock2, ...commandArgs) {
  throwIfCommandIsNotAllowed(commandName, RedisMock2);
  const result = commandEmulator(...commandArgs);
  return processReply(result, commandName, RedisMock2);
}
function command(commandEmulator, commandName, RedisMock2) {
  return (...args) => {
    const lastArgIndex = args.length - 1;
    let callback = args[lastArgIndex];
    if (typeof callback !== "function") {
      callback = void 0;
    } else {
      args.length = lastArgIndex;
    }
    const commandArgs = processArguments(args, commandName, RedisMock2);
    if (commandName === "defineCommand") {
      return safelyExecuteCommand(commandEmulator, commandName, RedisMock2, ...commandArgs);
    }
    const Promise2 = promise_container_default.get();
    return (0, import_standard_as_callback.default)(new Promise2((resolve) => resolve(safelyExecuteCommand(commandEmulator, commandName, RedisMock2, ...commandArgs))), callback);
  };
}

// src/lua.js
var import_fengari = __toModule(require("fengari"));
var import_fengari_interop = __toModule(require("fengari-interop"));
var {
  lua,
  lualib,
  lauxlib,
  to_luastring: toLuaString,
  to_jsstring: toJsString
} = import_fengari.default;
var luaExecString = (L) => (str) => {
  const retCode = lauxlib.luaL_dostring(L, toLuaString(str));
  if (retCode !== 0) {
    const errorMsg = lua.lua_tojsstring(L, -1);
    const message = `Error trying to loading or executing lua code string in VM: ${errorMsg}`;
    throw new Error(message);
  }
};
var getTopLength = (L) => {
  lua.lua_len(L, -1);
  const length = lua.lua_tointeger(L, -1);
  lua.lua_pop(L, 1);
  return length;
};
var typeOf = (L) => (pos) => toJsString(lua.lua_typename(L, lua.lua_type(L, pos)));
var getTopKeys = (L) => {
  if (lua.lua_isnil(L, -1))
    throw new Error("cannot get keys on nil");
  if (!lua.lua_istable(L, -1))
    throw new Error(`non-tables don't have keys! type is "${typeOf(L)(-1)}"`);
  lua.lua_pushnil(L);
  const keys2 = [];
  while (lua.lua_next(L, -2) !== 0) {
    keys2.push(import_fengari_interop.default.tojs(L, -2));
    lua.lua_pop(L, 1);
  }
  return keys2;
};
var isTopArray = (L) => () => {
  try {
    const keys2 = getTopKeys(L);
    return keys2.reverse().every((v, i) => v === i + 1);
  } catch (e) {
    return false;
  }
};
var makeReturnValue = (L) => {
  const isArray2 = isTopArray(L)();
  if (!isArray2) {
    const retVal2 = import_fengari_interop.default.tojs(L, -1);
    if (Array.isArray(retVal2)) {
      return retVal2.slice(1);
    }
    return retVal2;
  }
  const arrayLength = getTopLength(L);
  const table = import_fengari_interop.default.tojs(L, -1);
  const retVal = [];
  if (arrayLength === 0) {
    lua.lua_pop(L, 1);
    return retVal;
  }
  for (let i = 1; i <= arrayLength; i++) {
    import_fengari_interop.default.push(L, table.get(i));
    retVal.push(makeReturnValue(L));
  }
  lua.lua_pop(L, 1);
  return retVal;
};
var popReturnValue = (L) => (topBeforeCall) => {
  const numReturn = lua.lua_gettop(L) - topBeforeCall + 1;
  let ret;
  if (numReturn > 0) {
    ret = makeReturnValue(L);
  }
  lua.lua_settop(L, topBeforeCall);
  return ret;
};
var pushTable = (L) => (obj) => {
  lua.lua_newtable(L);
  const index = lua.lua_gettop(L);
  Object.keys(obj).forEach((fieldName) => {
    import_fengari_interop.default.push(L, fieldName);
    push(L)(obj[fieldName]);
    lua.lua_settable(L, index);
  });
};
var pushArray = (L) => (array) => {
  lua.lua_newtable(L);
  const subTableIndex = lua.lua_gettop(L);
  array.forEach((e, i) => {
    import_fengari_interop.default.push(L, i + 1);
    import_fengari_interop.default.push(L, e);
    lua.lua_settable(L, subTableIndex);
  });
};
var push = (L) => (value) => {
  if (Array.isArray(value)) {
    pushArray(L)(value);
  } else if (value && typeof value === "object" && !Array.isArray(value)) {
    pushTable(L)(value);
  } else {
    import_fengari_interop.default.push(L, value);
  }
};
var defineGlobalArray = (L) => (array, name) => {
  push(L)(array);
  lua.lua_setglobal(L, toLuaString(name));
};
var defineGlobalFunction = (L) => (fn, name) => {
  lua.lua_pushjsfunction(L, fn);
  lua.lua_setglobal(L, toLuaString(name));
};
var extractArgs = (L) => () => {
  const top = lua.lua_gettop(L);
  const args = [];
  let a = -top;
  while (a < 0) {
    args.push(a);
    a += 1;
  }
  return args.map((i) => import_fengari_interop.default.tojs(L, i));
};
var init = () => {
  const L = lauxlib.luaL_newstate();
  lualib.luaL_openlibs(L);
  import_fengari_interop.default.luaopen_js(L);
  return {
    L,
    defineGlobalFunction: defineGlobalFunction(L),
    defineGlobalArray: defineGlobalArray(L),
    luaExecString: luaExecString(L),
    extractArgs: extractArgs(L),
    popReturnValue: popReturnValue(L),
    utils: {
      isTopArray: isTopArray(L),
      push: push(L)
    }
  };
};
var dispose = (vm) => {
  const L = vm.L || vm;
  lua.lua_close(L);
};

// src/commands/defineCommand.js
var {lua: lua2, to_luastring: toLuaString2} = import_fengari2.default;
var defineRedisObject = (vm) => (fn) => {
  vm.defineGlobalFunction(fn, "call");
  vm.luaExecString(`
    local redis = {}
    function repair(val)
      if val == nil then
        return false
      end
      return val
    end
    redis.call = function(...)
        return repair(call(false, ...))
    end
    redis.pcall = function(...)
        return repair(call(true, ...))
    end
    return redis
  `);
  lua2.lua_setglobal(vm.L, toLuaString2("redis"));
};
var callToRedisCommand = (vm) => function callToRedisCommand2() {
  const rawArgs = vm.extractArgs();
  const returnError = rawArgs[0];
  let result;
  try {
    const args = rawArgs.slice(1);
    const name = args[0].toLowerCase();
    const redisCmd = commands_exports[name].bind(this);
    result = redisCmd(...args.slice(1));
  } catch (err) {
    if (!returnError) {
      throw err;
    }
    import_fengari_interop2.default.push(vm.L, ["error", err.toString()]);
    return 1;
  }
  if (!!result || result === 0) {
    if (Array.isArray(result)) {
      result.unshift(null);
      result[Symbol.for("__len")] = function() {
        const arr = this;
        return arr.length - 1;
      };
    }
    import_fengari_interop2.default.push(vm.L, result);
    return 1;
  }
  return 0;
};
function defineKeys(vm, numberOfKeys, commandArgs) {
  const keys2 = commandArgs.slice(0, numberOfKeys);
  vm.defineGlobalArray(keys2, "KEYS");
}
function defineArgv(vm, numberOfKeys, commandArgs) {
  const args = commandArgs.slice(numberOfKeys);
  vm.defineGlobalArray(args, "ARGV");
}
var customCommand = (numberOfKeys, luaCode) => function customCommand2(...luaScriptArgs) {
  const vm = init();
  defineRedisObject(vm)(callToRedisCommand(vm).bind(this));
  defineKeys.bind(this)(vm, numberOfKeys, luaScriptArgs);
  defineArgv.bind(this)(vm, numberOfKeys, luaScriptArgs);
  const topBeforeExecute = lua2.lua_gettop(vm.L);
  vm.luaExecString(luaCode);
  const retVal = vm.popReturnValue(topBeforeExecute);
  dispose(vm);
  return retVal;
};
function defineCommand(command2, {numberOfKeys, lua: luaCode}) {
  const cmd = command(customCommand(numberOfKeys, luaCode).bind(this), command2, this);
  this[command2] = cmd;
  this.customCommands[command2] = cmd;
}

// src/keyspace-notifications.js
var allEventsDisabled = {
  g: false,
  string: false,
  l: false,
  s: false,
  h: false,
  z: false,
  x: false,
  e: false
};
function parseEvents(keyspaceEventsConfigString) {
  const result = Object.assign({}, allEventsDisabled);
  const allEvents = "g$lshzxe";
  const unAliasedString = keyspaceEventsConfigString.replace("A", allEvents);
  result.g = unAliasedString.includes("g");
  result.string = unAliasedString.includes("$");
  result.l = unAliasedString.includes("l");
  result.s = unAliasedString.includes("s");
  result.h = unAliasedString.includes("h");
  result.z = unAliasedString.includes("z");
  result.x = unAliasedString.includes("x");
  result.e = unAliasedString.includes("e");
  return result;
}
function parseKeyspaceEvents(keyspaceEventsConfigString) {
  const keyspaceConfig = {
    K: Object.assign({}, allEventsDisabled),
    E: Object.assign({}, allEventsDisabled)
  };
  const isKeyspace = keyspaceEventsConfigString.includes("K");
  const isKeyevent = keyspaceEventsConfigString.includes("E");
  if (isKeyspace) {
    keyspaceConfig.K = parseEvents(keyspaceEventsConfigString);
  }
  if (isKeyevent) {
    keyspaceConfig.E = parseEvents(keyspaceEventsConfigString);
  }
  return keyspaceConfig;
}
function createChannelString(type2, name) {
  const database = 0;
  const typeString = type2 === "K" ? "keyspace" : "keyevent";
  const channel = `__${typeString}@${database}__:${name}`;
  return channel;
}
function emitNotification(redisMock, notifType, key, event) {
  if (redisMock.keyspaceEvents.K[notifType] === true) {
    redisMock.publish(createChannelString("K", key), event);
  }
  if (redisMock.keyspaceEvents.E[notifType] === true) {
    redisMock.publish(createChannelString("E", event), key);
  }
}

// src/commands/del.js
function del(...keys2) {
  let deleted = 0;
  keys2.forEach((key) => {
    if (this.data.has(key)) {
      deleted++;
      emitNotification(this, "g", key, "del");
    }
    this.data.delete(key);
  });
  return deleted;
}

// src/commands/discard.js
function discard() {
  if (!this.batch) {
    throw new Error("ERR DISCARD without MULTI");
  }
  this.batch = void 0;
  return "OK";
}

// src/commands/echo.js
function echo(message) {
  return message;
}

// src/commands-utils/sha1.js
var import_crypto = __toModule(require("crypto"));
function sha1(inputString) {
  const shasum = import_crypto.default.createHash("sha1");
  shasum.update(inputString);
  return shasum.digest("hex");
}

// src/commands/eval.js
function evaluate(script, numberOfKeys, ...args) {
  const scriptSha = sha1(script);
  this.shaScripts[scriptSha] = script;
  return command(customCommand(numberOfKeys, script).bind(this), "", this)(...args);
}

// src/commands/evalsha.js
function evalsha(sha12, numberOfKeys, ...args) {
  if (!(sha12 in this.shaScripts) || !this.shaScripts[sha12]) {
    throw new Error(`NOSCRIPT for sha1 ${sha12}`);
  }
  const script = this.shaScripts[sha12];
  return command(customCommand(numberOfKeys, script).bind(this), "", this)(...args);
}

// src/commands/exists.js
function exists(...keys2) {
  return keys2.reduce((totalExists, key) => {
    if (this.data.has(key)) {
      return totalExists + 1;
    }
    return totalExists;
  }, 0);
}

// src/commands/expire.js
function expire(key, seconds) {
  if (!this.data.has(key)) {
    return 0;
  }
  this.expires.set(key, seconds * 1e3 + Date.now());
  emitNotification(this, "g", key, "expire");
  return 1;
}

// src/commands/expireat.js
function expireat(key, at) {
  if (!this.data.has(key)) {
    return 0;
  }
  this.expires.set(key, at * 1e3);
  return 1;
}

// src/commands/flushall.js
function flushall() {
  this.data.clear();
  return "OK";
}

// src/commands/flushdb.js
function flushdb() {
  this.data.clear();
  return "OK";
}

// src/commands/get.js
function get(key) {
  return this.data.has(key) ? this.data.get(key) : null;
}

// src/commands/getbit.js
var MAX_OFFSET = 2 ** 32 - 1;
function getbit(key, offset) {
  if (offset > MAX_OFFSET)
    throw new Error("ERR bit offset is not an integer or out of range");
  if (!this.data.has(key))
    return 0;
  const current = this.data.get(key);
  if (offset > current.length * 8)
    return 0;
  const byteOffset = parseInt(offset / 8, 10);
  const shift = 7 - offset % 8;
  return current.charCodeAt(byteOffset) >> shift & 1;
}

// src/commands/getBuffer.js
function getBuffer(key) {
  const val = get.apply(this, [key]);
  return val ? Buffer.from(val) : val;
}

// src/commands/getrange.js
function getrange(key, s, e) {
  const val = this.data.get(key);
  const start = parseInt(s, 10);
  const end = parseInt(e, 10);
  if (end === -1) {
    return val.slice(start);
  }
  return val.slice(start, end + 1);
}

// src/commands/getset.js
function getset(key, val) {
  const old = this.data.has(key) ? this.data.get(key) : null;
  this.data.set(key, val);
  this.expires.delete(key);
  return old;
}

// src/commands/hdel.js
function hdel(key, ...fields) {
  const value = this.data.get(key);
  if (!value) {
    return 0;
  }
  const numDeleted = fields.filter((field) => {
    if ({}.hasOwnProperty.call(value, field)) {
      delete value[field];
      return true;
    }
    return false;
  }).length;
  const numLeft = Object.getOwnPropertyNames(value).length;
  if (numLeft > 0) {
    this.data.set(key, value);
  } else {
    this.data.delete(key);
  }
  return numDeleted;
}

// src/commands/hexists.js
function hexists(key, field) {
  const hash = this.data.get(key);
  if (!hash || hash[field] === void 0) {
    return 0;
  }
  return {}.hasOwnProperty.call(hash, field) ? 1 : 0;
}

// src/commands/hget.js
function hget(key, hashKey) {
  const hash = this.data.get(key);
  if (!hash || hash[hashKey] === void 0) {
    return null;
  }
  return hash[hashKey];
}

// src/commands/hgetBuffer.js
function hgetBuffer(key, hashKey) {
  const val = hget.apply(this, [key, hashKey]);
  return val ? Buffer.from(val) : val;
}

// src/commands/hgetall.js
function hgetall(key) {
  return this.data.get(key) || {};
}

// src/commands/hgetallBuffer.js
function hgetallBuffer(key) {
  const val = hgetall.apply(this, [key]);
  Object.keys(val).forEach((keyInObject) => {
    val[keyInObject] = Buffer.from(val[keyInObject]);
  });
  return val;
}

// src/commands/hincrby.js
function hincrby(key, field, increment = 0) {
  if (!this.data.has(key)) {
    this.data.set(key, {[field]: "0"});
  }
  const hash = this.data.get(key);
  if (!{}.hasOwnProperty.call(hash, field)) {
    hash[field] = "0";
  }
  const curVal = Number(hash[field]);
  const nextVal = curVal + parseInt(increment, 10);
  hash[field] = nextVal.toString();
  this.data.set(key, hash);
  return nextVal;
}

// src/commands/hincrbyfloat.js
function hincrbyfloat(key, field, increment) {
  if (!this.data.has(key)) {
    this.data.set(key, {[field]: "0"});
  }
  const hash = this.data.get(key);
  if (!{}.hasOwnProperty.call(hash, field)) {
    hash[field] = "0";
  }
  const curVal = parseFloat(hash[field]);
  hash[field] = (curVal + parseFloat(increment)).toString();
  this.data.set(key, hash);
  return hash[field];
}

// src/commands/hkeys.js
function hkeys(key) {
  return this.data.has(key) ? Object.keys(this.data.get(key)) : [];
}

// src/commands/hlen.js
function hlen(key) {
  return this.data.has(key) ? Object.keys(this.data.get(key)).length : 0;
}

// src/commands/hmget.js
function hmget(key, ...fields) {
  const hash = this.data.get(key);
  return fields.map((field) => {
    if (!hash || hash[field] === void 0) {
      return null;
    }
    return hash[field];
  });
}

// src/commands/hmgetBuffer.js
function hmgetBuffer(key, ...fields) {
  const val = hmget.apply(this, [key, ...fields]);
  return val.map((payload) => payload ? Buffer.from(payload) : payload);
}

// src/commands/hmset.js
function hmset(key, ...args) {
  if (!this.data.has(key)) {
    this.data.set(key, {});
  }
  const hash = this.data.get(key);
  for (let i = 0; i < args.length; i += 2) {
    hash[args[i]] = args[i + 1];
  }
  this.data.set(key, hash);
  return "OK";
}

// src/commands-utils/scan-command.common.js
function pattern(str) {
  let string = str.replace(/([+{($^|.\\])/g, "\\$1");
  string = string.replace(/(^|[^\\])([*?])/g, "$1.$2");
  string = `^${string}$`;
  const p = new RegExp(string);
  return p.test.bind(p);
}
function getCountAndMatch(args) {
  if (args.length > 4) {
    throw new Error("Too many arguments");
  }
  if (args.length % 2 !== 0) {
    throw new Error("Args should be provided by pair (name & value)");
  }
  let count = 10;
  let matchPattern = null;
  const test = `${args[0]}${args[2]}`.toUpperCase();
  if (test === "UNDEFINEDUNDEFINED") {
    return [count, matchPattern];
  }
  if (test === "MATCHUNDEFINED") {
    matchPattern = pattern(args[1]);
  } else if (test === "COUNTUNDEFINED") {
    count = parseInt(args[1], 10);
  } else if (test === "MATCHCOUNT") {
    matchPattern = pattern(args[1]);
    count = parseInt(args[3], 10);
  } else if (test.startsWith("MATCH") || test.startsWith("COUNT")) {
    throw new Error("BAD Syntax");
  } else {
    throw new Error(`Uknown option ${args[0]}`);
  }
  if (Number.isNaN(count)) {
    throw new Error("count must be integer");
  }
  return [count, matchPattern];
}
function scanHelper(allKeys, size, cursorStart, ...args) {
  const cursor = parseInt(cursorStart, 10);
  if (Number.isNaN(cursor)) {
    throw new Error("Cursor must be integer");
  }
  const [count, matchPattern] = getCountAndMatch(args);
  let nextCursor = cursor + count;
  const keys2 = allKeys.slice(cursor, nextCursor);
  if (matchPattern) {
    let i = 0;
    while (i < keys2.length)
      if (!matchPattern(keys2[i])) {
        keys2.splice(i, size);
      } else {
        i += size;
      }
  }
  if (nextCursor >= allKeys.length) {
    nextCursor = 0;
  }
  return [String(nextCursor), keys2];
}

// src/commands/hscan.js
function hscan(key, cursor, ...args) {
  if (!this.data.has(key)) {
    return ["0", []];
  }
  const hKeys = Object.keys(this.data.get(key));
  return scanHelper(hKeys, 1, cursor, ...args);
}

// src/commands/hset.js
function hset(key, ...keyValuePairs) {
  if (!this.data.has(key)) {
    this.data.set(key, {});
  }
  const hash = this.data.get(key);
  let reply = 0;
  for (let i = 0; i < keyValuePairs.length; i += 2) {
    const field = keyValuePairs[i];
    const value = keyValuePairs[i + 1];
    if (!{}.hasOwnProperty.call(hash, field)) {
      reply++;
    }
    hash[field] = value;
  }
  this.data.set(key, hash);
  return reply;
}

// src/commands/hsetnx.js
function hsetnx(key, hashKey, hashVal) {
  if (!this.data.has(key)) {
    this.data.set(key, {});
  }
  if (!{}.hasOwnProperty.call(this.data.get(key), hashKey)) {
    const hash = this.data.get(key);
    hash[hashKey] = hashVal;
    this.data.set(key, hash);
    return 1;
  }
  return 0;
}

// src/commands/hstrlen.js
function hstrlen(key, field) {
  return this.data.has(key) && {}.hasOwnProperty.call(this.data.get(key), field) ? this.data.get(key)[field].length : 0;
}

// src/commands/hvals.js
var import_lodash2 = __toModule(require("lodash"));
function hvals(key) {
  return (0, import_lodash2.values)(this.data.get(key));
}

// src/commands/incr.js
function incr(key) {
  if (!this.data.has(key)) {
    this.data.set(key, "0");
  }
  const curVal = Number(this.data.get(key));
  const nextVal = curVal + 1;
  this.data.set(key, nextVal.toString());
  return nextVal;
}

// src/commands/incrby.js
function incrby(key, increment = 0) {
  if (!this.data.has(key)) {
    this.data.set(key, "0");
  }
  const curVal = Number(this.data.get(key));
  const nextVal = curVal + parseInt(increment, 10);
  this.data.set(key, nextVal.toString());
  return nextVal;
}

// src/commands/incrbyfloat.js
function incrbyfloat(key, increment) {
  if (!this.data.has(key)) {
    this.data.set(key, "0");
  }
  const curVal = parseFloat(this.data.get(key));
  this.data.set(key, (curVal + parseFloat(increment)).toString());
  return this.data.get(key);
}

// src/commands/info.js
function info() {
  if (this.data.has("info")) {
    return this.data.get("info");
  }
  const defaultInfo = [
    "# Server",
    "redis_version:5.0.7",
    "redis_git_sha1:00000000",
    "redis_git_dirty:0",
    "redis_build_id:6eea854fbb5ddd69",
    "redis_mode:standalone",
    "os:Linux 4.19.76-linuxkit x86_64",
    "arch_bits:64",
    "multiplexing_api:epoll",
    "atomicvar_api:atomic-builtin",
    "gcc_version:9.2.0",
    "process_id:1",
    "run_id:4787d20e758149c8d52455abc39cf8cf277a334c",
    "tcp_port:6379",
    "uptime_in_seconds:968",
    "uptime_in_days:0",
    "hz:10",
    "configured_hz:10",
    "lru_clock:642868",
    "executable:/data/redis-server",
    "config_file:",
    "",
    "# Clients",
    "connected_clients:1",
    "client_recent_max_input_buffer:2",
    "client_recent_max_output_buffer:0",
    "blocked_clients:0",
    "",
    "# Memory",
    "used_memory:898376",
    "used_memory_human:877.32K",
    "used_memory_rss:4046848",
    "used_memory_rss_human:3.86M",
    "used_memory_peak:1022480",
    "used_memory_peak_human:998.52K",
    "used_memory_peak_perc:87.86%",
    "used_memory_overhead:847550",
    "used_memory_startup:791264",
    "used_memory_dataset:50826",
    "used_memory_dataset_perc:47.45%",
    "allocator_allocated:1626408",
    "allocator_active:1945600",
    "allocator_resident:8847360",
    "total_system_memory:2086522880",
    "total_system_memory_human:1.94G",
    "used_memory_lua:51200",
    "used_memory_lua_human:50.00K",
    "used_memory_scripts:4528",
    "used_memory_scripts_human:4.42K",
    "number_of_cached_scripts:2",
    "maxmemory:0",
    "maxmemory_human:0B",
    "maxmemory_policy:noeviction",
    "allocator_frag_ratio:1.20",
    "allocator_frag_bytes:319192",
    "allocator_rss_ratio:4.55",
    "allocator_rss_bytes:6901760",
    "rss_overhead_ratio:0.46",
    "rss_overhead_bytes:-4800512",
    "mem_fragmentation_ratio:4.73",
    "mem_fragmentation_bytes:3190472",
    "mem_not_counted_for_evict:0",
    "mem_replication_backlog:0",
    "mem_clients_slaves:0",
    "mem_clients_normal:49694",
    "mem_aof_buffer:0",
    "mem_allocator:jemalloc-5.1.0",
    "active_defrag_running:0",
    "lazyfree_pending_objects:0",
    "",
    "# Persistence",
    "loading:0",
    "rdb_changes_since_last_save:1",
    "rdb_bgsave_in_progress:0",
    "rdb_last_save_time:1577700205",
    "rdb_last_bgsave_status:ok",
    "rdb_last_bgsave_time_sec:-1",
    "rdb_current_bgsave_time_sec:-1",
    "rdb_last_cow_size:0",
    "aof_enabled:0",
    "aof_rewrite_in_progress:0",
    "aof_rewrite_scheduled:0",
    "aof_last_rewrite_time_sec:-1",
    "aof_current_rewrite_time_sec:-1",
    "aof_last_bgrewrite_status:ok",
    "aof_last_write_status:ok",
    "aof_last_cow_size:0",
    "",
    "# Stats",
    "total_connections_received:6",
    "total_commands_processed:32",
    "instantaneous_ops_per_sec:0",
    "total_net_input_bytes:6643",
    "total_net_output_bytes:31254",
    "instantaneous_input_kbps:0.00",
    "instantaneous_output_kbps:0.00",
    "rejected_connections:0",
    "sync_full:0",
    "sync_partial_ok:0",
    "sync_partial_err:0",
    "expired_keys:1",
    "expired_stale_perc:0.00",
    "expired_time_cap_reached_count:0",
    "evicted_keys:0",
    "keyspace_hits:0",
    "keyspace_misses:11",
    "pubsub_channels:0",
    "pubsub_patterns:0",
    "latest_fork_usec:0",
    "migrate_cached_sockets:0",
    "slave_expires_tracked_keys:0",
    "active_defrag_hits:0",
    "active_defrag_misses:0",
    "active_defrag_key_hits:0",
    "active_defrag_key_misses:0",
    "",
    "# Replication",
    "role:master",
    "connected_slaves:0",
    "master_replid:4ca161d4b9cc62b01bb87b9084a71ff229d0bda8",
    "master_replid2:0000000000000000000000000000000000000000",
    "master_repl_offset:0",
    "second_repl_offset:-1",
    "repl_backlog_active:0",
    "repl_backlog_size:1048576",
    "repl_backlog_first_byte_offset:0",
    "repl_backlog_histlen:0",
    "",
    "# CPU",
    "used_cpu_sys:4.571514",
    "used_cpu_user:1.065946",
    "used_cpu_sys_children:0.002352",
    "used_cpu_user_children:0.001369",
    "",
    "# Cluster",
    "cluster_enabled:0",
    "",
    "# Keyspace",
    "db0:keys=38,expires=0,avg_ttl=0"
  ].join("\r\n");
  return defaultInfo;
}

// src/commands-utils/patternMatchesString.js
function stringmatchlen(pattern2, p, patternLen, string, s, stringLen, nocase) {
  while (patternLen && stringLen) {
    switch (pattern2[p]) {
      case "*":
        while (patternLen && pattern2[p + 1] === "*") {
          p++;
          patternLen--;
        }
        if (patternLen === 1)
          return true;
        while (stringLen) {
          if (stringmatchlen(pattern2, p + 1, patternLen - 1, string, s, stringLen, nocase)) {
            return true;
          }
          s++;
          stringLen--;
        }
        return false;
      case "?":
        s++;
        stringLen--;
        break;
      case "[": {
        let match = false;
        p++;
        patternLen--;
        const not = pattern2[p] === "^";
        if (not) {
          p++;
          patternLen--;
        }
        while (true) {
          if (pattern2[p] === "\\" && patternLen >= 2) {
            p++;
            patternLen--;
            if (pattern2[p] === string[s])
              match = true;
          } else if (pattern2[p] === "]") {
            break;
          } else if (patternLen === 0) {
            p--;
            patternLen++;
            break;
          } else if (patternLen >= 3 && pattern2[p + 1] === "-") {
            let start = pattern2[p];
            let end = pattern2[p + 2];
            let c = string[s];
            if (start > end) {
              const t = start;
              start = end;
              end = t;
            }
            if (nocase) {
              start = start.toLowerCase();
              end = end.toLowerCase();
              c = c.toLowerCase();
            }
            p += 2;
            patternLen -= 2;
            if (c >= start && c <= end) {
              match = true;
            }
          } else if (!nocase) {
            if (pattern2[p] === string[s])
              match = true;
          } else if (pattern2[p].toLowerCase() === string[s].toLowerCase()) {
            match = true;
          }
          p++;
          patternLen--;
        }
        if (not)
          match = !match;
        if (!match)
          return false;
        s++;
        stringLen--;
        break;
      }
      case "\\":
        if (patternLen >= 2) {
          p++;
          patternLen--;
        }
      default:
        if (!nocase) {
          if (pattern2[p] !== string[s])
            return false;
        } else if (pattern2[p].toLowerCase() !== string[s].toLowerCase()) {
          return false;
        }
        s++;
        stringLen--;
        break;
    }
    p++;
    patternLen--;
    if (stringLen === 0) {
      while (pattern2[p] === "*") {
        p++;
        patternLen--;
      }
      break;
    }
  }
  return patternLen === 0 && stringLen === 0;
}
function stringmatch(pattern2, string, nocase) {
  return stringmatchlen(pattern2, 0, pattern2.length, string, 0, string.length, nocase);
}
function patternMatchesString(pattern2, string) {
  return stringmatch(pattern2, string, false);
}

// src/commands/keys.js
function keys(globString) {
  return this.data.keys().filter((key) => patternMatchesString(globString, key));
}

// src/commands/lastsave.js
function lastsave() {
  return Math.floor(new Date().getTime() / 1e3);
}

// src/commands/lindex.js
function lindex(key, i) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const index = parseInt(i, 10);
  const list = this.data.get(key) || [];
  const item = list[index < 0 ? list.length + index : index];
  return item !== void 0 ? item : null;
}

// src/commands/llen.js
function llen(key) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  return (this.data.get(key) || []).length;
}

// src/commands/lpop.js
function lpop(key) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const list = this.data.get(key) || [];
  const item = list.length > 0 ? list.shift() : null;
  this.data.set(key, list);
  return item;
}

// src/commands/lpopBuffer.js
function lpopBuffer(key) {
  const val = lpop.apply(this, [key]);
  return val ? Buffer.from(val) : val;
}

// src/commands/lpush.js
function lpush(key, ...values2) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const list = this.data.get(key) || [];
  const length = list.unshift(...values2.reverse());
  this.data.set(key, list);
  return length;
}

// src/commands/linsert.js
function linsert(key, position, pivot, element) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const list = this.data.get(key) || [];
  const pivotIndex = list.indexOf(pivot);
  if (pivotIndex < 0)
    return -1;
  let elementIndex = pivotIndex;
  switch (position) {
    case "BEFORE":
      elementIndex = pivotIndex;
      break;
    case "AFTER":
      elementIndex = pivotIndex + 1;
      break;
    default:
      throw new Error("The position of the new element must be BEFORE the pivot or AFTER the pivot");
  }
  list.splice(elementIndex, 0, element);
  const {length} = list;
  this.data.set(key, list);
  return length;
}

// src/commands/lpushx.js
function lpushx(key, value) {
  if (!this.data.has(key)) {
    return 0;
  }
  return lpush.call(this, key, value);
}

// src/commands/lrange.js
function lrange(key, s, e) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  let start = parseInt(s, 10);
  let end = parseInt(e, 10);
  const list = this.data.get(key) || [];
  if (start < 0) {
    start = list.length + start;
  }
  if (end < 0) {
    end = list.length + end;
  }
  return list.slice(start, end + 1);
}

// src/commands/lrem.js
function lrem(key, c, value) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    return 0;
  }
  const count = parseInt(c, 10);
  const list = [...this.data.get(key) || []];
  const indexFun = (count < 0 ? [].lastIndexOf : [].indexOf).bind(list);
  const max = count === 0 ? list.length : Math.abs(count);
  let removed = 0;
  let idx = indexFun(value);
  while (idx !== -1 && removed < max) {
    removed++;
    list.splice(idx, 1);
    idx = indexFun(value);
  }
  this.data.set(key, list);
  return removed;
}

// src/commands/lset.js
function lset(key, i, value) {
  if (!this.data.has(key)) {
    throw new Error("no such key");
  }
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const index = parseInt(i, 10);
  const list = this.data.get(key) || [];
  list[index < 0 ? list.length + index : index] = value;
  this.data.set(key, list);
  return "OK";
}

// src/commands/ltrim.js
function ltrim(key, s, e) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const start = parseInt(s, 10);
  const end = parseInt(e, 10);
  const list = this.data.get(key) || [];
  this.data.set(key, list.slice(start, end + 1 || void 0));
  return "OK";
}

// src/commands/mget.js
function mget(...keys2) {
  return keys2.map((key) => this.data.has(key) ? this.data.get(key) : null);
}

// src/commands/mset.js
function mset(...msetData) {
  for (let i = 0; i < msetData.length; i += 2) {
    set.call(this, msetData[i], msetData[i + 1]);
  }
  return "OK";
}

// src/commands/msetnx.js
function msetnx(...msetData) {
  for (let i = 0; i < msetData.length; i += 2) {
    if (this.data.has(msetData[i])) {
      return 0;
    }
  }
  for (let i = 0; i < msetData.length; i += 2) {
    set.call(this, msetData[i], msetData[i + 1]);
  }
  return 1;
}

// src/commands/persist.js
function persist(key) {
  if (!this.data.has(key)) {
    return 0;
  }
  if (!this.expires.has(key)) {
    return 0;
  }
  this.expires.delete(key);
  return 1;
}

// src/commands/pexpire.js
function pexpire(key, milliseconds) {
  if (!this.data.has(key)) {
    return 0;
  }
  this.expires.set(key, +milliseconds + Date.now());
  return 1;
}

// src/commands/pexpireat.js
function pexpireat(key, at) {
  if (!this.data.has(key)) {
    return 0;
  }
  this.expires.set(key, at);
  return 1;
}

// src/commands/ping.js
function ping(message = "PONG") {
  return message;
}

// src/commands/psetex.js
function psetex(key, milliseconds, value) {
  set.call(this, key, value);
  pexpire.call(this, key, milliseconds);
  return "OK";
}

// src/commands/pttl.js
function pttl(key) {
  if (!this.data.has(key)) {
    return -2;
  }
  if (!this.expires.has(key)) {
    return -1;
  }
  return Math.ceil(this.expires.get(key) - Date.now());
}

// src/commands-utils/emitMessage.js
function emitMessage(redisMock, channel, message, pattern2) {
  process.nextTick(() => {
    if (pattern2) {
      redisMock.emit(Buffer.isBuffer(message) ? "pmessageBuffer" : "pmessage", pattern2, channel, message);
    } else {
      redisMock.emit(Buffer.isBuffer(message) ? "messageBuffer" : "message", channel, message);
    }
  });
}

// src/commands-utils/channel-subscription.js
function getSubscribedChannels(instance, channelStore) {
  const subscribedChannels = [];
  if (!channelStore.instanceListeners) {
    return [];
  }
  channelStore.instanceListeners.forEach((instanceMap, channel) => {
    if (instanceMap.has(instance)) {
      subscribedChannels.push(channel);
    }
  });
  return subscribedChannels;
}
function subscribeToChannel(instance, chan, channels, isPattern) {
  if (!channels.instanceListeners.has(chan)) {
    channels.instanceListeners.set(chan, new Map());
  }
  if (channels.instanceListeners.get(chan).has(instance)) {
    return;
  }
  const listener = (message, channel) => emitMessage(instance, isPattern ? channel : chan, message, isPattern ? chan : void 0);
  channels.on(chan, listener);
  channels.instanceListeners.get(chan).set(instance, listener);
}
function unsubscribeFromChannel(instance, chan, channels) {
  if (!channels.instanceListeners || channels.instanceListeners.has(chan) === false) {
    return;
  }
  const channelMap = channels.instanceListeners.get(chan);
  if (channelMap.has(instance) === false) {
    return;
  }
  const listener = channelMap.get(instance);
  channels.removeListener(chan, listener);
  channelMap.delete(instance);
  if (channelMap.size === 0) {
    channels.instanceListeners.delete(chan);
  }
}

// src/commands/psubscribe.js
function psubscribe(...args) {
  args.forEach((pattern2) => {
    if (!this.patternChannels.instanceListeners) {
      this.patternChannels.instanceListeners = new Map();
    }
    subscribeToChannel(this, pattern2, this.patternChannels, true);
  });
  const numberOfSubscribedChannels = getSubscribedChannels(this, this.patternChannels).length;
  if (numberOfSubscribedChannels > 0) {
    this.subscriberMode = true;
  }
  return numberOfSubscribedChannels;
}

// src/commands/publish.js
function publish(channel, message) {
  this.channels.emit(channel, message);
  const matchingPatterns = this.patternChannels.eventNames().filter((pattern2) => patternMatchesString(pattern2, channel));
  matchingPatterns.forEach((matchingChannel) => this.patternChannels.emit(matchingChannel, message, channel));
  const numberOfSubscribers = matchingPatterns.length + this.channels.listenerCount(channel);
  return numberOfSubscribers;
}

// src/commands/punsubscribe.js
function punsubscribe(...args) {
  if (args.length === 0) {
    getSubscribedChannels(this, this.patternChannels).forEach((channel) => {
      unsubscribeFromChannel(this, channel, this.patternChannels);
    });
  }
  args.forEach((pattern2) => {
    unsubscribeFromChannel(this, pattern2, this.patternChannels);
  });
  const numberOfSubscribedChannels = getSubscribedChannels(this, this.patternChannels).length;
  if (numberOfSubscribedChannels + getSubscribedChannels(this, this.channels).length === 0) {
    this.subscriberMode = false;
  }
  return numberOfSubscribedChannels;
}

// src/commands/quit.js
function quit() {
  this.disconnect();
  return "OK";
}

// src/commands/randomkey.js
var import_lodash3 = __toModule(require("lodash"));
function randomkey() {
  const keys2 = this.data.keys();
  return keys2.length > 0 ? keys2[(0, import_lodash3.random)(0, keys2.length - 1)] : null;
}

// src/commands/rename.js
function rename(key, newKey) {
  const value = this.data.get(key);
  if (this.expires.has(key)) {
    const expire2 = this.expires.get(key);
    this.expires.delete(key);
    this.expires.set(newKey, expire2);
  }
  this.data.set(newKey, value);
  this.data.delete(key);
  emitNotification(this, "g", key, "rename_from");
  emitNotification(this, "g", newKey, "rename_to");
  return "OK";
}

// src/commands/renamenx.js
function renamenx(key, newKey) {
  if (this.data.has(newKey)) {
    return 0;
  }
  rename.call(this, key, newKey);
  return 1;
}

// src/commands/role.js
function role() {
  return ["master", 0];
}

// src/commands/rpop.js
function rpop(key) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const list = this.data.get(key) || [];
  const item = list.length > 0 ? list.pop() : null;
  this.data.set(key, list);
  return item;
}

// src/commands/rpopBuffer.js
function rpopBuffer(key) {
  return rpop.apply(this, [key]);
}

// src/commands/rpoplpush.js
function rpoplpush(source, destination) {
  if (this.data.has(source) && !(this.data.get(source) instanceof Array)) {
    throw new Error(`Key ${source} does not contain a list`);
  }
  if (this.data.has(destination) && !(this.data.get(destination) instanceof Array)) {
    throw new Error(`Key ${destination} does not contain a list`);
  }
  if (!this.data.has(source) || this.data.get(source).length === 0) {
    return null;
  }
  if (!this.data.has(destination)) {
    this.data.set(destination, []);
  }
  const newSource = this.data.get(source);
  const item = newSource.pop();
  const newDest = this.data.get(destination);
  newDest.unshift(item);
  this.data.set(source, newSource);
  this.data.set(destination, newDest);
  return item;
}

// src/commands/rpoplpushBuffer.js
function rpoplpushBuffer(source, destination) {
  return rpoplpush.apply(this, [source, destination]);
}

// src/commands/rpush.js
function rpush(key, ...values2) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Array)) {
    throw new Error(`Key ${key} does not contain a list`);
  }
  const list = this.data.get(key) || [];
  const length = list.push(...values2);
  this.data.set(key, list);
  return length;
}

// src/commands/rpushx.js
function rpushx(key, value) {
  if (!this.data.has(key)) {
    return 0;
  }
  return rpush.call(this, key, value);
}

// src/commands/sadd.js
function sadd(key, ...vals) {
  if (!this.data.has(key)) {
    this.data.set(key, new Set());
  }
  let added = 0;
  const set2 = this.data.get(key);
  vals.forEach((value) => {
    if (!set2.has(value)) {
      added++;
    }
    set2.add(value);
  });
  this.data.set(key, set2);
  return added;
}

// src/commands/save.js
function save() {
  return "OK";
}

// src/commands/scan.js
function scan(cursor, opt1, opt1val, opt2, opt2val) {
  const allKeys = this.data.keys();
  return scanHelper(allKeys, 1, cursor, opt1, opt1val, opt2, opt2val);
}

// src/commands/scard.js
function scard(key) {
  const set2 = this.data.get(key);
  if (!set2) {
    return 0;
  }
  if (!(set2 instanceof Set)) {
    throw new Error(`Key ${key} does not contain a set`);
  }
  return this.data.get(key).size;
}

// src/commands/sdiff.js
function sdiff(ours, ...theirs) {
  if (this.data.has(ours) && !(this.data.get(ours) instanceof Set)) {
    throw new Error(`Key ${ours} does not contain a set`);
  }
  theirs.forEach((key) => {
    if (this.data.has(key) && !(this.data.get(key) instanceof Set)) {
      throw new Error(`Key ${key} does not contain a set`);
    }
  });
  const ourSet = this.data.has(ours) ? this.data.get(ours) : new Set();
  const theirSets = theirs.map((key) => this.data.has(key) ? this.data.get(key) : new Set());
  const difference = new Set(Array.from(ourSet).filter((ourValue) => theirSets.reduce((isUnique, set2) => set2.has(ourValue) ? false : isUnique, true)));
  return Array.from(difference);
}

// src/commands-utils/makeStoreCommand.js
function makeStoreCommand(baseCommand, ResultType) {
  return function(dest, ...args) {
    const result = baseCommand.call(this, ...args);
    this.data.set(dest, new ResultType(result));
    return result.length;
  };
}
function makeStoreSetCommand(baseCommand) {
  return makeStoreCommand(baseCommand, Set);
}

// src/commands/sdiffstore.js
var sdiffstore = makeStoreSetCommand(sdiff);

// src/commands/set.js
function createGroupedArray(arr, groupSize) {
  const groups = [];
  for (let i = 0; i < arr.length; i += groupSize) {
    groups.push(arr.slice(i, i + groupSize));
  }
  return groups;
}
function set(key, value, ...options) {
  const nx = options.indexOf("NX") !== -1;
  const xx = options.indexOf("XX") !== -1;
  const filteredOptions = options.filter((option) => option !== "NX" && option !== "XX");
  if (nx && xx)
    throw new Error("ERR syntax error");
  if (nx && this.data.has(key))
    return null;
  if (xx && !this.data.has(key))
    return null;
  this.data.set(key, value);
  const expireOptions = new Map(createGroupedArray(filteredOptions, 2));
  const ttlSeconds = expireOptions.get("EX") || expireOptions.get("PX") / 1e3;
  if (ttlSeconds) {
    expire.call(this, key, ttlSeconds);
  } else {
    this.expires.delete(key);
  }
  return "OK";
}

// src/commands/setbit.js
var MAX_OFFSET2 = 2 ** 32 - 1;
var STR_BIT_0 = String.fromCharCode(0);
var constantLengthOf = (len) => (str) => str + Array(Math.max(0, len - str.length)).fill(STR_BIT_0).join("");
var getBitAt = (position) => (byte) => byte >> position & 1;
var setBitAt = (position) => (byte) => byte | 1 << position;
var resetBitAt = (position) => (byte) => byte & ~(1 << position);
var setOrResetBitAt = (bit) => bit === 1 ? setBitAt : resetBitAt;
var getByteAt = (position) => (str) => str.charCodeAt(position);
var setByteAt = (byte) => (position) => (str) => str.substr(0, position) + String.fromCharCode(byte) + str.substr(position + 1);
function setbit(key, offset, value) {
  if (offset > MAX_OFFSET2)
    throw new Error("ERR bit offset is not an integer or out of range");
  const bit = parseInt(value, 10);
  if (bit !== 0 && bit !== 1)
    throw new Error("ERR bit is not an integer or out of range");
  const byteOffset = parseInt(offset / 8, 10);
  const bitOffset = 7 - offset % 8;
  const prev = this.data.has(key) ? this.data.get(key) : "";
  const prevByte = getByteAt(byteOffset)(prev);
  const padded = constantLengthOf(byteOffset + 1)(prev);
  const newByte = setOrResetBitAt(bit)(bitOffset)(prevByte);
  const newValue = setByteAt(newByte)(byteOffset)(padded);
  this.data.set(key, newValue);
  return getBitAt(bitOffset)(prevByte);
}

// src/commands/setex.js
function setex(key, seconds, value) {
  set.call(this, key, value);
  expire.call(this, key, seconds);
  return "OK";
}

// src/commands/setnx.js
function setnx(key, val) {
  if (!this.data.has(key)) {
    this.data.set(key, val);
    return 1;
  }
  return 0;
}

// src/commands/sinter.js
function sinter(...keys2) {
  const values2 = sunion.apply(this, keys2);
  const sets = keys2.map((key) => this.data.has(key) ? this.data.get(key) : new Set());
  const intersection = new Set(values2.filter((value) => sets.reduce((isShared, set2) => set2.has(value) ? isShared : false, true)));
  return Array.from(intersection);
}

// src/commands/sinterstore.js
var sinterstore = makeStoreSetCommand(sinter);

// src/commands/sismember.js
function sismember(key, val) {
  const data = this.data.get(key);
  if (data) {
    return data.has(val) ? 1 : 0;
  }
  return 0;
}

// src/commands/smismember.js
function smismember(key, ...valArray) {
  const data = this.data.get(key);
  if (data) {
    return valArray.map((val) => data.has(val) ? 1 : 0);
  }
  return valArray.map(() => 0);
}

// src/commands/smembers.js
function smembers(key) {
  if (!this.data.has(key)) {
    return [];
  }
  return Array.from(this.data.get(key));
}

// src/commands/smove.js
function smove(source, destination, member) {
  if (this.data.has(source) && !(this.data.get(source) instanceof Set)) {
    throw new Error(`Key ${source} does not contain a set`);
  }
  if (this.data.has(destination) && !(this.data.get(destination) instanceof Set)) {
    throw new Error(`Key ${destination} does not contain a set`);
  }
  if (!this.data.has(source)) {
    return 0;
  }
  const sourceSet = this.data.get(source);
  if (!sourceSet.has(member)) {
    return 0;
  }
  sourceSet.delete(member);
  this.data.set(source, sourceSet);
  if (!this.data.has(destination)) {
    this.data.set(destination, new Set());
  }
  const destSet = this.data.get(destination);
  destSet.add(member);
  this.data.set(destination, destSet);
  return 1;
}

// src/commands/spop.js
var import_lodash4 = __toModule(require("lodash"));
var safeCount = (count) => {
  const result = count !== void 0 ? parseInt(count, 10) : 1;
  if (Number.isNaN(result) || result < 0) {
    throw new Error("ERR value is not an integer or out of range");
  }
  return result;
};
function spop(key, count) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Set)) {
    throw new Error(`Key ${key} does not contain a set`);
  }
  const want = safeCount(count);
  const set2 = this.data.get(key) || new Set();
  const total = set2.size;
  if (want === 0)
    return void 0;
  if (total === 0)
    return null;
  const values2 = import_lodash4.default.chain(set2).toArray();
  let result;
  if (want === 1) {
    result = values2.sample().value();
    set2.delete(result);
  } else if (total <= want) {
    result = values2.value();
    set2.clear();
  } else {
    values2.shuffle();
    result = values2.take(want).value();
    result.map((item) => set2.delete(item));
  }
  this.data.set(key, set2);
  return result;
}

// src/commands/srandmember.js
var import_lodash5 = __toModule(require("lodash"));
function srandmember(key, count) {
  if (this.data.has(key) && !(this.data.get(key) instanceof Set)) {
    throw new Error(`Key ${key} does not contain a set`);
  }
  const set2 = this.data.get(key) || new Set();
  const list = Array.from(set2);
  const total = list.length;
  if (total === 0) {
    return null;
  }
  const shouldReturnArray = count !== void 0;
  const max = shouldReturnArray ? Math.abs(count) : 1;
  const skipDuplicates = shouldReturnArray && count > -1;
  if (skipDuplicates) {
    return (0, import_lodash5.shuffle)(list.splice(0, max));
  }
  const items = [];
  let results = 0;
  while (results < max) {
    const item = list[(0, import_lodash5.random)(0, total - 1)];
    items.push(item);
    results += 1;
  }
  return shouldReturnArray ? items : items[0];
}

// src/commands/srem.js
function srem(key, ...vals) {
  if (!this.data.has(key)) {
    return 0;
  }
  let removed = 0;
  const set2 = this.data.get(key);
  vals.forEach((val) => {
    if (set2.has(val)) {
      removed++;
    }
    set2.delete(val);
  });
  if (set2.size === 0) {
    this.data.delete(key);
  } else {
    this.data.set(key, set2);
  }
  return removed;
}

// src/commands/sscan.js
function sscan(key, cursor, ...args) {
  if (!this.data.has(key)) {
    return ["0", []];
  }
  const setKeys = [];
  this.data.get(key).forEach((value) => setKeys.push(value));
  return scanHelper(setKeys, 1, cursor, ...args);
}

// src/commands/strlen.js
function strlen(key) {
  return this.data.has(key) ? this.data.get(key).length : 0;
}

// src/commands/subscribe.js
function subscribe(...args) {
  args.forEach((chan) => {
    if (!this.channels.instanceListeners) {
      this.channels.instanceListeners = new Map();
    }
    subscribeToChannel(this, chan, this.channels);
  });
  if (!this.channels.instanceListeners) {
    return 0;
  }
  const numberOfSubscribedChannels = getSubscribedChannels(this, this.channels).length;
  if (numberOfSubscribedChannels > 0) {
    this.subscriberMode = true;
  }
  return numberOfSubscribedChannels;
}

// src/commands/sunion.js
function sunion(...keys2) {
  keys2.forEach((key) => {
    if (this.data.has(key) && !(this.data.get(key) instanceof Set)) {
      throw new Error(`Key ${key} does not contain a set`);
    }
  });
  const sets = keys2.map((key) => this.data.has(key) ? this.data.get(key) : new Set());
  const union = new Set(sets.reduce((combined, set2) => [...combined, ...Array.from(set2)], []));
  return Array.from(union);
}

// src/commands/sunionstore.js
var sunionstore = makeStoreSetCommand(sunion);

// src/commands/time.js
function time() {
  return [
    Math.round(new Date().getTime() / 1e3),
    Math.round(process.hrtime()[1] / 1e3)
  ];
}

// src/commands/ttl.js
function ttl(key) {
  if (!this.data.has(key)) {
    return -2;
  }
  if (!this.expires.has(key)) {
    return -1;
  }
  return Math.ceil((this.expires.get(key) - Date.now()) / 1e3);
}

// src/commands/type.js
var import_lodash6 = __toModule(require("lodash"));
function type(key) {
  if (!this.data.has(key)) {
    return "none";
  }
  const val = this.data.get(key);
  if (val instanceof Set) {
    return "set";
  }
  if ((0, import_lodash6.isArray)(val)) {
    return "list";
  }
  if ((0, import_lodash6.isString)(val)) {
    return "string";
  }
  if ((0, import_lodash6.isPlainObject)(val)) {
    return "hash";
  }
}

// src/commands/unlink.js
function unlink(...keys2) {
  const removeKeys = del.bind(this);
  return removeKeys(...keys2);
}

// src/commands/unsubscribe.js
function unsubscribe(...args) {
  if (args.length === 0) {
    getSubscribedChannels(this, this.channels).forEach((channel) => {
      unsubscribeFromChannel(this, channel, this.channels);
    });
    return 0;
  }
  args.forEach((chan) => {
    unsubscribeFromChannel(this, chan, this.channels);
  });
  const numberOfSubscribedChannels = getSubscribedChannels(this, this.channels).length;
  if (numberOfSubscribedChannels + getSubscribedChannels(this, this.patternChannels).length === 0) {
    this.subscriberMode = false;
  }
  return numberOfSubscribedChannels;
}

// src/commands/xadd.js
function xadd(stream, id, ...args) {
  if (!stream || !id || args.length === 0 || args.length % 2 !== 0) {
    throw new Error("ERR wrong number of arguments for 'xadd' command");
  }
  if (!this.data.has(stream)) {
    this.data.set(stream, []);
  }
  const eventId = `${id === "*" ? this.data.get(stream).length + 1 : id}-0`;
  const list = this.data.get(stream);
  if (list.length > 0 && list[0][0] === `${eventId}`) {
    throw new Error("ERR The ID specified in XADD is equal or smaller than the target stream top item");
  }
  this.data.set(`stream:${stream}:${eventId}`, {polled: false});
  this.data.set(stream, list.concat([[`${eventId}`, [...args]]]));
  return `${eventId}`;
}

// src/commands/xlen.js
function xlen(stream) {
  return (this.data.get(stream) || []).length;
}

// src/commands/xrange.js
function xrange(stream, start, end, ...args) {
  if (!stream || !start || !end) {
    throw new Error("ERR wrong number of arguments for 'xrange' command");
  }
  const [COUNT, count] = args;
  if (COUNT && !count) {
    throw new Error("ERR syntax error");
  }
  if (!this.data.has(stream)) {
    return [];
  }
  const list = this.data.get(stream);
  const min = start === "-" ? -Infinity : start;
  const max = end === "+" ? Infinity : end;
  const result = list.filter(([eventId]) => min <= parseInt(eventId, 10) && max >= parseInt(eventId, 10));
  if (count)
    return result.slice(0, count);
  return result;
}

// src/commands/xread.js
function xread(option, ...args) {
  const Promise2 = promise_container_default.get();
  const {op, opVal, rest} = option === "STREAMS" ? {op: "COUNT", opVal: Infinity, rest: args} : {
    op: option,
    opVal: parseInt(args[0], 10),
    rest: args.slice(2)
  };
  if (["COUNT", "BLOCK"].indexOf(op) < 0) {
    throw new Error("ERR syntax error");
  }
  if (rest.length % 2 !== 0) {
    throw new Error("ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified.");
  }
  const toPoll = rest.reduce((memo, arg, i) => {
    const chunk = Math.floor(i / 2);
    const tuple = memo[chunk] || [];
    memo[chunk] = tuple.concat(arg);
    return memo;
  }, []);
  const pollStream = (stream, id, count = 1) => {
    const data = this.data.get(stream);
    if (!data)
      return [];
    return data.reduce((memo, [eventId, ...row]) => {
      const {polled} = this.data.get(`stream:${stream}:${eventId}`);
      if (!polled && (id === "$" || eventId >= id) && memo.length < count) {
        this.data.set(`stream:${stream}:${eventId}`, {polled: true});
        return memo.concat([[eventId, ...row]]);
      }
      return memo;
    }, []);
  };
  const pollEvents = (streams, countVal) => streams.reduce((memo, [stream, id]) => [[stream, pollStream(stream, id, countVal)]].concat(memo), []);
  return op === "BLOCK" ? new Promise2((resolve) => {
    let timeElapsed = 0;
    const f = () => setTimeout(() => {
      if (opVal > 0 && timeElapsed < opVal)
        return resolve(null);
      const events = pollEvents(toPoll, 1);
      if (events.length > 0)
        return resolve(events);
      timeElapsed += 100;
      return f();
    }, 100);
    f();
  }) : new Promise2((resolve) => {
    const events = pollEvents(toPoll, opVal);
    if (events.length === 0)
      return resolve(null);
    return resolve(events.slice().reverse());
  });
}

// src/commands/xrevrange.js
function xrevrange(stream, end, start, ...args) {
  if (!stream || !start || !end) {
    throw new Error("ERR wrong number of arguments for 'xrevrange' command");
  }
  const [COUNT, count] = args;
  if (COUNT && !count) {
    throw new Error("ERR syntax error");
  }
  if (!this.data.has(stream)) {
    return [];
  }
  const list = this.data.get(stream).slice().reverse();
  const min = start === "-" ? -Infinity : start;
  const max = end === "+" ? Infinity : end;
  const result = list.filter(([eventId]) => min <= parseInt(eventId, 10) && max >= parseInt(eventId, 10));
  if (count)
    return result.slice(0, count);
  return result;
}

// src/commands/zadd.js
function zadd(key, ...vals) {
  const options = [];
  while (["NX", "XX", "CH", "INCR"].includes(vals[0])) {
    options.push(vals.shift());
  }
  const elems = vals.length;
  if (elems % 2 !== 0 || elems < 1)
    throw new Error("ERR syntax error");
  const nx = options.includes("NX");
  const xx = options.includes("XX");
  const ch = options.includes("CH");
  const incr2 = options.includes("INCR");
  if (nx && xx)
    throw new Error("XX and NX options at the same time are not compatible");
  if (incr2 && elems > 2)
    throw new Error("INCR option supports a single increment-element pair");
  if (!this.data.has(key)) {
    if (xx)
      return 0;
    this.data.set(key, new Map());
  }
  const map = this.data.get(key);
  let added = 0;
  let updated = 0;
  for (let i = 0; i < elems; i += 2) {
    let score = Number(vals[i]);
    const value = vals[i + 1];
    if (map.has(value)) {
      if (!nx) {
        if (incr2) {
          score += Number(map.get(value).score);
        }
        map.set(value, {score, value});
        updated++;
      }
    } else if (!xx) {
      map.set(value, {score, value});
      added++;
    }
  }
  this.data.set(key, map);
  return ch ? added + updated : added;
}

// src/commands/zcard.js
function zcard(key) {
  const map = this.data.get(key);
  if (!map) {
    return 0;
  }
  if (!(map instanceof Map)) {
    throw new Error(`Key ${key} does not contain a sorted set`);
  }
  return this.data.get(key).size;
}

// src/commands/zcount.js
var import_lodash7 = __toModule(require("lodash"));

// src/commands/zrange-command.common.js
function slice(arr, start, end) {
  return arr.slice(start, end === -1 ? void 0 : end + 1);
}
function normalizeCountToIndex(offset, count, array) {
  if (count < 0) {
    return -count > array.length ? 0 : array.length + count;
  }
  return offset + count;
}
function offsetAndLimit(arr, offset, count) {
  if (count === 0) {
    return [];
  }
  const end = normalizeCountToIndex(offset, count, arr);
  return arr.slice(offset, end);
}
function parseLimit(input) {
  let str = `${input}`;
  let strict = false;
  if (str[0] === "(") {
    str = str.substr(1, str.length);
    strict = true;
  } else if (str === "-inf") {
    return {value: -Infinity, isStrict: true};
  } else if (str === "+inf") {
    return {value: Infinity, isStrict: true};
  }
  return {
    value: parseInt(str, 10),
    isStrict: strict
  };
}
function filterPredicate(min, max) {
  return (it) => {
    if (it.score < min.value || min.isStrict && it.score === min.value) {
      return false;
    }
    if (it.score > max.value || max.isStrict && it.score === max.value) {
      return false;
    }
    return true;
  };
}
function getWithScoresAndLimit(args) {
  let remaining = args.length;
  let pos = 0;
  let withScores = false;
  let limit = null;
  let offset = null;
  while (remaining > 0) {
    if (remaining >= 1 && args[pos].toUpperCase() === "WITHSCORES") {
      withScores = true;
      pos += 1;
      remaining -= 1;
    } else if (remaining >= 3 && args[pos].toUpperCase() === "LIMIT") {
      offset = parseInt(args[pos + 1], 10);
      limit = parseInt(args[pos + 2], 10);
      pos += 3;
      remaining -= 3;
    } else {
      throw new Error("ERR syntax error");
    }
  }
  return {withScores, limit, offset};
}

// src/commands/zcount.js
function zcount(key, inputMin, inputMax) {
  const map = this.data.get(key);
  if (!map) {
    return 0;
  }
  if (this.data.has(key) && !(this.data.get(key) instanceof Map)) {
    return 0;
  }
  const min = parseLimit(inputMin);
  const max = parseLimit(inputMax);
  const filteredArray = (0, import_lodash7.filter)(Array.from(map.values()), filterPredicate(min, max));
  return filteredArray.length;
}

// src/commands/zincrby.js
function zincrby(key, increment, value) {
  if (!this.data.has(key)) {
    this.data.set(key, new Map());
  }
  const map = this.data.get(key);
  let score = 0;
  if (map.has(value)) {
    ({score} = map.get(value));
  }
  score += parseFloat(increment);
  map.set(value, {value, score});
  this.data.set(key, map);
  return score.toString();
}

// src/commands/zinterstore.js
var import_lodash8 = __toModule(require("lodash"));
function zinterstore(destKey, numKeys, ...keys2) {
  const srcMaps = [];
  if (parseInt(numKeys, 10) !== keys2.length) {
    throw new Error("ERR syntax error");
  }
  for (let i = 0; i < keys2.length; i += 1) {
    if (!this.data.has(keys2[i]) || !(this.data.get(keys2[i]) instanceof Map)) {
      return 0;
    }
    srcMaps.push(this.data.get(keys2[i]));
  }
  const inputs = srcMaps.map((x) => JSON.parse(JSON.stringify(Array.from(x.values()))));
  const intersected = (0, import_lodash8.intersectionBy)(...inputs, "value");
  if (intersected.length === 0) {
    this.data.delete(destKey);
    return 0;
  }
  for (let i = 0; i < intersected.length; i += 1) {
    let weightSum = 0;
    for (let j = 0; j < srcMaps.length; j += 1) {
      if (srcMaps[j].get(intersected[i].value)) {
        weightSum += srcMaps[j].get(intersected[i].value).score;
      }
    }
    intersected[i].score = weightSum;
    intersected[i] = [intersected[i].value, intersected[i]];
  }
  const intersectedMap = new Map(intersected);
  this.data.set(destKey, intersectedMap);
  return intersected.length;
}

// src/commands/zpopmax.js
var import_lodash9 = __toModule(require("lodash"));
function zpopmax(key, count = 1) {
  const map = this.data.get(key);
  if (map == null || !(map instanceof Map)) {
    return [];
  }
  const ordered = (0, import_lodash9.reverse)(slice((0, import_lodash9.orderBy)(Array.from(map.values()), ["score", "value"]), -count, -1));
  (0, import_lodash9.forEach)(ordered, (it) => {
    map.delete(it.value);
  });
  this.data.set(key, map);
  return (0, import_lodash9.flatMap)(ordered, (it) => [it.value, it.score]);
}

// src/commands/zpopmin.js
var import_lodash10 = __toModule(require("lodash"));
function zpopmin(key, count = 1) {
  const map = this.data.get(key);
  if (map == null || !(map instanceof Map)) {
    return [];
  }
  const ordered = slice((0, import_lodash10.orderBy)(Array.from(map.values()), ["score", "value"]), 0, count - 1);
  (0, import_lodash10.forEach)(ordered, (it) => {
    map.delete(it.value);
  });
  this.data.set(key, map);
  return (0, import_lodash10.flatMap)(ordered, (it) => [it.value, it.score]);
}

// src/commands/zrange.js
var import_lodash11 = __toModule(require("lodash"));
function zrange(key, s, e, withScores) {
  const map = this.data.get(key);
  if (!map) {
    return [];
  }
  if (this.data.has(key) && !(this.data.get(key) instanceof Map)) {
    return [];
  }
  const start = parseInt(s, 10);
  const end = parseInt(e, 10);
  const ordered = slice((0, import_lodash11.orderBy)(Array.from(map.values()), ["score", "value"]), start, end);
  if (typeof withScores === "string" && withScores.toUpperCase() === "WITHSCORES") {
    return (0, import_lodash11.flatMap)(ordered, (it) => [it.value, it.score]);
  }
  return ordered.map((it) => it.value);
}

// src/commands/zrangebyscore.js
var import_lodash12 = __toModule(require("lodash"));
function zrangebyscore(key, inputMin, inputMax, ...args) {
  const map = this.data.get(key);
  if (!map) {
    return [];
  }
  if (this.data.has(key) && !(this.data.get(key) instanceof Map)) {
    return [];
  }
  const {withScores, limit, offset} = getWithScoresAndLimit(args);
  const min = parseLimit(inputMin);
  const max = parseLimit(inputMax);
  const filteredArray = (0, import_lodash12.filter)(Array.from(map.values()), filterPredicate(min, max));
  let ordered = (0, import_lodash12.orderBy)(filteredArray, ["score", "value"]);
  if (withScores) {
    if (limit !== null) {
      ordered = offsetAndLimit(ordered, offset, limit);
    }
    return (0, import_lodash12.flatMap)(ordered, (it) => [it.value, it.score]);
  }
  const results = ordered.map((it) => it.value);
  if (limit !== null) {
    return offsetAndLimit(results, offset, limit);
  }
  return results;
}

// src/commands/zrank.js
function zrank(key, member) {
  const vals = zrange.call(this, key, 0, -1);
  const idx = vals.indexOf(member);
  return idx >= 0 ? idx : null;
}

// src/commands/zrem.js
function zrem(key, ...vals) {
  const map = this.data.get(key);
  if (!map)
    return 0;
  let removed = 0;
  vals.forEach((val) => {
    if (map.delete(val)) {
      removed++;
    }
  });
  this.data.set(key, map);
  return removed;
}

// src/commands/zremrangebyrank.js
function zremrangebyrank(key, s, e) {
  const vals = zrange.call(this, key, s, e);
  if (!this.data.has(key)) {
    return 0;
  }
  const map = this.data.get(key);
  vals.forEach((val) => {
    map.delete(val);
  });
  this.data.set(key, map);
  return vals.length;
}

// src/commands/zremrangebyscore.js
function zremrangebyscore(key, inputMin, inputMax) {
  const vals = zrevrangebyscore.call(this, key, inputMax, inputMin);
  if (!this.data.has(key)) {
    return 0;
  }
  const map = this.data.get(key);
  vals.forEach((val) => {
    map.delete(val);
  });
  this.data.set(key, map);
  return vals.length;
}

// src/commands/zrevrange.js
var import_lodash13 = __toModule(require("lodash"));
function zrevrange(key, s, e, w) {
  const map = this.data.get(key);
  if (!map) {
    return [];
  }
  if (this.data.has(key) && !(this.data.get(key) instanceof Map)) {
    return [];
  }
  const start = parseInt(s, 10);
  const end = parseInt(e, 10);
  let val = (0, import_lodash13.orderBy)(Array.from(map.values()), ["score", "value"], ["desc", "desc"]).map((it) => {
    if (w) {
      return [it.value, it.score];
    }
    return [it.value];
  });
  val = slice(val, start, end);
  return (0, import_lodash13.flatten)(val);
}

// src/commands/zrevrangebyscore.js
var import_lodash14 = __toModule(require("lodash"));
function zrevrangebyscore(key, inputMax, inputMin, ...args) {
  const map = this.data.get(key);
  if (!map) {
    return [];
  }
  if (this.data.has(key) && !(this.data.get(key) instanceof Map)) {
    return [];
  }
  const {withScores, limit, offset} = getWithScoresAndLimit(args);
  const min = parseLimit(inputMin);
  const max = parseLimit(inputMax);
  const filteredArray = (0, import_lodash14.filter)(Array.from(map.values()), filterPredicate(min, max));
  let ordered = (0, import_lodash14.orderBy)(filteredArray, ["score", "value"], ["desc", "desc"]);
  if (withScores) {
    if (limit !== null) {
      ordered = offsetAndLimit(ordered, offset, limit);
    }
    return (0, import_lodash14.flatMap)(ordered, (it) => [it.value, it.score]);
  }
  const results = ordered.map((it) => it.value);
  if (limit !== null) {
    return offsetAndLimit(results, offset, limit);
  }
  return results;
}

// src/commands/zrevrank.js
function zrevrank(key, member) {
  const vals = zrevrange.call(this, key, 0, -1);
  const idx = vals.indexOf(member);
  return idx >= 0 ? idx : null;
}

// src/commands/zscan.js
var import_lodash15 = __toModule(require("lodash"));
function zscan(key, cursor, ...args) {
  if (!this.data.has(key)) {
    return ["0", []];
  }
  const zKeys = [];
  this.data.get(key).forEach(({score, value}) => {
    zKeys.push([value, score.toString()]);
  });
  const [offset, keys2] = scanHelper(zKeys, 1, cursor, ...args);
  return [offset, (0, import_lodash15.flatten)(keys2)];
}

// src/commands/zscore.js
function zscore(key, member) {
  const map = this.data.get(key);
  if (!map || !(map instanceof Map)) {
    return null;
  }
  const entry = map.get(member);
  if (!entry) {
    return null;
  }
  return entry.score.toString();
}

// src/commands-stream/index.js
var commands_stream_exports = {};
__export(commands_stream_exports, {
  hscanStream: () => hscanStream,
  scanStream: () => scanStream,
  sscanStream: () => sscanStream,
  zscanStream: () => zscanStream
});

// src/commands-utils/readable-scan.js
var import_stream = __toModule(require("stream"));
var ReadableScan = class extends import_stream.Readable {
  constructor(scanCommand, opt = {}) {
    super({objectMode: true});
    this._scanCommand = scanCommand;
    this._cursor = 0;
    this.opt = opt;
    this._drained = false;
  }
  _callScan() {
    const args = [this._cursor];
    if (this.opt.key) {
      args.unshift(this.opt.key);
    }
    if (this.opt.match) {
      args.push("MATCH", this.opt.match);
    }
    if (this.opt.count) {
      args.push("COUNT", this.opt.count);
    }
    return this._scanCommand(...args);
  }
  _read() {
    if (this._drained) {
      this.push(null);
      return;
    }
    this._callScan().then((res) => {
      const [nextCursor, keys2] = res;
      if (nextCursor === "0") {
        this._drained = true;
      } else {
        this._cursor = nextCursor;
      }
      if (keys2.length > 0)
        this.push(keys2);
      else
        this._read();
    }).catch((err) => process.nextTick(() => this.emit("error", err)));
  }
};
var readable_scan_default = ReadableScan;

// src/commands-stream/hscanStream.js
function hscanStream(key, opt = {}) {
  const options = opt instanceof Object ? opt : {};
  options.key = key;
  return new readable_scan_default(this.hscan, options);
}

// src/commands-stream/scanStream.js
function scanStream(opt) {
  return new readable_scan_default(this.scan, opt);
}

// src/commands-stream/sscanStream.js
function sscanStream(key, opt = {}) {
  const options = opt instanceof Object ? opt : {};
  options.key = key;
  return new readable_scan_default(this.sscan, options);
}

// src/commands-stream/zscanStream.js
function zscanStream(key, opt = {}) {
  const options = opt instanceof Object ? opt : {};
  options.key = key;
  return new readable_scan_default(this.zscan, options);
}

// src/data.js
var import_lodash16 = __toModule(require("lodash"));
function createData(expiresInstance, initial = {}, keyPrefix = "") {
  let raw = {};
  function createInstance(prefix, expires) {
    return Object.freeze({
      clear() {
        raw = {};
      },
      delete(key) {
        if (expires.has(key)) {
          expires.delete(key);
        }
        delete raw[`${prefix}${key}`];
      },
      get(key) {
        if (expires.has(key) && expires.isExpired(key)) {
          this.delete(key);
        }
        const value = raw[`${prefix}${key}`];
        if (Array.isArray(value)) {
          return value.slice();
        }
        if (Buffer.isBuffer(value)) {
          return Buffer.from(value);
        }
        if (value instanceof Set) {
          return new Set(value);
        }
        if (value instanceof Map) {
          return new Map(value);
        }
        if (typeof value === "object" && value) {
          return (0, import_lodash16.assign)({}, value);
        }
        return value;
      },
      has(key) {
        if (expires.has(key) && expires.isExpired(key)) {
          this.delete(key);
        }
        return {}.hasOwnProperty.call(raw, `${prefix}${key}`);
      },
      keys() {
        return Object.keys(raw);
      },
      set(key, val) {
        let item = val;
        if (Array.isArray(val)) {
          item = val.slice();
        } else if (Buffer.isBuffer(val)) {
          item = Buffer.from(val);
        } else if (val instanceof Set) {
          item = new Set(val);
        } else if (val instanceof Map) {
          item = new Map(val);
        } else if (typeof val === "object" && val) {
          item = (0, import_lodash16.assign)({}, val);
        }
        raw[`${prefix}${key}`] = item;
      },
      withKeyPrefix(newKeyPrefix) {
        if (newKeyPrefix === prefix)
          return this;
        return createInstance(newKeyPrefix, expires.withKeyPrefix(newKeyPrefix));
      }
    });
  }
  const data = createInstance(keyPrefix, expiresInstance);
  Object.keys(initial).forEach((key) => data.set(key, initial[key]));
  return data;
}

// src/expires.js
function createExpires(keyPrefix = "") {
  const expires = {};
  function createInstance(prefix) {
    return {
      get(key) {
        return expires[`${prefix}${key}`];
      },
      set(key, timestamp) {
        expires[`${prefix}${key}`] = +timestamp;
      },
      has(key) {
        return {}.hasOwnProperty.call(expires, `${prefix}${key}`);
      },
      isExpired(key) {
        return expires[`${prefix}${key}`] <= Date.now();
      },
      delete(key) {
        delete expires[`${prefix}${key}`];
      },
      withKeyPrefix(newPrefix) {
        if (newPrefix === prefix)
          return this;
        return createInstance(newPrefix);
      }
    };
  }
  return createInstance(keyPrefix);
}

// src/pipeline.js
var import_standard_as_callback2 = __toModule(require("standard-as-callback"));
var Pipeline = class {
  constructor(redis) {
    this.batch = [];
    this.redis = redis;
    this._transactions = 0;
    this.copyCommands();
  }
  copyCommands() {
    Object.keys(commands_exports).forEach((commandName) => {
      const command2 = commands_exports[commandName];
      this[commandName] = this._createCommand(commandName, command2);
    });
    Object.keys(this.redis.customCommands).forEach((commandName) => {
      const command2 = this.redis.customCommands[commandName];
      this[commandName] = this._createCommand(commandName, command2);
    });
  }
  _createCommand(commandName, command2) {
    return (...args) => {
      const lastArgIndex = args.length - 1;
      let callback = args[lastArgIndex];
      if (typeof callback !== "function") {
        callback = void 0;
      } else {
        args.length = lastArgIndex;
      }
      const commandEmulator = command2.bind(this.redis);
      const commandArgs = processArguments(args, commandName, this.redis);
      this._addTransaction(commandEmulator, commandName, commandArgs, callback);
      return this;
    };
  }
  _addTransaction(commandEmulator, commandName, commandArgs, callback) {
    const Promise2 = promise_container_default.get();
    this.batch.push(() => (0, import_standard_as_callback2.default)(new Promise2((resolve) => resolve(safelyExecuteCommand(commandEmulator, commandName, this.redis, ...commandArgs))), callback));
    this._transactions += 1;
  }
  exec(callback) {
    const batch = this.batch;
    const Promise2 = promise_container_default.get();
    this.batch = [];
    return (0, import_standard_as_callback2.default)(Promise2.all(batch.map((cmd) => cmd())).then((replies) => replies.map((reply) => [null, reply])), callback);
  }
};
var pipeline_default = Pipeline;

// src/index.js
var defaultOptions = {
  data: {},
  keyPrefix: "",
  lazyConnect: false,
  notifyKeyspaceEvents: ""
};
var RedisMock = class extends import_events.EventEmitter {
  static get Promise() {
    return promise_container_default.get();
  }
  static set Promise(lib) {
    return promise_container_default.set(lib);
  }
  constructor(options = {}) {
    super();
    this.channels = new import_events.EventEmitter();
    this.patternChannels = new import_events.EventEmitter();
    this.batch = void 0;
    this.connected = false;
    this.subscriberMode = false;
    this.customCommands = {};
    this.shaScripts = {};
    const optionsWithDefault = Object.assign({}, defaultOptions, options);
    this.expires = createExpires(optionsWithDefault.keyPrefix);
    this.data = createData(this.expires, optionsWithDefault.data, optionsWithDefault.keyPrefix);
    this._initCommands();
    this.keyspaceEvents = parseKeyspaceEvents(optionsWithDefault.notifyKeyspaceEvents);
    if (optionsWithDefault.lazyConnect === false) {
      this.connected = true;
      emitConnectEvent(this);
    }
  }
  multi(batch = []) {
    this.batch = new pipeline_default(this);
    this.batch._transactions += 1;
    batch.forEach(([command2, ...options]) => this.batch[command2](...options));
    return this.batch;
  }
  pipeline(batch = []) {
    this.batch = new pipeline_default(this);
    batch.forEach(([command2, ...options]) => this.batch[command2](...options));
    return this.batch;
  }
  exec(callback) {
    const Promise2 = promise_container_default.get();
    if (!this.batch) {
      return Promise2.reject(new Error("ERR EXEC without MULTI"));
    }
    const pipeline = this.batch;
    this.batch = void 0;
    return pipeline.exec(callback);
  }
  createConnectedClient(options = {}) {
    const mock = new RedisMock(options);
    mock.expires = typeof options.keyPrefix === "string" ? this.expires.withKeyPrefix(options.keyPrefix) : this.expires;
    mock.data = typeof options.keyPrefix === "string" ? this.data.withKeyPrefix(options.keyPrefix) : this.data;
    mock.channels = this.channels;
    mock.patternChannels = this.patternChannels;
    return mock;
  }
  disconnect() {
    const removeFrom = ({instanceListeners}) => {
      if (!instanceListeners) {
        return;
      }
      instanceListeners.forEach((mapOfInstanceToListener) => {
        mapOfInstanceToListener.forEach((listener, instance) => {
          if (instance === this) {
            mapOfInstanceToListener.delete(instance);
          }
        });
      });
    };
    removeFrom(this.channels);
    removeFrom(this.patternChannels);
  }
  _initCommands() {
    Object.keys(commands_exports).forEach((command2) => {
      const commandName = command2 === "evaluate" ? "eval" : command2;
      this[commandName] = command(commands_exports[command2].bind(this), commandName, this);
    });
    Object.keys(commands_stream_exports).forEach((command2) => {
      this[command2] = commands_stream_exports[command2].bind(this);
    });
    const supportedCommands = [
      ...import_redis_commands.default.list,
      ...import_redis_commands.default.list.map((command2) => `${command2}Buffer`)
    ];
    const docsLink = "https://github.com/stipsan/ioredis-mock/blob/master/compat.md#supported-commands-";
    supportedCommands.forEach((command2) => {
      if (!(command2 in this)) {
        Object.defineProperty(this, command2, {
          value: () => {
            throw new TypeError(`Unsupported command: ${JSON.stringify(command2)}, please check the full list over mocked commands: ${docsLink}`);
          },
          writable: false
        });
      }
    });
  }
};
RedisMock.prototype.Command = {
  transformers: import_ioredis.Command._transformer,
  setArgumentTransformer: (name, func) => {
    RedisMock.prototype.Command.transformers.argument[name] = func;
  },
  setReplyTransformer: (name, func) => {
    RedisMock.prototype.Command.transformers.reply[name] = func;
  }
};
RedisMock.Cluster = class RedisClusterMock extends RedisMock {
  constructor(nodesOptions) {
    super();
    this.nodes = [];
    nodesOptions.forEach((options) => this.nodes.push(new RedisMock(options)));
  }
};
module.exports = RedisMock;
